syntax = "proto3";
package xatu_cbt;
option go_package = "github.com/ethpandaops/lab/backend/pkg/server/proto/xatu_cbt";

// This file defines the internal XatuCBT service that acts as a pass-through layer
// to upstream CBT data.
//
// Architecture:
// - This service uses upstream CBT proto definitions directly (imported from vendor/)
// - No type transformations occur at this layer - it's a pure pass-through
// - The service enriches the request with network routing via gRPC metadata
// - Data transformation to public API types happens in the REST API layer (cbt_api.proto)
//
// Flow:
// 1. REST API receives request with network in URL path (/api/v1/mainnet/nodes)
// 2. REST handler adds network to gRPC metadata and calls this service
// 3. This service extracts network, routes to appropriate ClickHouse instance
// 4. Returns raw CBT data using upstream types
// 5. REST layer transforms CBT types to public API types

import "vendor/xatu-cbt/clickhouse/fct_node_active_last_24h.proto";
import "vendor/xatu-cbt/clickhouse/common.proto";

// XatuCBT service provides access to CBT data from multiple ClickHouse instances.
// Each RPC corresponds to a specific CBT table/view and uses upstream request/response types.
service XatuCBT {
  // ListFctNodeActiveLast24h queries the fact table of nodes active in the last 24 hours.
  // This table contains node metadata for all nodes seen within a rolling 24-hour window.
  rpc ListFctNodeActiveLast24h(cbt.ListFctNodeActiveLast24hRequest) returns (cbt.ListFctNodeActiveLast24hResponse);
  
  // GetDataAvailability returns the common availability interval across a set of transformation tables.
  // It calculates the overlapping data range for the specified tables and returns slot information.
  rpc GetDataAvailability(GetDataAvailabilityRequest) returns (GetDataAvailabilityResponse);
}

// GetDataAvailabilityRequest defines the request for checking data availability across tables.
message GetDataAvailabilityRequest {
  // List of transformation tables to check for availability.
  // Format: table names without the network prefix (e.g., "fct_attestation_correctness_head").
  repeated string tables = 1;
  
  // The position field name to use for min/max calculation.
  // Common values: "slot_start_date_time", "block_number", etc.
  // If empty, defaults to "slot_start_date_time".
  string position_field = 2;
}

// GetDataAvailabilityResponse returns the data availability information.
message GetDataAvailabilityResponse {
  // Unix timestamp (seconds) of the earliest available data across all tables.
  int64 available_from_timestamp = 1;
  
  // Unix timestamp (seconds) of the latest available data across all tables.
  int64 available_until_timestamp = 2;
  
  // Earliest available slot number (calculated from available_from_timestamp).
  uint64 min_slot = 3;
  
  // Latest available slot number (calculated from available_until_timestamp).
  uint64 max_slot = 4;
  
  // Safe slot for "live" view (head - 2 slots from max_slot).
  uint64 safe_slot = 5;
  
  // The current head slot of the network.
  uint64 head_slot = 6;
  
  // Indicates if data is available (overlapping interval exists).
  bool has_data = 7;
}
