// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

export const zFctAddressAccessChunked10000 = z.object({
  chunk_start_block_number: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Start block number of the chunk',
    })
  ),
  first_accessed_accounts: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Number of accounts first accessed in the chunk',
    })
  ),
  last_accessed_accounts: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Number of accounts last accessed in the chunk',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
});

export const zFctAddressAccessTotal = z.object({
  expired_accounts: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Number of expired accounts (not accessed in last 365 days)',
    })
  ),
  expired_contracts: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Number of expired contracts (not accessed in last 365 days)',
    })
  ),
  total_accounts: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Total number of accounts accessed in last 365 days',
    })
  ),
  total_contract_accounts: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Total number of contract accounts accessed in last 365 days',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
});

export const zFctAddressStorageSlotChunked10000 = z.object({
  chunk_start_block_number: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Start block number of the chunk',
    })
  ),
  first_accessed_slots: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Number of slots first accessed in the chunk',
    })
  ),
  last_accessed_slots: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Number of slots last accessed in the chunk',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
});

export const zFctAddressStorageSlotExpiredTop100ByContract = z.object({
  contract_address: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The contract address',
    })
  ),
  expired_slots: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Number of expired storage slots for this contract',
    })
  ),
  rank: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Rank by expired storage slots (1=highest)',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
});

export const zFctAddressStorageSlotTop100ByContract = z.object({
  contract_address: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The contract address',
    })
  ),
  rank: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Rank by total storage slots (1=highest)',
    })
  ),
  total_storage_slots: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Total number of storage slots for this contract',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
});

export const zFctAddressStorageSlotTotal = z.object({
  expired_storage_slots: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Number of expired storage slots (not accessed in last 365 days)',
    })
  ),
  total_storage_slots: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Total number of storage slots accessed in last 365 days',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
});

export const zFctAttestationCorrectnessByValidatorCanonical = z.object({
  attesting_validator_index: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The index of the validator attesting',
    })
  ),
  block_root: z.optional(z.union([z.string(), z.null()])),
  epoch: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The epoch number containing the slot',
    })
  ),
  epoch_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the epoch started',
    })
  ),
  inclusion_distance: z.optional(z.union([z.int(), z.null()])),
  slot: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The slot number',
    })
  ),
  slot_distance: z.optional(z.union([z.int(), z.null()])),
  slot_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    })
  ),
  status: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Can be "canonical", "orphaned", "missed" or "unknown" (validator attested but block data not available)',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
});

export const zFctAttestationCorrectnessByValidatorHead = z.object({
  attesting_validator_index: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The index of the validator attesting',
    })
  ),
  block_root: z.optional(z.union([z.string(), z.null()])),
  epoch: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The epoch number containing the slot',
    })
  ),
  epoch_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the epoch started',
    })
  ),
  propagation_distance: z.optional(z.union([z.int(), z.null()])),
  slot: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The slot number',
    })
  ),
  slot_distance: z.optional(z.union([z.int(), z.null()])),
  slot_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
});

export const zFctAttestationCorrectnessCanonical = z.object({
  block_root: z.optional(z.union([z.string(), z.null()])),
  epoch: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The epoch number containing the slot',
    })
  ),
  epoch_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the epoch started',
    })
  ),
  slot: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The slot number',
    })
  ),
  slot_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
  votes_head: z.optional(z.union([z.int(), z.null()])),
  votes_max: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The maximum number of scheduled votes for the block',
    })
  ),
  votes_other: z.optional(z.union([z.int(), z.null()])),
});

export const zFctAttestationCorrectnessHead = z.object({
  block_root: z.optional(z.union([z.string(), z.null()])),
  epoch: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The epoch number containing the slot',
    })
  ),
  epoch_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the epoch started',
    })
  ),
  slot: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The slot number',
    })
  ),
  slot_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
  votes_head: z.optional(z.union([z.int(), z.null()])),
  votes_max: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The maximum number of scheduled votes for the block',
    })
  ),
  votes_other: z.optional(z.union([z.int(), z.null()])),
});

export const zFctAttestationFirstSeenChunked50Ms = z.object({
  attestation_count: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The number of attestations in this chunk',
    })
  ),
  block_root: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The beacon block root hash that was attested, null means the attestation was missed',
    })
  ),
  chunk_slot_start_diff: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The different between the chunk start time and slot_start_date_time. "1500" would mean this chunk contains attestations first seen between 1500ms 1550ms into the slot',
    })
  ),
  epoch: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The epoch number containing the slot',
    })
  ),
  epoch_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the epoch started',
    })
  ),
  slot: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The slot number',
    })
  ),
  slot_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
});

export const zFctBlock = z.object({
  block_root: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The root hash of the beacon block',
    })
  ),
  block_total_bytes: z.optional(z.union([z.int(), z.null()])),
  block_total_bytes_compressed: z.optional(z.union([z.int(), z.null()])),
  block_version: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The version of the beacon block',
    })
  ),
  epoch: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The epoch number from beacon block payload',
    })
  ),
  epoch_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the epoch started',
    })
  ),
  eth1_data_block_hash: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The block hash of the associated execution block',
    })
  ),
  eth1_data_deposit_root: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The root of the deposit tree in the associated execution block',
    })
  ),
  execution_payload_base_fee_per_gas: z.optional(z.union([z.string(), z.null()])),
  execution_payload_blob_gas_used: z.optional(z.union([z.int(), z.null()])),
  execution_payload_block_hash: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The block hash of the execution payload',
    })
  ),
  execution_payload_block_number: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The block number of the execution payload',
    })
  ),
  execution_payload_excess_blob_gas: z.optional(z.union([z.int(), z.null()])),
  execution_payload_fee_recipient: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The recipient of the fee for this execution payload',
    })
  ),
  execution_payload_gas_limit: z.optional(z.union([z.int(), z.null()])),
  execution_payload_gas_used: z.optional(z.union([z.int(), z.null()])),
  execution_payload_parent_hash: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The parent hash of the execution payload',
    })
  ),
  execution_payload_state_root: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The state root of the execution payload',
    })
  ),
  execution_payload_transactions_count: z.optional(z.union([z.int(), z.null()])),
  execution_payload_transactions_total_bytes: z.optional(z.union([z.int(), z.null()])),
  execution_payload_transactions_total_bytes_compressed: z.optional(z.union([z.int(), z.null()])),
  parent_root: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The root hash of the parent beacon block',
    })
  ),
  proposer_index: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The index of the validator that proposed the beacon block',
    })
  ),
  slot: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The slot number from beacon block payload',
    })
  ),
  slot_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the reorg slot started',
    })
  ),
  state_root: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The root hash of the beacon state at this block',
    })
  ),
  status: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Can be "canonical" or "orphaned"',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
});

export const zFctBlockBlobCount = z.object({
  blob_count: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The number of blobs in the block',
    })
  ),
  block_root: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The beacon block root hash',
    })
  ),
  epoch: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The epoch number containing the slot',
    })
  ),
  epoch_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the epoch started',
    })
  ),
  slot: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The slot number',
    })
  ),
  slot_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    })
  ),
  status: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Can be "canonical" or "orphaned"',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
});

export const zFctBlockBlobCountHead = z.object({
  blob_count: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The number of blobs in the block',
    })
  ),
  block_root: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The beacon block root hash',
    })
  ),
  epoch: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The epoch number containing the slot',
    })
  ),
  epoch_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the epoch started',
    })
  ),
  slot: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The slot number',
    })
  ),
  slot_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
});

export const zFctBlockBlobFirstSeenByNode = z.object({
  blob_index: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The blob index',
    })
  ),
  block_root: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The beacon block root hash',
    })
  ),
  classification: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified"',
    })
  ),
  epoch: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The epoch number containing the slot',
    })
  ),
  epoch_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the epoch started',
    })
  ),
  meta_client_geo_autonomous_system_number: z.optional(z.union([z.int(), z.null()])),
  meta_client_geo_autonomous_system_organization: z.optional(z.union([z.string(), z.null()])),
  meta_client_geo_city: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'City of the client',
    })
  ),
  meta_client_geo_continent_code: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Continent code of the client',
    })
  ),
  meta_client_geo_country: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Country of the client',
    })
  ),
  meta_client_geo_country_code: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Country code of the client',
    })
  ),
  meta_client_geo_latitude: z.optional(z.union([z.number(), z.null()])),
  meta_client_geo_longitude: z.optional(z.union([z.number(), z.null()])),
  meta_client_implementation: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Implementation of the client',
    })
  ),
  meta_client_name: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Name of the client',
    })
  ),
  meta_client_version: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Version of the client',
    })
  ),
  meta_consensus_implementation: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Ethereum consensus client implementation',
    })
  ),
  meta_consensus_version: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Ethereum consensus client version',
    })
  ),
  node_id: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'ID of the node',
    })
  ),
  seen_slot_start_diff: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The time from slot start for the client to see the block',
    })
  ),
  slot: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The slot number',
    })
  ),
  slot_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    })
  ),
  source: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Source of the event',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
  username: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Username of the node',
    })
  ),
});

export const zFctBlockFirstSeenByNode = z.object({
  block_root: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The beacon block root hash',
    })
  ),
  classification: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified"',
    })
  ),
  epoch: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The epoch number containing the slot',
    })
  ),
  epoch_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the epoch started',
    })
  ),
  meta_client_geo_autonomous_system_number: z.optional(z.union([z.int(), z.null()])),
  meta_client_geo_autonomous_system_organization: z.optional(z.union([z.string(), z.null()])),
  meta_client_geo_city: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'City of the client',
    })
  ),
  meta_client_geo_continent_code: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Continent code of the client',
    })
  ),
  meta_client_geo_country: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Country of the client',
    })
  ),
  meta_client_geo_country_code: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Country code of the client',
    })
  ),
  meta_client_geo_latitude: z.optional(z.union([z.number(), z.null()])),
  meta_client_geo_longitude: z.optional(z.union([z.number(), z.null()])),
  meta_client_implementation: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Implementation of the client',
    })
  ),
  meta_client_name: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Name of the client',
    })
  ),
  meta_client_version: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Version of the client',
    })
  ),
  meta_consensus_implementation: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Ethereum consensus client implementation',
    })
  ),
  meta_consensus_version: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Ethereum consensus client version',
    })
  ),
  node_id: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'ID of the node',
    })
  ),
  seen_slot_start_diff: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The time from slot start for the client to see the block',
    })
  ),
  slot: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The slot number',
    })
  ),
  slot_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    })
  ),
  source: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Source of the event',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
  username: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Username of the node',
    })
  ),
});

export const zFctBlockHead = z.object({
  block_root: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The root hash of the beacon block',
    })
  ),
  block_total_bytes: z.optional(z.union([z.int(), z.null()])),
  block_total_bytes_compressed: z.optional(z.union([z.int(), z.null()])),
  block_version: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The version of the beacon block',
    })
  ),
  epoch: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The epoch number from beacon block payload',
    })
  ),
  epoch_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the epoch started',
    })
  ),
  eth1_data_block_hash: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The block hash of the associated execution block',
    })
  ),
  eth1_data_deposit_root: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The root of the deposit tree in the associated execution block',
    })
  ),
  execution_payload_base_fee_per_gas: z.optional(z.union([z.string(), z.null()])),
  execution_payload_blob_gas_used: z.optional(z.union([z.int(), z.null()])),
  execution_payload_block_hash: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The block hash of the execution payload',
    })
  ),
  execution_payload_block_number: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The block number of the execution payload',
    })
  ),
  execution_payload_excess_blob_gas: z.optional(z.union([z.int(), z.null()])),
  execution_payload_fee_recipient: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The recipient of the fee for this execution payload',
    })
  ),
  execution_payload_gas_limit: z.optional(z.union([z.int(), z.null()])),
  execution_payload_gas_used: z.optional(z.union([z.int(), z.null()])),
  execution_payload_parent_hash: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The parent hash of the execution payload',
    })
  ),
  execution_payload_state_root: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The state root of the execution payload',
    })
  ),
  execution_payload_transactions_count: z.optional(z.union([z.int(), z.null()])),
  execution_payload_transactions_total_bytes: z.optional(z.union([z.int(), z.null()])),
  execution_payload_transactions_total_bytes_compressed: z.optional(z.union([z.int(), z.null()])),
  parent_root: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The root hash of the parent beacon block',
    })
  ),
  proposer_index: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The index of the validator that proposed the beacon block',
    })
  ),
  slot: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The slot number from beacon block payload',
    })
  ),
  slot_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the reorg slot started',
    })
  ),
  state_root: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The root hash of the beacon state at this block',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
});

export const zFctBlockMev = z.object({
  block_hash: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The block hash of the proposer payload',
    })
  ),
  block_number: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The block number of the proposer payload',
    })
  ),
  block_root: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The root hash of the beacon block',
    })
  ),
  builder_pubkey: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The builder pubkey of the proposer payload',
    })
  ),
  earliest_bid_date_time: z.optional(z.union([z.coerce.bigint(), z.null()])),
  epoch: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Epoch number derived from the slot that the proposer payload is for',
    })
  ),
  epoch_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The start time for the epoch that the proposer payload is for',
    })
  ),
  gas_limit: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The gas limit of the proposer payload',
    })
  ),
  gas_used: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The gas used of the proposer payload',
    })
  ),
  parent_hash: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The parent hash of the proposer payload',
    })
  ),
  proposer_fee_recipient: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The proposer fee recipient of the proposer payload',
    })
  ),
  proposer_pubkey: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The proposer pubkey of the proposer payload',
    })
  ),
  relay_names: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description: 'The relay names that delivered the proposer payload',
    })
  ),
  slot: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Slot number within the block proposer payload',
    })
  ),
  slot_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The start time for the slot that the proposer payload is for',
    })
  ),
  status: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Can be "canonical" or "orphaned"',
    })
  ),
  transaction_count: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The number of transactions in the proposer payload',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
  value: z.optional(z.union([z.string(), z.null()])),
});

export const zFctBlockMevHead = z.object({
  block_hash: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The block hash of the proposer payload',
    })
  ),
  block_number: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The block number of the proposer payload',
    })
  ),
  block_root: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The root hash of the beacon block',
    })
  ),
  builder_pubkey: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The builder pubkey of the proposer payload',
    })
  ),
  earliest_bid_date_time: z.optional(z.union([z.coerce.bigint(), z.null()])),
  epoch: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Epoch number derived from the slot that the proposer payload is for',
    })
  ),
  epoch_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The start time for the epoch that the proposer payload is for',
    })
  ),
  gas_limit: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The gas limit of the proposer payload',
    })
  ),
  gas_used: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The gas used of the proposer payload',
    })
  ),
  parent_hash: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The parent hash of the proposer payload',
    })
  ),
  proposer_fee_recipient: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The proposer fee recipient of the proposer payload',
    })
  ),
  proposer_pubkey: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The proposer pubkey of the proposer payload',
    })
  ),
  relay_names: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description: 'The relay names that delivered the proposer payload',
    })
  ),
  slot: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Slot number within the block proposer payload',
    })
  ),
  slot_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The start time for the slot that the proposer payload is for',
    })
  ),
  transaction_count: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The number of transactions in the proposer payload',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
  value: z.optional(z.union([z.string(), z.null()])),
});

export const zFctBlockProposer = z.object({
  block_root: z.optional(z.union([z.string(), z.null()])),
  epoch: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The epoch number containing the slot',
    })
  ),
  epoch_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the epoch started',
    })
  ),
  proposer_pubkey: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The public key of the validator proposer',
    })
  ),
  proposer_validator_index: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The validator index of the proposer for the slot',
    })
  ),
  slot: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The slot number',
    })
  ),
  slot_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    })
  ),
  status: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Can be "canonical", "orphaned" or "missed"',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
});

export const zFctBlockProposerEntity = z.object({
  entity: z.optional(z.union([z.string(), z.null()])),
  epoch: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The epoch number containing the slot',
    })
  ),
  epoch_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the epoch started',
    })
  ),
  slot: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The slot number',
    })
  ),
  slot_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
});

export const zFctBlockProposerHead = z.object({
  block_root: z.optional(z.union([z.string(), z.null()])),
  epoch: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The epoch number containing the slot',
    })
  ),
  epoch_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the epoch started',
    })
  ),
  proposer_pubkey: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The public key of the validator proposer',
    })
  ),
  proposer_validator_index: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The validator index of the proposer for the slot',
    })
  ),
  slot: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The slot number',
    })
  ),
  slot_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
});

export const zFctMevBidCountByBuilder = z.object({
  bid_total: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The total number of bids from the builder',
    })
  ),
  builder_pubkey: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The relay that the bid was fetched from',
    })
  ),
  epoch: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Epoch number derived from the slot that the bid is for',
    })
  ),
  epoch_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The start time for the epoch that the bid is for',
    })
  ),
  slot: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Slot number within the block bid',
    })
  ),
  slot_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The start time for the slot that the bid is for',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
});

export const zFctMevBidCountByRelay = z.object({
  bid_total: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The total number of bids for the relay',
    })
  ),
  epoch: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Epoch number derived from the slot that the bid is for',
    })
  ),
  epoch_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The start time for the epoch that the bid is for',
    })
  ),
  relay_name: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The relay that the bid was fetched from',
    })
  ),
  slot: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Slot number within the block bid',
    })
  ),
  slot_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The start time for the slot that the bid is for',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
});

export const zFctMevBidHighestValueByBuilderChunked50Ms = z.object({
  block_hash: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The execution block hash of the bid',
    })
  ),
  builder_pubkey: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The builder pubkey of the bid',
    })
  ),
  chunk_slot_start_diff: z.optional(
    z.int().register(z.globalRegistry, {
      description:
        'The difference between the chunk start time and slot_start_date_time. "1500" would mean the earliest bid for this block_hash was between 1500ms and 1550ms into the slot. Negative values indicate bids received before slot start',
    })
  ),
  earliest_bid_date_time: z.optional(
    z.coerce.bigint().register(z.globalRegistry, {
      description: 'The timestamp of the earliest bid for this block_hash from this builder',
    })
  ),
  epoch: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Epoch number derived from the slot that the bid is for',
    })
  ),
  epoch_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The start time for the epoch that the bid is for',
    })
  ),
  relay_names: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description: 'The relay that the bid was fetched from',
    })
  ),
  slot: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Slot number within the block bid',
    })
  ),
  slot_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The start time for the slot that the bid is for',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
  value: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The transaction value in wei',
    })
  ),
});

export const zFctNodeActiveLast24h = z.object({
  classification: z.optional(
    z.string().register(z.globalRegistry, {
      description:
        'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified"',
    })
  ),
  last_seen_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the node was last seen',
    })
  ),
  meta_client_geo_autonomous_system_number: z.optional(z.union([z.int(), z.null()])),
  meta_client_geo_autonomous_system_organization: z.optional(z.union([z.string(), z.null()])),
  meta_client_geo_city: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'City of the client',
    })
  ),
  meta_client_geo_continent_code: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Continent code of the client',
    })
  ),
  meta_client_geo_country: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Country of the client',
    })
  ),
  meta_client_geo_country_code: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Country code of the client',
    })
  ),
  meta_client_geo_latitude: z.optional(z.union([z.number(), z.null()])),
  meta_client_geo_longitude: z.optional(z.union([z.number(), z.null()])),
  meta_client_implementation: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Implementation of the client',
    })
  ),
  meta_client_name: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Name of the client',
    })
  ),
  meta_client_version: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Version of the client',
    })
  ),
  meta_consensus_implementation: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Ethereum consensus client implementation',
    })
  ),
  meta_consensus_version: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Ethereum consensus client version',
    })
  ),
  node_id: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'ID of the node',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
  username: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Username of the node',
    })
  ),
});

export const zFctPreparedBlock = z.object({
  block_total_bytes: z.optional(z.union([z.int(), z.null()])),
  block_total_bytes_compressed: z.optional(z.union([z.int(), z.null()])),
  block_version: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'The version of the beacon block',
    })
  ),
  consensus_payload_value: z.optional(z.union([z.int(), z.null()])),
  event_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the event was received',
    })
  ),
  execution_payload_block_number: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The block number of the execution payload',
    })
  ),
  execution_payload_gas_limit: z.optional(z.union([z.int(), z.null()])),
  execution_payload_gas_used: z.optional(z.union([z.int(), z.null()])),
  execution_payload_transactions_count: z.optional(z.union([z.int(), z.null()])),
  execution_payload_transactions_total_bytes: z.optional(z.union([z.int(), z.null()])),
  execution_payload_value: z.optional(z.union([z.int(), z.null()])),
  meta_client_geo_city: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'City of the client that generated the event',
    })
  ),
  meta_client_geo_country: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Country of the client that generated the event',
    })
  ),
  meta_client_geo_country_code: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Country code of the client that generated the event',
    })
  ),
  meta_client_implementation: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Implementation of the client that generated the event',
    })
  ),
  meta_client_name: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Name of the client that generated the event',
    })
  ),
  meta_client_version: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Version of the client that generated the event',
    })
  ),
  meta_consensus_implementation: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Consensus implementation of the validator',
    })
  ),
  meta_consensus_version: z.optional(
    z.string().register(z.globalRegistry, {
      description: 'Consensus version of the validator',
    })
  ),
  slot: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The slot number from beacon block',
    })
  ),
  slot_start_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    })
  ),
  updated_date_time: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    })
  ),
});

/**
 * Response for getting a single fct_address_access_chunked_10000 record
 */
export const zGetFctAddressAccessChunked10000Response = z
  .object({
    item: z.optional(zFctAddressAccessChunked10000),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_address_access_chunked_10000 record',
  });

/**
 * Response for getting a single fct_address_access_total record
 */
export const zGetFctAddressAccessTotalResponse = z
  .object({
    item: z.optional(zFctAddressAccessTotal),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_address_access_total record',
  });

/**
 * Response for getting a single fct_address_storage_slot_chunked_10000 record
 */
export const zGetFctAddressStorageSlotChunked10000Response = z
  .object({
    item: z.optional(zFctAddressStorageSlotChunked10000),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_address_storage_slot_chunked_10000 record',
  });

/**
 * Response for getting a single fct_address_storage_slot_expired_top_100_by_contract record
 */
export const zGetFctAddressStorageSlotExpiredTop100ByContractResponse = z
  .object({
    item: z.optional(zFctAddressStorageSlotExpiredTop100ByContract),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_address_storage_slot_expired_top_100_by_contract record',
  });

/**
 * Response for getting a single fct_address_storage_slot_top_100_by_contract record
 */
export const zGetFctAddressStorageSlotTop100ByContractResponse = z
  .object({
    item: z.optional(zFctAddressStorageSlotTop100ByContract),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_address_storage_slot_top_100_by_contract record',
  });

/**
 * Response for getting a single fct_address_storage_slot_total record
 */
export const zGetFctAddressStorageSlotTotalResponse = z
  .object({
    item: z.optional(zFctAddressStorageSlotTotal),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_address_storage_slot_total record',
  });

/**
 * Response for getting a single fct_attestation_correctness_by_validator_canonical record
 */
export const zGetFctAttestationCorrectnessByValidatorCanonicalResponse = z
  .object({
    item: z.optional(zFctAttestationCorrectnessByValidatorCanonical),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_attestation_correctness_by_validator_canonical record',
  });

/**
 * Response for getting a single fct_attestation_correctness_by_validator_head record
 */
export const zGetFctAttestationCorrectnessByValidatorHeadResponse = z
  .object({
    item: z.optional(zFctAttestationCorrectnessByValidatorHead),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_attestation_correctness_by_validator_head record',
  });

/**
 * Response for getting a single fct_attestation_correctness_canonical record
 */
export const zGetFctAttestationCorrectnessCanonicalResponse = z
  .object({
    item: z.optional(zFctAttestationCorrectnessCanonical),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_attestation_correctness_canonical record',
  });

/**
 * Response for getting a single fct_attestation_correctness_head record
 */
export const zGetFctAttestationCorrectnessHeadResponse = z
  .object({
    item: z.optional(zFctAttestationCorrectnessHead),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_attestation_correctness_head record',
  });

/**
 * Response for getting a single fct_attestation_first_seen_chunked_50ms record
 */
export const zGetFctAttestationFirstSeenChunked50MsResponse = z
  .object({
    item: z.optional(zFctAttestationFirstSeenChunked50Ms),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_attestation_first_seen_chunked_50ms record',
  });

/**
 * Response for getting a single fct_block_blob_count_head record
 */
export const zGetFctBlockBlobCountHeadResponse = z
  .object({
    item: z.optional(zFctBlockBlobCountHead),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_block_blob_count_head record',
  });

/**
 * Response for getting a single fct_block_blob_count record
 */
export const zGetFctBlockBlobCountResponse = z
  .object({
    item: z.optional(zFctBlockBlobCount),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_block_blob_count record',
  });

/**
 * Response for getting a single fct_block_blob_first_seen_by_node record
 */
export const zGetFctBlockBlobFirstSeenByNodeResponse = z
  .object({
    item: z.optional(zFctBlockBlobFirstSeenByNode),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_block_blob_first_seen_by_node record',
  });

/**
 * Response for getting a single fct_block_first_seen_by_node record
 */
export const zGetFctBlockFirstSeenByNodeResponse = z
  .object({
    item: z.optional(zFctBlockFirstSeenByNode),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_block_first_seen_by_node record',
  });

/**
 * Response for getting a single fct_block_head record
 */
export const zGetFctBlockHeadResponse = z
  .object({
    item: z.optional(zFctBlockHead),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_block_head record',
  });

/**
 * Response for getting a single fct_block_mev_head record
 */
export const zGetFctBlockMevHeadResponse = z
  .object({
    item: z.optional(zFctBlockMevHead),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_block_mev_head record',
  });

/**
 * Response for getting a single fct_block_mev record
 */
export const zGetFctBlockMevResponse = z
  .object({
    item: z.optional(zFctBlockMev),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_block_mev record',
  });

/**
 * Response for getting a single fct_block_proposer_entity record
 */
export const zGetFctBlockProposerEntityResponse = z
  .object({
    item: z.optional(zFctBlockProposerEntity),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_block_proposer_entity record',
  });

/**
 * Response for getting a single fct_block_proposer_head record
 */
export const zGetFctBlockProposerHeadResponse = z
  .object({
    item: z.optional(zFctBlockProposerHead),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_block_proposer_head record',
  });

/**
 * Response for getting a single fct_block_proposer record
 */
export const zGetFctBlockProposerResponse = z
  .object({
    item: z.optional(zFctBlockProposer),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_block_proposer record',
  });

/**
 * Response for getting a single fct_block record
 */
export const zGetFctBlockResponse = z
  .object({
    item: z.optional(zFctBlock),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_block record',
  });

/**
 * Response for getting a single fct_mev_bid_count_by_builder record
 */
export const zGetFctMevBidCountByBuilderResponse = z
  .object({
    item: z.optional(zFctMevBidCountByBuilder),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_mev_bid_count_by_builder record',
  });

/**
 * Response for getting a single fct_mev_bid_count_by_relay record
 */
export const zGetFctMevBidCountByRelayResponse = z
  .object({
    item: z.optional(zFctMevBidCountByRelay),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_mev_bid_count_by_relay record',
  });

/**
 * Response for getting a single fct_mev_bid_highest_value_by_builder_chunked_50ms record
 */
export const zGetFctMevBidHighestValueByBuilderChunked50MsResponse = z
  .object({
    item: z.optional(zFctMevBidHighestValueByBuilderChunked50Ms),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_mev_bid_highest_value_by_builder_chunked_50ms record',
  });

/**
 * Response for getting a single fct_node_active_last_24h record
 */
export const zGetFctNodeActiveLast24hResponse = z
  .object({
    item: z.optional(zFctNodeActiveLast24h),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_node_active_last_24h record',
  });

/**
 * Response for getting a single fct_prepared_block record
 */
export const zGetFctPreparedBlockResponse = z
  .object({
    item: z.optional(zFctPreparedBlock),
  })
  .register(z.globalRegistry, {
    description: 'Response for getting a single fct_prepared_block record',
  });

/**
 * Contains an arbitrary serialized message along with a @type that describes the type of the serialized message.
 */
export const zGoogleProtobufAny = z
  .object({
    '@type': z.optional(
      z.string().register(z.globalRegistry, {
        description: 'The type of the serialized message.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description:
      'Contains an arbitrary serialized message along with a @type that describes the type of the serialized message.',
  });

/**
 * Response for listing fct_address_access_chunked_10000 records
 */
export const zListFctAddressAccessChunked10000Response = z
  .object({
    fct_address_access_chunked_10000: z.optional(
      z.array(zFctAddressAccessChunked10000).register(z.globalRegistry, {
        description: 'The list of fct_address_access_chunked_10000.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_address_access_chunked_10000 records',
  });

/**
 * Response for listing fct_address_access_total records
 */
export const zListFctAddressAccessTotalResponse = z
  .object({
    fct_address_access_total: z.optional(
      z.array(zFctAddressAccessTotal).register(z.globalRegistry, {
        description: 'The list of fct_address_access_total.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_address_access_total records',
  });

/**
 * Response for listing fct_address_storage_slot_chunked_10000 records
 */
export const zListFctAddressStorageSlotChunked10000Response = z
  .object({
    fct_address_storage_slot_chunked_10000: z.optional(
      z.array(zFctAddressStorageSlotChunked10000).register(z.globalRegistry, {
        description: 'The list of fct_address_storage_slot_chunked_10000.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_address_storage_slot_chunked_10000 records',
  });

/**
 * Response for listing fct_address_storage_slot_expired_top_100_by_contract records
 */
export const zListFctAddressStorageSlotExpiredTop100ByContractResponse = z
  .object({
    fct_address_storage_slot_expired_top_100_by_contract: z.optional(
      z.array(zFctAddressStorageSlotExpiredTop100ByContract).register(z.globalRegistry, {
        description: 'The list of fct_address_storage_slot_expired_top_100_by_contract.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_address_storage_slot_expired_top_100_by_contract records',
  });

/**
 * Response for listing fct_address_storage_slot_top_100_by_contract records
 */
export const zListFctAddressStorageSlotTop100ByContractResponse = z
  .object({
    fct_address_storage_slot_top_100_by_contract: z.optional(
      z.array(zFctAddressStorageSlotTop100ByContract).register(z.globalRegistry, {
        description: 'The list of fct_address_storage_slot_top_100_by_contract.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_address_storage_slot_top_100_by_contract records',
  });

/**
 * Response for listing fct_address_storage_slot_total records
 */
export const zListFctAddressStorageSlotTotalResponse = z
  .object({
    fct_address_storage_slot_total: z.optional(
      z.array(zFctAddressStorageSlotTotal).register(z.globalRegistry, {
        description: 'The list of fct_address_storage_slot_total.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_address_storage_slot_total records',
  });

/**
 * Response for listing fct_attestation_correctness_by_validator_canonical records
 */
export const zListFctAttestationCorrectnessByValidatorCanonicalResponse = z
  .object({
    fct_attestation_correctness_by_validator_canonical: z.optional(
      z.array(zFctAttestationCorrectnessByValidatorCanonical).register(z.globalRegistry, {
        description: 'The list of fct_attestation_correctness_by_validator_canonical.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_attestation_correctness_by_validator_canonical records',
  });

/**
 * Response for listing fct_attestation_correctness_by_validator_head records
 */
export const zListFctAttestationCorrectnessByValidatorHeadResponse = z
  .object({
    fct_attestation_correctness_by_validator_head: z.optional(
      z.array(zFctAttestationCorrectnessByValidatorHead).register(z.globalRegistry, {
        description: 'The list of fct_attestation_correctness_by_validator_head.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_attestation_correctness_by_validator_head records',
  });

/**
 * Response for listing fct_attestation_correctness_canonical records
 */
export const zListFctAttestationCorrectnessCanonicalResponse = z
  .object({
    fct_attestation_correctness_canonical: z.optional(
      z.array(zFctAttestationCorrectnessCanonical).register(z.globalRegistry, {
        description: 'The list of fct_attestation_correctness_canonical.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_attestation_correctness_canonical records',
  });

/**
 * Response for listing fct_attestation_correctness_head records
 */
export const zListFctAttestationCorrectnessHeadResponse = z
  .object({
    fct_attestation_correctness_head: z.optional(
      z.array(zFctAttestationCorrectnessHead).register(z.globalRegistry, {
        description: 'The list of fct_attestation_correctness_head.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_attestation_correctness_head records',
  });

/**
 * Response for listing fct_attestation_first_seen_chunked_50ms records
 */
export const zListFctAttestationFirstSeenChunked50MsResponse = z
  .object({
    fct_attestation_first_seen_chunked_50ms: z.optional(
      z.array(zFctAttestationFirstSeenChunked50Ms).register(z.globalRegistry, {
        description: 'The list of fct_attestation_first_seen_chunked_50ms.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_attestation_first_seen_chunked_50ms records',
  });

/**
 * Response for listing fct_block_blob_count_head records
 */
export const zListFctBlockBlobCountHeadResponse = z
  .object({
    fct_block_blob_count_head: z.optional(
      z.array(zFctBlockBlobCountHead).register(z.globalRegistry, {
        description: 'The list of fct_block_blob_count_head.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_block_blob_count_head records',
  });

/**
 * Response for listing fct_block_blob_count records
 */
export const zListFctBlockBlobCountResponse = z
  .object({
    fct_block_blob_count: z.optional(
      z.array(zFctBlockBlobCount).register(z.globalRegistry, {
        description: 'The list of fct_block_blob_count.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_block_blob_count records',
  });

/**
 * Response for listing fct_block_blob_first_seen_by_node records
 */
export const zListFctBlockBlobFirstSeenByNodeResponse = z
  .object({
    fct_block_blob_first_seen_by_node: z.optional(
      z.array(zFctBlockBlobFirstSeenByNode).register(z.globalRegistry, {
        description: 'The list of fct_block_blob_first_seen_by_node.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_block_blob_first_seen_by_node records',
  });

/**
 * Response for listing fct_block_first_seen_by_node records
 */
export const zListFctBlockFirstSeenByNodeResponse = z
  .object({
    fct_block_first_seen_by_node: z.optional(
      z.array(zFctBlockFirstSeenByNode).register(z.globalRegistry, {
        description: 'The list of fct_block_first_seen_by_node.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_block_first_seen_by_node records',
  });

/**
 * Response for listing fct_block_head records
 */
export const zListFctBlockHeadResponse = z
  .object({
    fct_block_head: z.optional(
      z.array(zFctBlockHead).register(z.globalRegistry, {
        description: 'The list of fct_block_head.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_block_head records',
  });

/**
 * Response for listing fct_block_mev_head records
 */
export const zListFctBlockMevHeadResponse = z
  .object({
    fct_block_mev_head: z.optional(
      z.array(zFctBlockMevHead).register(z.globalRegistry, {
        description: 'The list of fct_block_mev_head.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_block_mev_head records',
  });

/**
 * Response for listing fct_block_mev records
 */
export const zListFctBlockMevResponse = z
  .object({
    fct_block_mev: z.optional(
      z.array(zFctBlockMev).register(z.globalRegistry, {
        description: 'The list of fct_block_mev.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_block_mev records',
  });

/**
 * Response for listing fct_block_proposer_entity records
 */
export const zListFctBlockProposerEntityResponse = z
  .object({
    fct_block_proposer_entity: z.optional(
      z.array(zFctBlockProposerEntity).register(z.globalRegistry, {
        description: 'The list of fct_block_proposer_entity.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_block_proposer_entity records',
  });

/**
 * Response for listing fct_block_proposer_head records
 */
export const zListFctBlockProposerHeadResponse = z
  .object({
    fct_block_proposer_head: z.optional(
      z.array(zFctBlockProposerHead).register(z.globalRegistry, {
        description: 'The list of fct_block_proposer_head.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_block_proposer_head records',
  });

/**
 * Response for listing fct_block_proposer records
 */
export const zListFctBlockProposerResponse = z
  .object({
    fct_block_proposer: z.optional(
      z.array(zFctBlockProposer).register(z.globalRegistry, {
        description: 'The list of fct_block_proposer.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_block_proposer records',
  });

/**
 * Response for listing fct_block records
 */
export const zListFctBlockResponse = z
  .object({
    fct_block: z.optional(
      z.array(zFctBlock).register(z.globalRegistry, {
        description: 'The list of fct_block.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_block records',
  });

/**
 * Response for listing fct_mev_bid_count_by_builder records
 */
export const zListFctMevBidCountByBuilderResponse = z
  .object({
    fct_mev_bid_count_by_builder: z.optional(
      z.array(zFctMevBidCountByBuilder).register(z.globalRegistry, {
        description: 'The list of fct_mev_bid_count_by_builder.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_mev_bid_count_by_builder records',
  });

/**
 * Response for listing fct_mev_bid_count_by_relay records
 */
export const zListFctMevBidCountByRelayResponse = z
  .object({
    fct_mev_bid_count_by_relay: z.optional(
      z.array(zFctMevBidCountByRelay).register(z.globalRegistry, {
        description: 'The list of fct_mev_bid_count_by_relay.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_mev_bid_count_by_relay records',
  });

/**
 * Response for listing fct_mev_bid_highest_value_by_builder_chunked_50ms records
 */
export const zListFctMevBidHighestValueByBuilderChunked50MsResponse = z
  .object({
    fct_mev_bid_highest_value_by_builder_chunked_50ms: z.optional(
      z.array(zFctMevBidHighestValueByBuilderChunked50Ms).register(z.globalRegistry, {
        description: 'The list of fct_mev_bid_highest_value_by_builder_chunked_50ms.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_mev_bid_highest_value_by_builder_chunked_50ms records',
  });

/**
 * Response for listing fct_node_active_last_24h records
 */
export const zListFctNodeActiveLast24hResponse = z
  .object({
    fct_node_active_last_24h: z.optional(
      z.array(zFctNodeActiveLast24h).register(z.globalRegistry, {
        description: 'The list of fct_node_active_last_24h.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_node_active_last_24h records',
  });

/**
 * Response for listing fct_prepared_block records
 */
export const zListFctPreparedBlockResponse = z
  .object({
    fct_prepared_block: z.optional(
      z.array(zFctPreparedBlock).register(z.globalRegistry, {
        description: 'The list of fct_prepared_block.',
      })
    ),
    next_page_token: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description: 'Response for listing fct_prepared_block records',
  });

/**
 * The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
 */
export const zStatus = z
  .object({
    code: z.optional(
      z.int().register(z.globalRegistry, {
        description: 'The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].',
      })
    ),
    details: z.optional(
      z.array(zGoogleProtobufAny).register(z.globalRegistry, {
        description:
          'A list of messages that carry the error details.  There is a common set of message types for APIs to use.',
      })
    ),
    message: z.optional(
      z.string().register(z.globalRegistry, {
        description:
          'A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.',
      })
    ),
  })
  .register(z.globalRegistry, {
    description:
      'The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).',
  });

export const zFctAddressAccessChunked10000ServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      chunk_start_block_number_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Start block number of the chunk (filter: eq)',
        })
      ),
      chunk_start_block_number_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Start block number of the chunk (filter: ne)',
        })
      ),
      chunk_start_block_number_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Start block number of the chunk (filter: lt)',
        })
      ),
      chunk_start_block_number_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Start block number of the chunk (filter: lte)',
        })
      ),
      chunk_start_block_number_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Start block number of the chunk (filter: gt)',
        })
      ),
      chunk_start_block_number_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Start block number of the chunk (filter: gte)',
        })
      ),
      chunk_start_block_number_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Start block number of the chunk (filter: between_min)',
        })
      ),
      chunk_start_block_number_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Start block number of the chunk (filter: between_max_value)',
        })
      ),
      chunk_start_block_number_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Start block number of the chunk (filter: in_values) (comma-separated list)',
          })
      ),
      chunk_start_block_number_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Start block number of the chunk (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      first_accessed_accounts_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of accounts first accessed in the chunk (filter: eq)',
        })
      ),
      first_accessed_accounts_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of accounts first accessed in the chunk (filter: ne)',
        })
      ),
      first_accessed_accounts_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of accounts first accessed in the chunk (filter: lt)',
        })
      ),
      first_accessed_accounts_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of accounts first accessed in the chunk (filter: lte)',
        })
      ),
      first_accessed_accounts_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of accounts first accessed in the chunk (filter: gt)',
        })
      ),
      first_accessed_accounts_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of accounts first accessed in the chunk (filter: gte)',
        })
      ),
      first_accessed_accounts_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of accounts first accessed in the chunk (filter: between_min)',
        })
      ),
      first_accessed_accounts_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of accounts first accessed in the chunk (filter: between_max_value)',
        })
      ),
      first_accessed_accounts_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Number of accounts first accessed in the chunk (filter: in_values) (comma-separated list)',
          })
      ),
      first_accessed_accounts_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Number of accounts first accessed in the chunk (filter: not_in_values) (comma-separated list)',
          })
      ),
      last_accessed_accounts_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of accounts last accessed in the chunk (filter: eq)',
        })
      ),
      last_accessed_accounts_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of accounts last accessed in the chunk (filter: ne)',
        })
      ),
      last_accessed_accounts_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of accounts last accessed in the chunk (filter: lt)',
        })
      ),
      last_accessed_accounts_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of accounts last accessed in the chunk (filter: lte)',
        })
      ),
      last_accessed_accounts_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of accounts last accessed in the chunk (filter: gt)',
        })
      ),
      last_accessed_accounts_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of accounts last accessed in the chunk (filter: gte)',
        })
      ),
      last_accessed_accounts_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of accounts last accessed in the chunk (filter: between_min)',
        })
      ),
      last_accessed_accounts_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of accounts last accessed in the chunk (filter: between_max_value)',
        })
      ),
      last_accessed_accounts_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Number of accounts last accessed in the chunk (filter: in_values) (comma-separated list)',
          })
      ),
      last_accessed_accounts_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Number of accounts last accessed in the chunk (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_address_access_chunked_10000 to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctAddressAccessChunked10000` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctAddressAccessChunked10000ServiceListResponse = zListFctAddressAccessChunked10000Response;

export const zFctAddressAccessChunked10000ServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    chunk_start_block_number: z.int().register(z.globalRegistry, {
      description: 'Start block number of the chunk',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctAddressAccessChunked10000ServiceGetResponse = zGetFctAddressAccessChunked10000Response;

export const zFctAddressAccessTotalServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      total_accounts_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of accounts accessed in last 365 days (filter: eq)',
        })
      ),
      total_accounts_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of accounts accessed in last 365 days (filter: ne)',
        })
      ),
      total_accounts_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of accounts accessed in last 365 days (filter: lt)',
        })
      ),
      total_accounts_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of accounts accessed in last 365 days (filter: lte)',
        })
      ),
      total_accounts_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of accounts accessed in last 365 days (filter: gt)',
        })
      ),
      total_accounts_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of accounts accessed in last 365 days (filter: gte)',
        })
      ),
      total_accounts_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of accounts accessed in last 365 days (filter: between_min)',
        })
      ),
      total_accounts_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of accounts accessed in last 365 days (filter: between_max_value)',
        })
      ),
      total_accounts_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Total number of accounts accessed in last 365 days (filter: in_values) (comma-separated list)',
          })
      ),
      total_accounts_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Total number of accounts accessed in last 365 days (filter: not_in_values) (comma-separated list)',
          })
      ),
      expired_accounts_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired accounts (not accessed in last 365 days) (filter: eq)',
        })
      ),
      expired_accounts_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired accounts (not accessed in last 365 days) (filter: ne)',
        })
      ),
      expired_accounts_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired accounts (not accessed in last 365 days) (filter: lt)',
        })
      ),
      expired_accounts_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired accounts (not accessed in last 365 days) (filter: lte)',
        })
      ),
      expired_accounts_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired accounts (not accessed in last 365 days) (filter: gt)',
        })
      ),
      expired_accounts_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired accounts (not accessed in last 365 days) (filter: gte)',
        })
      ),
      expired_accounts_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired accounts (not accessed in last 365 days) (filter: between_min)',
        })
      ),
      expired_accounts_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired accounts (not accessed in last 365 days) (filter: between_max_value)',
        })
      ),
      expired_accounts_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Number of expired accounts (not accessed in last 365 days) (filter: in_values) (comma-separated list)',
          })
      ),
      expired_accounts_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Number of expired accounts (not accessed in last 365 days) (filter: not_in_values) (comma-separated list)',
          })
      ),
      total_contract_accounts_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of contract accounts accessed in last 365 days (filter: eq)',
        })
      ),
      total_contract_accounts_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of contract accounts accessed in last 365 days (filter: ne)',
        })
      ),
      total_contract_accounts_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of contract accounts accessed in last 365 days (filter: lt)',
        })
      ),
      total_contract_accounts_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of contract accounts accessed in last 365 days (filter: lte)',
        })
      ),
      total_contract_accounts_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of contract accounts accessed in last 365 days (filter: gt)',
        })
      ),
      total_contract_accounts_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of contract accounts accessed in last 365 days (filter: gte)',
        })
      ),
      total_contract_accounts_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of contract accounts accessed in last 365 days (filter: between_min)',
        })
      ),
      total_contract_accounts_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of contract accounts accessed in last 365 days (filter: between_max_value)',
        })
      ),
      total_contract_accounts_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Total number of contract accounts accessed in last 365 days (filter: in_values) (comma-separated list)',
          })
      ),
      total_contract_accounts_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Total number of contract accounts accessed in last 365 days (filter: not_in_values) (comma-separated list)',
          })
      ),
      expired_contracts_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired contracts (not accessed in last 365 days) (filter: eq)',
        })
      ),
      expired_contracts_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired contracts (not accessed in last 365 days) (filter: ne)',
        })
      ),
      expired_contracts_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired contracts (not accessed in last 365 days) (filter: lt)',
        })
      ),
      expired_contracts_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired contracts (not accessed in last 365 days) (filter: lte)',
        })
      ),
      expired_contracts_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired contracts (not accessed in last 365 days) (filter: gt)',
        })
      ),
      expired_contracts_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired contracts (not accessed in last 365 days) (filter: gte)',
        })
      ),
      expired_contracts_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired contracts (not accessed in last 365 days) (filter: between_min)',
        })
      ),
      expired_contracts_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired contracts (not accessed in last 365 days) (filter: between_max_value)',
        })
      ),
      expired_contracts_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Number of expired contracts (not accessed in last 365 days) (filter: in_values) (comma-separated list)',
          })
      ),
      expired_contracts_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Number of expired contracts (not accessed in last 365 days) (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_address_access_total to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctAddressAccessTotal` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctAddressAccessTotalServiceListResponse = zListFctAddressAccessTotalResponse;

export const zFctAddressAccessTotalServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    updated_date_time: z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctAddressAccessTotalServiceGetResponse = zGetFctAddressAccessTotalResponse;

export const zFctAddressStorageSlotChunked10000ServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      chunk_start_block_number_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Start block number of the chunk (filter: eq)',
        })
      ),
      chunk_start_block_number_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Start block number of the chunk (filter: ne)',
        })
      ),
      chunk_start_block_number_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Start block number of the chunk (filter: lt)',
        })
      ),
      chunk_start_block_number_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Start block number of the chunk (filter: lte)',
        })
      ),
      chunk_start_block_number_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Start block number of the chunk (filter: gt)',
        })
      ),
      chunk_start_block_number_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Start block number of the chunk (filter: gte)',
        })
      ),
      chunk_start_block_number_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Start block number of the chunk (filter: between_min)',
        })
      ),
      chunk_start_block_number_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Start block number of the chunk (filter: between_max_value)',
        })
      ),
      chunk_start_block_number_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Start block number of the chunk (filter: in_values) (comma-separated list)',
          })
      ),
      chunk_start_block_number_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Start block number of the chunk (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      first_accessed_slots_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of slots first accessed in the chunk (filter: eq)',
        })
      ),
      first_accessed_slots_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of slots first accessed in the chunk (filter: ne)',
        })
      ),
      first_accessed_slots_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of slots first accessed in the chunk (filter: lt)',
        })
      ),
      first_accessed_slots_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of slots first accessed in the chunk (filter: lte)',
        })
      ),
      first_accessed_slots_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of slots first accessed in the chunk (filter: gt)',
        })
      ),
      first_accessed_slots_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of slots first accessed in the chunk (filter: gte)',
        })
      ),
      first_accessed_slots_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of slots first accessed in the chunk (filter: between_min)',
        })
      ),
      first_accessed_slots_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of slots first accessed in the chunk (filter: between_max_value)',
        })
      ),
      first_accessed_slots_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Number of slots first accessed in the chunk (filter: in_values) (comma-separated list)',
          })
      ),
      first_accessed_slots_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Number of slots first accessed in the chunk (filter: not_in_values) (comma-separated list)',
          })
      ),
      last_accessed_slots_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of slots last accessed in the chunk (filter: eq)',
        })
      ),
      last_accessed_slots_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of slots last accessed in the chunk (filter: ne)',
        })
      ),
      last_accessed_slots_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of slots last accessed in the chunk (filter: lt)',
        })
      ),
      last_accessed_slots_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of slots last accessed in the chunk (filter: lte)',
        })
      ),
      last_accessed_slots_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of slots last accessed in the chunk (filter: gt)',
        })
      ),
      last_accessed_slots_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of slots last accessed in the chunk (filter: gte)',
        })
      ),
      last_accessed_slots_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of slots last accessed in the chunk (filter: between_min)',
        })
      ),
      last_accessed_slots_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of slots last accessed in the chunk (filter: between_max_value)',
        })
      ),
      last_accessed_slots_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Number of slots last accessed in the chunk (filter: in_values) (comma-separated list)',
          })
      ),
      last_accessed_slots_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Number of slots last accessed in the chunk (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_address_storage_slot_chunked_10000 to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctAddressStorageSlotChunked10000` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctAddressStorageSlotChunked10000ServiceListResponse = zListFctAddressStorageSlotChunked10000Response;

export const zFctAddressStorageSlotChunked10000ServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    chunk_start_block_number: z.int().register(z.globalRegistry, {
      description: 'Start block number of the chunk',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctAddressStorageSlotChunked10000ServiceGetResponse = zGetFctAddressStorageSlotChunked10000Response;

export const zFctAddressStorageSlotExpiredTop100ByContractServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      rank_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Rank by expired storage slots (1=highest) (filter: eq)',
        })
      ),
      rank_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Rank by expired storage slots (1=highest) (filter: ne)',
        })
      ),
      rank_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Rank by expired storage slots (1=highest) (filter: lt)',
        })
      ),
      rank_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Rank by expired storage slots (1=highest) (filter: lte)',
        })
      ),
      rank_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Rank by expired storage slots (1=highest) (filter: gt)',
        })
      ),
      rank_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Rank by expired storage slots (1=highest) (filter: gte)',
        })
      ),
      rank_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Rank by expired storage slots (1=highest) (filter: between_min)',
        })
      ),
      rank_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Rank by expired storage slots (1=highest) (filter: between_max_value)',
        })
      ),
      rank_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Rank by expired storage slots (1=highest) (filter: in_values) (comma-separated list)',
          })
      ),
      rank_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Rank by expired storage slots (1=highest) (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      contract_address_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The contract address (filter: eq)',
        })
      ),
      contract_address_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The contract address (filter: ne)',
        })
      ),
      contract_address_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The contract address (filter: contains)',
        })
      ),
      contract_address_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The contract address (filter: starts_with)',
        })
      ),
      contract_address_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The contract address (filter: ends_with)',
        })
      ),
      contract_address_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The contract address (filter: like)',
        })
      ),
      contract_address_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The contract address (filter: not_like)',
        })
      ),
      contract_address_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The contract address (filter: in_values) (comma-separated list)',
          })
      ),
      contract_address_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The contract address (filter: not_in_values) (comma-separated list)',
          })
      ),
      expired_slots_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired storage slots for this contract (filter: eq)',
        })
      ),
      expired_slots_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired storage slots for this contract (filter: ne)',
        })
      ),
      expired_slots_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired storage slots for this contract (filter: lt)',
        })
      ),
      expired_slots_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired storage slots for this contract (filter: lte)',
        })
      ),
      expired_slots_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired storage slots for this contract (filter: gt)',
        })
      ),
      expired_slots_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired storage slots for this contract (filter: gte)',
        })
      ),
      expired_slots_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired storage slots for this contract (filter: between_min)',
        })
      ),
      expired_slots_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired storage slots for this contract (filter: between_max_value)',
        })
      ),
      expired_slots_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Number of expired storage slots for this contract (filter: in_values) (comma-separated list)',
          })
      ),
      expired_slots_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Number of expired storage slots for this contract (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_address_storage_slot_expired_top_100_by_contract to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctAddressStorageSlotExpiredTop100ByContract` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctAddressStorageSlotExpiredTop100ByContractServiceListResponse =
  zListFctAddressStorageSlotExpiredTop100ByContractResponse;

export const zFctAddressStorageSlotExpiredTop100ByContractServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    rank: z.int().register(z.globalRegistry, {
      description: 'Rank by expired storage slots (1=highest)',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctAddressStorageSlotExpiredTop100ByContractServiceGetResponse =
  zGetFctAddressStorageSlotExpiredTop100ByContractResponse;

export const zFctAddressStorageSlotTop100ByContractServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      rank_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Rank by total storage slots (1=highest) (filter: eq)',
        })
      ),
      rank_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Rank by total storage slots (1=highest) (filter: ne)',
        })
      ),
      rank_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Rank by total storage slots (1=highest) (filter: lt)',
        })
      ),
      rank_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Rank by total storage slots (1=highest) (filter: lte)',
        })
      ),
      rank_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Rank by total storage slots (1=highest) (filter: gt)',
        })
      ),
      rank_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Rank by total storage slots (1=highest) (filter: gte)',
        })
      ),
      rank_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Rank by total storage slots (1=highest) (filter: between_min)',
        })
      ),
      rank_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Rank by total storage slots (1=highest) (filter: between_max_value)',
        })
      ),
      rank_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Rank by total storage slots (1=highest) (filter: in_values) (comma-separated list)',
          })
      ),
      rank_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Rank by total storage slots (1=highest) (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      contract_address_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The contract address (filter: eq)',
        })
      ),
      contract_address_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The contract address (filter: ne)',
        })
      ),
      contract_address_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The contract address (filter: contains)',
        })
      ),
      contract_address_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The contract address (filter: starts_with)',
        })
      ),
      contract_address_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The contract address (filter: ends_with)',
        })
      ),
      contract_address_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The contract address (filter: like)',
        })
      ),
      contract_address_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The contract address (filter: not_like)',
        })
      ),
      contract_address_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The contract address (filter: in_values) (comma-separated list)',
          })
      ),
      contract_address_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The contract address (filter: not_in_values) (comma-separated list)',
          })
      ),
      total_storage_slots_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of storage slots for this contract (filter: eq)',
        })
      ),
      total_storage_slots_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of storage slots for this contract (filter: ne)',
        })
      ),
      total_storage_slots_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of storage slots for this contract (filter: lt)',
        })
      ),
      total_storage_slots_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of storage slots for this contract (filter: lte)',
        })
      ),
      total_storage_slots_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of storage slots for this contract (filter: gt)',
        })
      ),
      total_storage_slots_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of storage slots for this contract (filter: gte)',
        })
      ),
      total_storage_slots_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of storage slots for this contract (filter: between_min)',
        })
      ),
      total_storage_slots_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of storage slots for this contract (filter: between_max_value)',
        })
      ),
      total_storage_slots_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Total number of storage slots for this contract (filter: in_values) (comma-separated list)',
          })
      ),
      total_storage_slots_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Total number of storage slots for this contract (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_address_storage_slot_top_100_by_contract to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctAddressStorageSlotTop100ByContract` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctAddressStorageSlotTop100ByContractServiceListResponse =
  zListFctAddressStorageSlotTop100ByContractResponse;

export const zFctAddressStorageSlotTop100ByContractServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    rank: z.int().register(z.globalRegistry, {
      description: 'Rank by total storage slots (1=highest)',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctAddressStorageSlotTop100ByContractServiceGetResponse =
  zGetFctAddressStorageSlotTop100ByContractResponse;

export const zFctAddressStorageSlotTotalServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      total_storage_slots_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of storage slots accessed in last 365 days (filter: eq)',
        })
      ),
      total_storage_slots_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of storage slots accessed in last 365 days (filter: ne)',
        })
      ),
      total_storage_slots_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of storage slots accessed in last 365 days (filter: lt)',
        })
      ),
      total_storage_slots_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of storage slots accessed in last 365 days (filter: lte)',
        })
      ),
      total_storage_slots_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of storage slots accessed in last 365 days (filter: gt)',
        })
      ),
      total_storage_slots_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of storage slots accessed in last 365 days (filter: gte)',
        })
      ),
      total_storage_slots_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of storage slots accessed in last 365 days (filter: between_min)',
        })
      ),
      total_storage_slots_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Total number of storage slots accessed in last 365 days (filter: between_max_value)',
        })
      ),
      total_storage_slots_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Total number of storage slots accessed in last 365 days (filter: in_values) (comma-separated list)',
          })
      ),
      total_storage_slots_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Total number of storage slots accessed in last 365 days (filter: not_in_values) (comma-separated list)',
          })
      ),
      expired_storage_slots_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired storage slots (not accessed in last 365 days) (filter: eq)',
        })
      ),
      expired_storage_slots_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired storage slots (not accessed in last 365 days) (filter: ne)',
        })
      ),
      expired_storage_slots_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired storage slots (not accessed in last 365 days) (filter: lt)',
        })
      ),
      expired_storage_slots_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired storage slots (not accessed in last 365 days) (filter: lte)',
        })
      ),
      expired_storage_slots_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired storage slots (not accessed in last 365 days) (filter: gt)',
        })
      ),
      expired_storage_slots_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired storage slots (not accessed in last 365 days) (filter: gte)',
        })
      ),
      expired_storage_slots_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired storage slots (not accessed in last 365 days) (filter: between_min)',
        })
      ),
      expired_storage_slots_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Number of expired storage slots (not accessed in last 365 days) (filter: between_max_value)',
        })
      ),
      expired_storage_slots_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Number of expired storage slots (not accessed in last 365 days) (filter: in_values) (comma-separated list)',
          })
      ),
      expired_storage_slots_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Number of expired storage slots (not accessed in last 365 days) (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_address_storage_slot_total to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctAddressStorageSlotTotal` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctAddressStorageSlotTotalServiceListResponse = zListFctAddressStorageSlotTotalResponse;

export const zFctAddressStorageSlotTotalServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    updated_date_time: z.int().register(z.globalRegistry, {
      description: 'Timestamp when the record was last updated',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctAddressStorageSlotTotalServiceGetResponse = zGetFctAddressStorageSlotTotalResponse;

export const zFctAttestationCorrectnessByValidatorCanonicalServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      slot_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: eq)',
        })
      ),
      slot_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: ne)',
        })
      ),
      slot_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lt)',
        })
      ),
      slot_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lte)',
        })
      ),
      slot_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gt)',
        })
      ),
      slot_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gte)',
        })
      ),
      slot_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_min)',
        })
      ),
      slot_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_max_value)',
        })
      ),
      slot_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: in_values) (comma-separated list)',
          })
      ),
      slot_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: not_in_values) (comma-separated list)',
          })
      ),
      attesting_validator_index_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator attesting (filter: eq)',
        })
      ),
      attesting_validator_index_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator attesting (filter: ne)',
        })
      ),
      attesting_validator_index_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator attesting (filter: lt)',
        })
      ),
      attesting_validator_index_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator attesting (filter: lte)',
        })
      ),
      attesting_validator_index_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator attesting (filter: gt)',
        })
      ),
      attesting_validator_index_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator attesting (filter: gte)',
        })
      ),
      attesting_validator_index_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator attesting (filter: between_min)',
        })
      ),
      attesting_validator_index_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator attesting (filter: between_max_value)',
        })
      ),
      attesting_validator_index_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The index of the validator attesting (filter: in_values) (comma-separated list)',
          })
      ),
      attesting_validator_index_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The index of the validator attesting (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      slot_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: eq)',
        })
      ),
      slot_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: ne)',
        })
      ),
      slot_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: lt)',
        })
      ),
      slot_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: lte)',
        })
      ),
      slot_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: gt)',
        })
      ),
      slot_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: gte)',
        })
      ),
      slot_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: between_min)',
        })
      ),
      slot_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: between_max_value)',
        })
      ),
      slot_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number (filter: in_values) (comma-separated list)',
          })
      ),
      slot_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: eq)',
        })
      ),
      epoch_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: ne)',
        })
      ),
      epoch_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: lt)',
        })
      ),
      epoch_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: lte)',
        })
      ),
      epoch_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: gt)',
        })
      ),
      epoch_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: gte)',
        })
      ),
      epoch_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: between_min)',
        })
      ),
      epoch_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: between_max_value)',
        })
      ),
      epoch_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number containing the slot (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number containing the slot (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: eq)',
        })
      ),
      epoch_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: ne)',
        })
      ),
      epoch_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lt)',
        })
      ),
      epoch_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lte)',
        })
      ),
      epoch_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gt)',
        })
      ),
      epoch_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gte)',
        })
      ),
      epoch_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_min)',
        })
      ),
      epoch_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_max_value)',
        })
      ),
      epoch_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_root_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash that was attested (filter: eq)',
        })
      ),
      block_root_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash that was attested (filter: ne)',
        })
      ),
      block_root_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash that was attested (filter: contains)',
        })
      ),
      block_root_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash that was attested (filter: starts_with)',
        })
      ),
      block_root_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash that was attested (filter: ends_with)',
        })
      ),
      block_root_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash that was attested (filter: like)',
        })
      ),
      block_root_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash that was attested (filter: not_like)',
        })
      ),
      block_root_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The beacon block root hash that was attested (filter: in_values) (comma-separated list)',
          })
      ),
      block_root_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The beacon block root hash that was attested (filter: not_in_values) (comma-separated list)',
          })
      ),
      slot_distance_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot to the attested block. If the attested block is the same as the slot, the distance is 0, if the attested block is the previous slot, the distance is 1, etc. If null, the attestation was missed, the block was orphaned and never seen by a sentry or the block was more than 64 slots ago (filter: eq)',
        })
      ),
      slot_distance_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot to the attested block. If the attested block is the same as the slot, the distance is 0, if the attested block is the previous slot, the distance is 1, etc. If null, the attestation was missed, the block was orphaned and never seen by a sentry or the block was more than 64 slots ago (filter: ne)',
        })
      ),
      slot_distance_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot to the attested block. If the attested block is the same as the slot, the distance is 0, if the attested block is the previous slot, the distance is 1, etc. If null, the attestation was missed, the block was orphaned and never seen by a sentry or the block was more than 64 slots ago (filter: lt)',
        })
      ),
      slot_distance_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot to the attested block. If the attested block is the same as the slot, the distance is 0, if the attested block is the previous slot, the distance is 1, etc. If null, the attestation was missed, the block was orphaned and never seen by a sentry or the block was more than 64 slots ago (filter: lte)',
        })
      ),
      slot_distance_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot to the attested block. If the attested block is the same as the slot, the distance is 0, if the attested block is the previous slot, the distance is 1, etc. If null, the attestation was missed, the block was orphaned and never seen by a sentry or the block was more than 64 slots ago (filter: gt)',
        })
      ),
      slot_distance_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot to the attested block. If the attested block is the same as the slot, the distance is 0, if the attested block is the previous slot, the distance is 1, etc. If null, the attestation was missed, the block was orphaned and never seen by a sentry or the block was more than 64 slots ago (filter: gte)',
        })
      ),
      slot_distance_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot to the attested block. If the attested block is the same as the slot, the distance is 0, if the attested block is the previous slot, the distance is 1, etc. If null, the attestation was missed, the block was orphaned and never seen by a sentry or the block was more than 64 slots ago (filter: between_min)',
        })
      ),
      slot_distance_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot to the attested block. If the attested block is the same as the slot, the distance is 0, if the attested block is the previous slot, the distance is 1, etc. If null, the attestation was missed, the block was orphaned and never seen by a sentry or the block was more than 64 slots ago (filter: between_max_value)',
        })
      ),
      slot_distance_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The distance from the slot to the attested block. If the attested block is the same as the slot, the distance is 0, if the attested block is the previous slot, the distance is 1, etc. If null, the attestation was missed, the block was orphaned and never seen by a sentry or the block was more than 64 slots ago (filter: in_values) (comma-separated list)',
          })
      ),
      slot_distance_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The distance from the slot to the attested block. If the attested block is the same as the slot, the distance is 0, if the attested block is the previous slot, the distance is 1, etc. If null, the attestation was missed, the block was orphaned and never seen by a sentry or the block was more than 64 slots ago (filter: not_in_values) (comma-separated list)',
          })
      ),
      inclusion_distance_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The distance from the slot when the attestation was included in a block (filter: eq)',
        })
      ),
      inclusion_distance_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The distance from the slot when the attestation was included in a block (filter: ne)',
        })
      ),
      inclusion_distance_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The distance from the slot when the attestation was included in a block (filter: lt)',
        })
      ),
      inclusion_distance_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The distance from the slot when the attestation was included in a block (filter: lte)',
        })
      ),
      inclusion_distance_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The distance from the slot when the attestation was included in a block (filter: gt)',
        })
      ),
      inclusion_distance_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The distance from the slot when the attestation was included in a block (filter: gte)',
        })
      ),
      inclusion_distance_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The distance from the slot when the attestation was included in a block (filter: between_min)',
        })
      ),
      inclusion_distance_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot when the attestation was included in a block (filter: between_max_value)',
        })
      ),
      inclusion_distance_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The distance from the slot when the attestation was included in a block (filter: in_values) (comma-separated list)',
          })
      ),
      inclusion_distance_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The distance from the slot when the attestation was included in a block (filter: not_in_values) (comma-separated list)',
          })
      ),
      status_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Can be "canonical", "orphaned", "missed" or "unknown" (validator attested but block data not available) (filter: eq)',
        })
      ),
      status_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Can be "canonical", "orphaned", "missed" or "unknown" (validator attested but block data not available) (filter: ne)',
        })
      ),
      status_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Can be "canonical", "orphaned", "missed" or "unknown" (validator attested but block data not available) (filter: contains)',
        })
      ),
      status_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Can be "canonical", "orphaned", "missed" or "unknown" (validator attested but block data not available) (filter: starts_with)',
        })
      ),
      status_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Can be "canonical", "orphaned", "missed" or "unknown" (validator attested but block data not available) (filter: ends_with)',
        })
      ),
      status_like: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Can be "canonical", "orphaned", "missed" or "unknown" (validator attested but block data not available) (filter: like)',
        })
      ),
      status_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Can be "canonical", "orphaned", "missed" or "unknown" (validator attested but block data not available) (filter: not_like)',
        })
      ),
      status_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'Can be "canonical", "orphaned", "missed" or "unknown" (validator attested but block data not available) (filter: in_values) (comma-separated list)',
          })
      ),
      status_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'Can be "canonical", "orphaned", "missed" or "unknown" (validator attested but block data not available) (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_attestation_correctness_by_validator_canonical to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctAttestationCorrectnessByValidatorCanonical` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctAttestationCorrectnessByValidatorCanonicalServiceListResponse =
  zListFctAttestationCorrectnessByValidatorCanonicalResponse;

export const zFctAttestationCorrectnessByValidatorCanonicalServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    slot_start_date_time: z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctAttestationCorrectnessByValidatorCanonicalServiceGetResponse =
  zGetFctAttestationCorrectnessByValidatorCanonicalResponse;

export const zFctAttestationCorrectnessByValidatorHeadServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      slot_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: eq)',
        })
      ),
      slot_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: ne)',
        })
      ),
      slot_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lt)',
        })
      ),
      slot_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lte)',
        })
      ),
      slot_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gt)',
        })
      ),
      slot_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gte)',
        })
      ),
      slot_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_min)',
        })
      ),
      slot_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_max_value)',
        })
      ),
      slot_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: in_values) (comma-separated list)',
          })
      ),
      slot_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: not_in_values) (comma-separated list)',
          })
      ),
      attesting_validator_index_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator attesting (filter: eq)',
        })
      ),
      attesting_validator_index_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator attesting (filter: ne)',
        })
      ),
      attesting_validator_index_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator attesting (filter: lt)',
        })
      ),
      attesting_validator_index_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator attesting (filter: lte)',
        })
      ),
      attesting_validator_index_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator attesting (filter: gt)',
        })
      ),
      attesting_validator_index_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator attesting (filter: gte)',
        })
      ),
      attesting_validator_index_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator attesting (filter: between_min)',
        })
      ),
      attesting_validator_index_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator attesting (filter: between_max_value)',
        })
      ),
      attesting_validator_index_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The index of the validator attesting (filter: in_values) (comma-separated list)',
          })
      ),
      attesting_validator_index_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The index of the validator attesting (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      slot_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: eq)',
        })
      ),
      slot_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: ne)',
        })
      ),
      slot_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: lt)',
        })
      ),
      slot_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: lte)',
        })
      ),
      slot_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: gt)',
        })
      ),
      slot_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: gte)',
        })
      ),
      slot_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: between_min)',
        })
      ),
      slot_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: between_max_value)',
        })
      ),
      slot_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number (filter: in_values) (comma-separated list)',
          })
      ),
      slot_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: eq)',
        })
      ),
      epoch_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: ne)',
        })
      ),
      epoch_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: lt)',
        })
      ),
      epoch_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: lte)',
        })
      ),
      epoch_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: gt)',
        })
      ),
      epoch_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: gte)',
        })
      ),
      epoch_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: between_min)',
        })
      ),
      epoch_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: between_max_value)',
        })
      ),
      epoch_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number containing the slot (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number containing the slot (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: eq)',
        })
      ),
      epoch_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: ne)',
        })
      ),
      epoch_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lt)',
        })
      ),
      epoch_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lte)',
        })
      ),
      epoch_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gt)',
        })
      ),
      epoch_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gte)',
        })
      ),
      epoch_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_min)',
        })
      ),
      epoch_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_max_value)',
        })
      ),
      epoch_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_root_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The beacon block root hash that was attested, null means the attestation was missed (filter: eq)',
        })
      ),
      block_root_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The beacon block root hash that was attested, null means the attestation was missed (filter: ne)',
        })
      ),
      block_root_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The beacon block root hash that was attested, null means the attestation was missed (filter: contains)',
        })
      ),
      block_root_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The beacon block root hash that was attested, null means the attestation was missed (filter: starts_with)',
        })
      ),
      block_root_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The beacon block root hash that was attested, null means the attestation was missed (filter: ends_with)',
        })
      ),
      block_root_like: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The beacon block root hash that was attested, null means the attestation was missed (filter: like)',
        })
      ),
      block_root_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The beacon block root hash that was attested, null means the attestation was missed (filter: not_like)',
        })
      ),
      block_root_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'The beacon block root hash that was attested, null means the attestation was missed (filter: in_values) (comma-separated list)',
          })
      ),
      block_root_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'The beacon block root hash that was attested, null means the attestation was missed (filter: not_in_values) (comma-separated list)',
          })
      ),
      slot_distance_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot to the attested block. If the attested block is the same as the slot, the distance is 0, if the attested block is the previous slot, the distance is 1, etc. If null, the attestation was missed, the block was orphaned and never seen by a sentry or the block was more than 64 slots ago (filter: eq)',
        })
      ),
      slot_distance_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot to the attested block. If the attested block is the same as the slot, the distance is 0, if the attested block is the previous slot, the distance is 1, etc. If null, the attestation was missed, the block was orphaned and never seen by a sentry or the block was more than 64 slots ago (filter: ne)',
        })
      ),
      slot_distance_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot to the attested block. If the attested block is the same as the slot, the distance is 0, if the attested block is the previous slot, the distance is 1, etc. If null, the attestation was missed, the block was orphaned and never seen by a sentry or the block was more than 64 slots ago (filter: lt)',
        })
      ),
      slot_distance_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot to the attested block. If the attested block is the same as the slot, the distance is 0, if the attested block is the previous slot, the distance is 1, etc. If null, the attestation was missed, the block was orphaned and never seen by a sentry or the block was more than 64 slots ago (filter: lte)',
        })
      ),
      slot_distance_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot to the attested block. If the attested block is the same as the slot, the distance is 0, if the attested block is the previous slot, the distance is 1, etc. If null, the attestation was missed, the block was orphaned and never seen by a sentry or the block was more than 64 slots ago (filter: gt)',
        })
      ),
      slot_distance_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot to the attested block. If the attested block is the same as the slot, the distance is 0, if the attested block is the previous slot, the distance is 1, etc. If null, the attestation was missed, the block was orphaned and never seen by a sentry or the block was more than 64 slots ago (filter: gte)',
        })
      ),
      slot_distance_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot to the attested block. If the attested block is the same as the slot, the distance is 0, if the attested block is the previous slot, the distance is 1, etc. If null, the attestation was missed, the block was orphaned and never seen by a sentry or the block was more than 64 slots ago (filter: between_min)',
        })
      ),
      slot_distance_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot to the attested block. If the attested block is the same as the slot, the distance is 0, if the attested block is the previous slot, the distance is 1, etc. If null, the attestation was missed, the block was orphaned and never seen by a sentry or the block was more than 64 slots ago (filter: between_max_value)',
        })
      ),
      slot_distance_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The distance from the slot to the attested block. If the attested block is the same as the slot, the distance is 0, if the attested block is the previous slot, the distance is 1, etc. If null, the attestation was missed, the block was orphaned and never seen by a sentry or the block was more than 64 slots ago (filter: in_values) (comma-separated list)',
          })
      ),
      slot_distance_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The distance from the slot to the attested block. If the attested block is the same as the slot, the distance is 0, if the attested block is the previous slot, the distance is 1, etc. If null, the attestation was missed, the block was orphaned and never seen by a sentry or the block was more than 64 slots ago (filter: not_in_values) (comma-separated list)',
          })
      ),
      propagation_distance_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot when the attestation was propagated. 0 means the attestation was propagated within the same slot as its duty was assigned, 1 means the attestation was propagated within the next slot, etc. (filter: eq)',
        })
      ),
      propagation_distance_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot when the attestation was propagated. 0 means the attestation was propagated within the same slot as its duty was assigned, 1 means the attestation was propagated within the next slot, etc. (filter: ne)',
        })
      ),
      propagation_distance_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot when the attestation was propagated. 0 means the attestation was propagated within the same slot as its duty was assigned, 1 means the attestation was propagated within the next slot, etc. (filter: lt)',
        })
      ),
      propagation_distance_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot when the attestation was propagated. 0 means the attestation was propagated within the same slot as its duty was assigned, 1 means the attestation was propagated within the next slot, etc. (filter: lte)',
        })
      ),
      propagation_distance_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot when the attestation was propagated. 0 means the attestation was propagated within the same slot as its duty was assigned, 1 means the attestation was propagated within the next slot, etc. (filter: gt)',
        })
      ),
      propagation_distance_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot when the attestation was propagated. 0 means the attestation was propagated within the same slot as its duty was assigned, 1 means the attestation was propagated within the next slot, etc. (filter: gte)',
        })
      ),
      propagation_distance_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot when the attestation was propagated. 0 means the attestation was propagated within the same slot as its duty was assigned, 1 means the attestation was propagated within the next slot, etc. (filter: between_min)',
        })
      ),
      propagation_distance_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The distance from the slot when the attestation was propagated. 0 means the attestation was propagated within the same slot as its duty was assigned, 1 means the attestation was propagated within the next slot, etc. (filter: between_max_value)',
        })
      ),
      propagation_distance_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The distance from the slot when the attestation was propagated. 0 means the attestation was propagated within the same slot as its duty was assigned, 1 means the attestation was propagated within the next slot, etc. (filter: in_values) (comma-separated list)',
          })
      ),
      propagation_distance_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The distance from the slot when the attestation was propagated. 0 means the attestation was propagated within the same slot as its duty was assigned, 1 means the attestation was propagated within the next slot, etc. (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_attestation_correctness_by_validator_head to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctAttestationCorrectnessByValidatorHead` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctAttestationCorrectnessByValidatorHeadServiceListResponse =
  zListFctAttestationCorrectnessByValidatorHeadResponse;

export const zFctAttestationCorrectnessByValidatorHeadServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    slot_start_date_time: z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctAttestationCorrectnessByValidatorHeadServiceGetResponse =
  zGetFctAttestationCorrectnessByValidatorHeadResponse;

export const zFctAttestationCorrectnessCanonicalServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      slot_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: eq)',
        })
      ),
      slot_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: ne)',
        })
      ),
      slot_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lt)',
        })
      ),
      slot_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lte)',
        })
      ),
      slot_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gt)',
        })
      ),
      slot_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gte)',
        })
      ),
      slot_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_min)',
        })
      ),
      slot_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_max_value)',
        })
      ),
      slot_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: in_values) (comma-separated list)',
          })
      ),
      slot_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      slot_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: eq)',
        })
      ),
      slot_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: ne)',
        })
      ),
      slot_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: lt)',
        })
      ),
      slot_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: lte)',
        })
      ),
      slot_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: gt)',
        })
      ),
      slot_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: gte)',
        })
      ),
      slot_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: between_min)',
        })
      ),
      slot_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: between_max_value)',
        })
      ),
      slot_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number (filter: in_values) (comma-separated list)',
          })
      ),
      slot_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: eq)',
        })
      ),
      epoch_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: ne)',
        })
      ),
      epoch_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: lt)',
        })
      ),
      epoch_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: lte)',
        })
      ),
      epoch_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: gt)',
        })
      ),
      epoch_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: gte)',
        })
      ),
      epoch_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: between_min)',
        })
      ),
      epoch_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: between_max_value)',
        })
      ),
      epoch_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number containing the slot (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number containing the slot (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: eq)',
        })
      ),
      epoch_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: ne)',
        })
      ),
      epoch_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lt)',
        })
      ),
      epoch_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lte)',
        })
      ),
      epoch_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gt)',
        })
      ),
      epoch_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gte)',
        })
      ),
      epoch_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_min)',
        })
      ),
      epoch_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_max_value)',
        })
      ),
      epoch_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_root_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: eq)',
        })
      ),
      block_root_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: ne)',
        })
      ),
      block_root_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: contains)',
        })
      ),
      block_root_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: starts_with)',
        })
      ),
      block_root_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: ends_with)',
        })
      ),
      block_root_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: like)',
        })
      ),
      block_root_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: not_like)',
        })
      ),
      block_root_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The beacon block root hash (filter: in_values) (comma-separated list)',
          })
      ),
      block_root_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The beacon block root hash (filter: not_in_values) (comma-separated list)',
          })
      ),
      votes_max_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The maximum number of scheduled votes for the block (filter: eq)',
        })
      ),
      votes_max_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The maximum number of scheduled votes for the block (filter: ne)',
        })
      ),
      votes_max_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The maximum number of scheduled votes for the block (filter: lt)',
        })
      ),
      votes_max_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The maximum number of scheduled votes for the block (filter: lte)',
        })
      ),
      votes_max_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The maximum number of scheduled votes for the block (filter: gt)',
        })
      ),
      votes_max_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The maximum number of scheduled votes for the block (filter: gte)',
        })
      ),
      votes_max_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The maximum number of scheduled votes for the block (filter: between_min)',
        })
      ),
      votes_max_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The maximum number of scheduled votes for the block (filter: between_max_value)',
        })
      ),
      votes_max_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The maximum number of scheduled votes for the block (filter: in_values) (comma-separated list)',
          })
      ),
      votes_max_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The maximum number of scheduled votes for the block (filter: not_in_values) (comma-separated list)',
          })
      ),
      votes_head_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for the block proposed in the current slot (filter: eq)',
        })
      ),
      votes_head_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for the block proposed in the current slot (filter: ne)',
        })
      ),
      votes_head_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for the block proposed in the current slot (filter: lt)',
        })
      ),
      votes_head_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for the block proposed in the current slot (filter: lte)',
        })
      ),
      votes_head_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for the block proposed in the current slot (filter: gt)',
        })
      ),
      votes_head_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for the block proposed in the current slot (filter: gte)',
        })
      ),
      votes_head_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for the block proposed in the current slot (filter: between_min)',
        })
      ),
      votes_head_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for the block proposed in the current slot (filter: between_max_value)',
        })
      ),
      votes_head_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The number of votes for the block proposed in the current slot (filter: in_values) (comma-separated list)',
          })
      ),
      votes_head_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The number of votes for the block proposed in the current slot (filter: not_in_values) (comma-separated list)',
          })
      ),
      votes_other_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for any blocks proposed in previous slots (filter: eq)',
        })
      ),
      votes_other_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for any blocks proposed in previous slots (filter: ne)',
        })
      ),
      votes_other_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for any blocks proposed in previous slots (filter: lt)',
        })
      ),
      votes_other_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for any blocks proposed in previous slots (filter: lte)',
        })
      ),
      votes_other_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for any blocks proposed in previous slots (filter: gt)',
        })
      ),
      votes_other_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for any blocks proposed in previous slots (filter: gte)',
        })
      ),
      votes_other_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for any blocks proposed in previous slots (filter: between_min)',
        })
      ),
      votes_other_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for any blocks proposed in previous slots (filter: between_max_value)',
        })
      ),
      votes_other_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The number of votes for any blocks proposed in previous slots (filter: in_values) (comma-separated list)',
          })
      ),
      votes_other_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The number of votes for any blocks proposed in previous slots (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_attestation_correctness_canonical to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctAttestationCorrectnessCanonical` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctAttestationCorrectnessCanonicalServiceListResponse = zListFctAttestationCorrectnessCanonicalResponse;

export const zFctAttestationCorrectnessCanonicalServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    slot_start_date_time: z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctAttestationCorrectnessCanonicalServiceGetResponse = zGetFctAttestationCorrectnessCanonicalResponse;

export const zFctAttestationCorrectnessHeadServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      slot_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: eq)',
        })
      ),
      slot_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: ne)',
        })
      ),
      slot_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lt)',
        })
      ),
      slot_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lte)',
        })
      ),
      slot_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gt)',
        })
      ),
      slot_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gte)',
        })
      ),
      slot_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_min)',
        })
      ),
      slot_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_max_value)',
        })
      ),
      slot_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: in_values) (comma-separated list)',
          })
      ),
      slot_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      slot_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: eq)',
        })
      ),
      slot_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: ne)',
        })
      ),
      slot_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: lt)',
        })
      ),
      slot_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: lte)',
        })
      ),
      slot_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: gt)',
        })
      ),
      slot_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: gte)',
        })
      ),
      slot_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: between_min)',
        })
      ),
      slot_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: between_max_value)',
        })
      ),
      slot_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number (filter: in_values) (comma-separated list)',
          })
      ),
      slot_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: eq)',
        })
      ),
      epoch_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: ne)',
        })
      ),
      epoch_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: lt)',
        })
      ),
      epoch_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: lte)',
        })
      ),
      epoch_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: gt)',
        })
      ),
      epoch_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: gte)',
        })
      ),
      epoch_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: between_min)',
        })
      ),
      epoch_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: between_max_value)',
        })
      ),
      epoch_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number containing the slot (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number containing the slot (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: eq)',
        })
      ),
      epoch_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: ne)',
        })
      ),
      epoch_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lt)',
        })
      ),
      epoch_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lte)',
        })
      ),
      epoch_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gt)',
        })
      ),
      epoch_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gte)',
        })
      ),
      epoch_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_min)',
        })
      ),
      epoch_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_max_value)',
        })
      ),
      epoch_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_root_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: eq)',
        })
      ),
      block_root_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: ne)',
        })
      ),
      block_root_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: contains)',
        })
      ),
      block_root_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: starts_with)',
        })
      ),
      block_root_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: ends_with)',
        })
      ),
      block_root_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: like)',
        })
      ),
      block_root_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: not_like)',
        })
      ),
      block_root_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The beacon block root hash (filter: in_values) (comma-separated list)',
          })
      ),
      block_root_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The beacon block root hash (filter: not_in_values) (comma-separated list)',
          })
      ),
      votes_max_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The maximum number of scheduled votes for the block (filter: eq)',
        })
      ),
      votes_max_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The maximum number of scheduled votes for the block (filter: ne)',
        })
      ),
      votes_max_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The maximum number of scheduled votes for the block (filter: lt)',
        })
      ),
      votes_max_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The maximum number of scheduled votes for the block (filter: lte)',
        })
      ),
      votes_max_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The maximum number of scheduled votes for the block (filter: gt)',
        })
      ),
      votes_max_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The maximum number of scheduled votes for the block (filter: gte)',
        })
      ),
      votes_max_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The maximum number of scheduled votes for the block (filter: between_min)',
        })
      ),
      votes_max_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The maximum number of scheduled votes for the block (filter: between_max_value)',
        })
      ),
      votes_max_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The maximum number of scheduled votes for the block (filter: in_values) (comma-separated list)',
          })
      ),
      votes_max_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The maximum number of scheduled votes for the block (filter: not_in_values) (comma-separated list)',
          })
      ),
      votes_head_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for the block proposed in the current slot (filter: eq)',
        })
      ),
      votes_head_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for the block proposed in the current slot (filter: ne)',
        })
      ),
      votes_head_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for the block proposed in the current slot (filter: lt)',
        })
      ),
      votes_head_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for the block proposed in the current slot (filter: lte)',
        })
      ),
      votes_head_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for the block proposed in the current slot (filter: gt)',
        })
      ),
      votes_head_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for the block proposed in the current slot (filter: gte)',
        })
      ),
      votes_head_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for the block proposed in the current slot (filter: between_min)',
        })
      ),
      votes_head_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for the block proposed in the current slot (filter: between_max_value)',
        })
      ),
      votes_head_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The number of votes for the block proposed in the current slot (filter: in_values) (comma-separated list)',
          })
      ),
      votes_head_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The number of votes for the block proposed in the current slot (filter: not_in_values) (comma-separated list)',
          })
      ),
      votes_other_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for any blocks proposed in previous slots (filter: eq)',
        })
      ),
      votes_other_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for any blocks proposed in previous slots (filter: ne)',
        })
      ),
      votes_other_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for any blocks proposed in previous slots (filter: lt)',
        })
      ),
      votes_other_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for any blocks proposed in previous slots (filter: lte)',
        })
      ),
      votes_other_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for any blocks proposed in previous slots (filter: gt)',
        })
      ),
      votes_other_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for any blocks proposed in previous slots (filter: gte)',
        })
      ),
      votes_other_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for any blocks proposed in previous slots (filter: between_min)',
        })
      ),
      votes_other_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of votes for any blocks proposed in previous slots (filter: between_max_value)',
        })
      ),
      votes_other_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The number of votes for any blocks proposed in previous slots (filter: in_values) (comma-separated list)',
          })
      ),
      votes_other_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The number of votes for any blocks proposed in previous slots (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_attestation_correctness_head to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctAttestationCorrectnessHead` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctAttestationCorrectnessHeadServiceListResponse = zListFctAttestationCorrectnessHeadResponse;

export const zFctAttestationCorrectnessHeadServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    slot_start_date_time: z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctAttestationCorrectnessHeadServiceGetResponse = zGetFctAttestationCorrectnessHeadResponse;

export const zFctAttestationFirstSeenChunked50MsServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      slot_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: eq)',
        })
      ),
      slot_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: ne)',
        })
      ),
      slot_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lt)',
        })
      ),
      slot_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lte)',
        })
      ),
      slot_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gt)',
        })
      ),
      slot_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gte)',
        })
      ),
      slot_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_min)',
        })
      ),
      slot_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_max_value)',
        })
      ),
      slot_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: in_values) (comma-separated list)',
          })
      ),
      slot_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_root_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The beacon block root hash that was attested, null means the attestation was missed (filter: eq)',
        })
      ),
      block_root_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The beacon block root hash that was attested, null means the attestation was missed (filter: ne)',
        })
      ),
      block_root_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The beacon block root hash that was attested, null means the attestation was missed (filter: contains)',
        })
      ),
      block_root_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The beacon block root hash that was attested, null means the attestation was missed (filter: starts_with)',
        })
      ),
      block_root_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The beacon block root hash that was attested, null means the attestation was missed (filter: ends_with)',
        })
      ),
      block_root_like: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The beacon block root hash that was attested, null means the attestation was missed (filter: like)',
        })
      ),
      block_root_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The beacon block root hash that was attested, null means the attestation was missed (filter: not_like)',
        })
      ),
      block_root_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'The beacon block root hash that was attested, null means the attestation was missed (filter: in_values) (comma-separated list)',
          })
      ),
      block_root_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'The beacon block root hash that was attested, null means the attestation was missed (filter: not_in_values) (comma-separated list)',
          })
      ),
      chunk_slot_start_diff_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The different between the chunk start time and slot_start_date_time. "1500" would mean this chunk contains attestations first seen between 1500ms 1550ms into the slot (filter: eq)',
        })
      ),
      chunk_slot_start_diff_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The different between the chunk start time and slot_start_date_time. "1500" would mean this chunk contains attestations first seen between 1500ms 1550ms into the slot (filter: ne)',
        })
      ),
      chunk_slot_start_diff_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The different between the chunk start time and slot_start_date_time. "1500" would mean this chunk contains attestations first seen between 1500ms 1550ms into the slot (filter: lt)',
        })
      ),
      chunk_slot_start_diff_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The different between the chunk start time and slot_start_date_time. "1500" would mean this chunk contains attestations first seen between 1500ms 1550ms into the slot (filter: lte)',
        })
      ),
      chunk_slot_start_diff_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The different between the chunk start time and slot_start_date_time. "1500" would mean this chunk contains attestations first seen between 1500ms 1550ms into the slot (filter: gt)',
        })
      ),
      chunk_slot_start_diff_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The different between the chunk start time and slot_start_date_time. "1500" would mean this chunk contains attestations first seen between 1500ms 1550ms into the slot (filter: gte)',
        })
      ),
      chunk_slot_start_diff_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The different between the chunk start time and slot_start_date_time. "1500" would mean this chunk contains attestations first seen between 1500ms 1550ms into the slot (filter: between_min)',
        })
      ),
      chunk_slot_start_diff_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The different between the chunk start time and slot_start_date_time. "1500" would mean this chunk contains attestations first seen between 1500ms 1550ms into the slot (filter: between_max_value)',
        })
      ),
      chunk_slot_start_diff_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The different between the chunk start time and slot_start_date_time. "1500" would mean this chunk contains attestations first seen between 1500ms 1550ms into the slot (filter: in_values) (comma-separated list)',
          })
      ),
      chunk_slot_start_diff_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The different between the chunk start time and slot_start_date_time. "1500" would mean this chunk contains attestations first seen between 1500ms 1550ms into the slot (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      slot_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: eq)',
        })
      ),
      slot_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: ne)',
        })
      ),
      slot_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: lt)',
        })
      ),
      slot_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: lte)',
        })
      ),
      slot_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: gt)',
        })
      ),
      slot_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: gte)',
        })
      ),
      slot_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: between_min)',
        })
      ),
      slot_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: between_max_value)',
        })
      ),
      slot_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number (filter: in_values) (comma-separated list)',
          })
      ),
      slot_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: eq)',
        })
      ),
      epoch_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: ne)',
        })
      ),
      epoch_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: lt)',
        })
      ),
      epoch_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: lte)',
        })
      ),
      epoch_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: gt)',
        })
      ),
      epoch_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: gte)',
        })
      ),
      epoch_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: between_min)',
        })
      ),
      epoch_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: between_max_value)',
        })
      ),
      epoch_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number containing the slot (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number containing the slot (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: eq)',
        })
      ),
      epoch_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: ne)',
        })
      ),
      epoch_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lt)',
        })
      ),
      epoch_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lte)',
        })
      ),
      epoch_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gt)',
        })
      ),
      epoch_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gte)',
        })
      ),
      epoch_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_min)',
        })
      ),
      epoch_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_max_value)',
        })
      ),
      epoch_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: not_in_values) (comma-separated list)',
          })
      ),
      attestation_count_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of attestations in this chunk (filter: eq)',
        })
      ),
      attestation_count_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of attestations in this chunk (filter: ne)',
        })
      ),
      attestation_count_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of attestations in this chunk (filter: lt)',
        })
      ),
      attestation_count_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of attestations in this chunk (filter: lte)',
        })
      ),
      attestation_count_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of attestations in this chunk (filter: gt)',
        })
      ),
      attestation_count_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of attestations in this chunk (filter: gte)',
        })
      ),
      attestation_count_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of attestations in this chunk (filter: between_min)',
        })
      ),
      attestation_count_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of attestations in this chunk (filter: between_max_value)',
        })
      ),
      attestation_count_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The number of attestations in this chunk (filter: in_values) (comma-separated list)',
          })
      ),
      attestation_count_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The number of attestations in this chunk (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_attestation_first_seen_chunked_50ms to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctAttestationFirstSeenChunked50ms` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctAttestationFirstSeenChunked50MsServiceListResponse = zListFctAttestationFirstSeenChunked50MsResponse;

export const zFctAttestationFirstSeenChunked50MsServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    slot_start_date_time: z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctAttestationFirstSeenChunked50MsServiceGetResponse = zGetFctAttestationFirstSeenChunked50MsResponse;

export const zFctBlockServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      slot_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the reorg slot started (filter: eq)',
        })
      ),
      slot_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the reorg slot started (filter: ne)',
        })
      ),
      slot_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the reorg slot started (filter: lt)',
        })
      ),
      slot_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the reorg slot started (filter: lte)',
        })
      ),
      slot_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the reorg slot started (filter: gt)',
        })
      ),
      slot_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the reorg slot started (filter: gte)',
        })
      ),
      slot_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the reorg slot started (filter: between_min)',
        })
      ),
      slot_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the reorg slot started (filter: between_max_value)',
        })
      ),
      slot_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the reorg slot started (filter: in_values) (comma-separated list)',
          })
      ),
      slot_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The wall clock time when the reorg slot started (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_root_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: eq)',
        })
      ),
      block_root_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: ne)',
        })
      ),
      block_root_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: contains)',
        })
      ),
      block_root_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: starts_with)',
        })
      ),
      block_root_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: ends_with)',
        })
      ),
      block_root_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: like)',
        })
      ),
      block_root_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: not_like)',
        })
      ),
      block_root_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The root hash of the beacon block (filter: in_values) (comma-separated list)',
          })
      ),
      block_root_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The root hash of the beacon block (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      slot_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number from beacon block payload (filter: eq)',
        })
      ),
      slot_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number from beacon block payload (filter: ne)',
        })
      ),
      slot_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number from beacon block payload (filter: lt)',
        })
      ),
      slot_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number from beacon block payload (filter: lte)',
        })
      ),
      slot_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number from beacon block payload (filter: gt)',
        })
      ),
      slot_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number from beacon block payload (filter: gte)',
        })
      ),
      slot_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number from beacon block payload (filter: between_min)',
        })
      ),
      slot_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number from beacon block payload (filter: between_max_value)',
        })
      ),
      slot_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number from beacon block payload (filter: in_values) (comma-separated list)',
          })
      ),
      slot_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number from beacon block payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number from beacon block payload (filter: eq)',
        })
      ),
      epoch_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number from beacon block payload (filter: ne)',
        })
      ),
      epoch_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number from beacon block payload (filter: lt)',
        })
      ),
      epoch_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number from beacon block payload (filter: lte)',
        })
      ),
      epoch_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number from beacon block payload (filter: gt)',
        })
      ),
      epoch_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number from beacon block payload (filter: gte)',
        })
      ),
      epoch_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number from beacon block payload (filter: between_min)',
        })
      ),
      epoch_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number from beacon block payload (filter: between_max_value)',
        })
      ),
      epoch_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number from beacon block payload (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number from beacon block payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: eq)',
        })
      ),
      epoch_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: ne)',
        })
      ),
      epoch_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lt)',
        })
      ),
      epoch_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lte)',
        })
      ),
      epoch_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gt)',
        })
      ),
      epoch_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gte)',
        })
      ),
      epoch_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_min)',
        })
      ),
      epoch_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_max_value)',
        })
      ),
      epoch_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_version_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The version of the beacon block (filter: eq)',
        })
      ),
      block_version_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The version of the beacon block (filter: ne)',
        })
      ),
      block_version_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The version of the beacon block (filter: contains)',
        })
      ),
      block_version_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The version of the beacon block (filter: starts_with)',
        })
      ),
      block_version_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The version of the beacon block (filter: ends_with)',
        })
      ),
      block_version_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The version of the beacon block (filter: like)',
        })
      ),
      block_version_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The version of the beacon block (filter: not_like)',
        })
      ),
      block_version_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The version of the beacon block (filter: in_values) (comma-separated list)',
          })
      ),
      block_version_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The version of the beacon block (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_total_bytes_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload (filter: eq)',
        })
      ),
      block_total_bytes_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload (filter: ne)',
        })
      ),
      block_total_bytes_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload (filter: lt)',
        })
      ),
      block_total_bytes_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload (filter: lte)',
        })
      ),
      block_total_bytes_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload (filter: gt)',
        })
      ),
      block_total_bytes_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload (filter: gte)',
        })
      ),
      block_total_bytes_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload (filter: between_min)',
        })
      ),
      block_total_bytes_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload (filter: between_max_value)',
        })
      ),
      block_total_bytes_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The total bytes of the beacon block payload (filter: in_values) (comma-separated list)',
          })
      ),
      block_total_bytes_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The total bytes of the beacon block payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_total_bytes_compressed_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload when compressed using snappy (filter: eq)',
        })
      ),
      block_total_bytes_compressed_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload when compressed using snappy (filter: ne)',
        })
      ),
      block_total_bytes_compressed_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload when compressed using snappy (filter: lt)',
        })
      ),
      block_total_bytes_compressed_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload when compressed using snappy (filter: lte)',
        })
      ),
      block_total_bytes_compressed_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload when compressed using snappy (filter: gt)',
        })
      ),
      block_total_bytes_compressed_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload when compressed using snappy (filter: gte)',
        })
      ),
      block_total_bytes_compressed_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload when compressed using snappy (filter: between_min)',
        })
      ),
      block_total_bytes_compressed_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The total bytes of the beacon block payload when compressed using snappy (filter: between_max_value)',
        })
      ),
      block_total_bytes_compressed_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The total bytes of the beacon block payload when compressed using snappy (filter: in_values) (comma-separated list)',
          })
      ),
      block_total_bytes_compressed_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The total bytes of the beacon block payload when compressed using snappy (filter: not_in_values) (comma-separated list)',
          })
      ),
      parent_root_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the parent beacon block (filter: eq)',
        })
      ),
      parent_root_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the parent beacon block (filter: ne)',
        })
      ),
      parent_root_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the parent beacon block (filter: contains)',
        })
      ),
      parent_root_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the parent beacon block (filter: starts_with)',
        })
      ),
      parent_root_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the parent beacon block (filter: ends_with)',
        })
      ),
      parent_root_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the parent beacon block (filter: like)',
        })
      ),
      parent_root_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the parent beacon block (filter: not_like)',
        })
      ),
      parent_root_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The root hash of the parent beacon block (filter: in_values) (comma-separated list)',
          })
      ),
      parent_root_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The root hash of the parent beacon block (filter: not_in_values) (comma-separated list)',
          })
      ),
      state_root_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon state at this block (filter: eq)',
        })
      ),
      state_root_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon state at this block (filter: ne)',
        })
      ),
      state_root_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon state at this block (filter: contains)',
        })
      ),
      state_root_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon state at this block (filter: starts_with)',
        })
      ),
      state_root_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon state at this block (filter: ends_with)',
        })
      ),
      state_root_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon state at this block (filter: like)',
        })
      ),
      state_root_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon state at this block (filter: not_like)',
        })
      ),
      state_root_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The root hash of the beacon state at this block (filter: in_values) (comma-separated list)',
          })
      ),
      state_root_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'The root hash of the beacon state at this block (filter: not_in_values) (comma-separated list)',
          })
      ),
      proposer_index_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator that proposed the beacon block (filter: eq)',
        })
      ),
      proposer_index_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator that proposed the beacon block (filter: ne)',
        })
      ),
      proposer_index_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator that proposed the beacon block (filter: lt)',
        })
      ),
      proposer_index_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator that proposed the beacon block (filter: lte)',
        })
      ),
      proposer_index_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator that proposed the beacon block (filter: gt)',
        })
      ),
      proposer_index_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator that proposed the beacon block (filter: gte)',
        })
      ),
      proposer_index_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator that proposed the beacon block (filter: between_min)',
        })
      ),
      proposer_index_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator that proposed the beacon block (filter: between_max_value)',
        })
      ),
      proposer_index_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The index of the validator that proposed the beacon block (filter: in_values) (comma-separated list)',
          })
      ),
      proposer_index_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The index of the validator that proposed the beacon block (filter: not_in_values) (comma-separated list)',
          })
      ),
      eth1_data_block_hash_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the associated execution block (filter: eq)',
        })
      ),
      eth1_data_block_hash_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the associated execution block (filter: ne)',
        })
      ),
      eth1_data_block_hash_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the associated execution block (filter: contains)',
        })
      ),
      eth1_data_block_hash_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the associated execution block (filter: starts_with)',
        })
      ),
      eth1_data_block_hash_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the associated execution block (filter: ends_with)',
        })
      ),
      eth1_data_block_hash_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the associated execution block (filter: like)',
        })
      ),
      eth1_data_block_hash_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the associated execution block (filter: not_like)',
        })
      ),
      eth1_data_block_hash_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The block hash of the associated execution block (filter: in_values) (comma-separated list)',
          })
      ),
      eth1_data_block_hash_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'The block hash of the associated execution block (filter: not_in_values) (comma-separated list)',
          })
      ),
      eth1_data_deposit_root_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root of the deposit tree in the associated execution block (filter: eq)',
        })
      ),
      eth1_data_deposit_root_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root of the deposit tree in the associated execution block (filter: ne)',
        })
      ),
      eth1_data_deposit_root_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root of the deposit tree in the associated execution block (filter: contains)',
        })
      ),
      eth1_data_deposit_root_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root of the deposit tree in the associated execution block (filter: starts_with)',
        })
      ),
      eth1_data_deposit_root_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root of the deposit tree in the associated execution block (filter: ends_with)',
        })
      ),
      eth1_data_deposit_root_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root of the deposit tree in the associated execution block (filter: like)',
        })
      ),
      eth1_data_deposit_root_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root of the deposit tree in the associated execution block (filter: not_like)',
        })
      ),
      eth1_data_deposit_root_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'The root of the deposit tree in the associated execution block (filter: in_values) (comma-separated list)',
          })
      ),
      eth1_data_deposit_root_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'The root of the deposit tree in the associated execution block (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_block_hash_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the execution payload (filter: eq)',
        })
      ),
      execution_payload_block_hash_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the execution payload (filter: ne)',
        })
      ),
      execution_payload_block_hash_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the execution payload (filter: contains)',
        })
      ),
      execution_payload_block_hash_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the execution payload (filter: starts_with)',
        })
      ),
      execution_payload_block_hash_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the execution payload (filter: ends_with)',
        })
      ),
      execution_payload_block_hash_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the execution payload (filter: like)',
        })
      ),
      execution_payload_block_hash_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the execution payload (filter: not_like)',
        })
      ),
      execution_payload_block_hash_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The block hash of the execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_block_hash_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The block hash of the execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_block_number_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the execution payload (filter: eq)',
        })
      ),
      execution_payload_block_number_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the execution payload (filter: ne)',
        })
      ),
      execution_payload_block_number_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the execution payload (filter: lt)',
        })
      ),
      execution_payload_block_number_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the execution payload (filter: lte)',
        })
      ),
      execution_payload_block_number_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the execution payload (filter: gt)',
        })
      ),
      execution_payload_block_number_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the execution payload (filter: gte)',
        })
      ),
      execution_payload_block_number_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the execution payload (filter: between_min)',
        })
      ),
      execution_payload_block_number_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the execution payload (filter: between_max_value)',
        })
      ),
      execution_payload_block_number_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The block number of the execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_block_number_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The block number of the execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_fee_recipient_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The recipient of the fee for this execution payload (filter: eq)',
        })
      ),
      execution_payload_fee_recipient_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The recipient of the fee for this execution payload (filter: ne)',
        })
      ),
      execution_payload_fee_recipient_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The recipient of the fee for this execution payload (filter: contains)',
        })
      ),
      execution_payload_fee_recipient_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The recipient of the fee for this execution payload (filter: starts_with)',
        })
      ),
      execution_payload_fee_recipient_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The recipient of the fee for this execution payload (filter: ends_with)',
        })
      ),
      execution_payload_fee_recipient_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The recipient of the fee for this execution payload (filter: like)',
        })
      ),
      execution_payload_fee_recipient_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The recipient of the fee for this execution payload (filter: not_like)',
        })
      ),
      execution_payload_fee_recipient_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'The recipient of the fee for this execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_fee_recipient_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'The recipient of the fee for this execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_base_fee_per_gas_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Base fee per gas for execution payload (filter: eq)',
        })
      ),
      execution_payload_base_fee_per_gas_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Base fee per gas for execution payload (filter: ne)',
        })
      ),
      execution_payload_base_fee_per_gas_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Base fee per gas for execution payload (filter: contains)',
        })
      ),
      execution_payload_base_fee_per_gas_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Base fee per gas for execution payload (filter: starts_with)',
        })
      ),
      execution_payload_base_fee_per_gas_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Base fee per gas for execution payload (filter: ends_with)',
        })
      ),
      execution_payload_base_fee_per_gas_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Base fee per gas for execution payload (filter: like)',
        })
      ),
      execution_payload_base_fee_per_gas_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Base fee per gas for execution payload (filter: not_like)',
        })
      ),
      execution_payload_base_fee_per_gas_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Base fee per gas for execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_base_fee_per_gas_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Base fee per gas for execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_blob_gas_used_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for blobs in execution payload (filter: eq)',
        })
      ),
      execution_payload_blob_gas_used_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for blobs in execution payload (filter: ne)',
        })
      ),
      execution_payload_blob_gas_used_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for blobs in execution payload (filter: lt)',
        })
      ),
      execution_payload_blob_gas_used_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for blobs in execution payload (filter: lte)',
        })
      ),
      execution_payload_blob_gas_used_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for blobs in execution payload (filter: gt)',
        })
      ),
      execution_payload_blob_gas_used_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for blobs in execution payload (filter: gte)',
        })
      ),
      execution_payload_blob_gas_used_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for blobs in execution payload (filter: between_min)',
        })
      ),
      execution_payload_blob_gas_used_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for blobs in execution payload (filter: between_max_value)',
        })
      ),
      execution_payload_blob_gas_used_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Gas used for blobs in execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_blob_gas_used_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Gas used for blobs in execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_excess_blob_gas_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Excess gas used for blobs in execution payload (filter: eq)',
        })
      ),
      execution_payload_excess_blob_gas_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Excess gas used for blobs in execution payload (filter: ne)',
        })
      ),
      execution_payload_excess_blob_gas_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Excess gas used for blobs in execution payload (filter: lt)',
        })
      ),
      execution_payload_excess_blob_gas_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Excess gas used for blobs in execution payload (filter: lte)',
        })
      ),
      execution_payload_excess_blob_gas_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Excess gas used for blobs in execution payload (filter: gt)',
        })
      ),
      execution_payload_excess_blob_gas_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Excess gas used for blobs in execution payload (filter: gte)',
        })
      ),
      execution_payload_excess_blob_gas_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Excess gas used for blobs in execution payload (filter: between_min)',
        })
      ),
      execution_payload_excess_blob_gas_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Excess gas used for blobs in execution payload (filter: between_max_value)',
        })
      ),
      execution_payload_excess_blob_gas_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Excess gas used for blobs in execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_excess_blob_gas_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Excess gas used for blobs in execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_gas_limit_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas limit for execution payload (filter: eq)',
        })
      ),
      execution_payload_gas_limit_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas limit for execution payload (filter: ne)',
        })
      ),
      execution_payload_gas_limit_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas limit for execution payload (filter: lt)',
        })
      ),
      execution_payload_gas_limit_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas limit for execution payload (filter: lte)',
        })
      ),
      execution_payload_gas_limit_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas limit for execution payload (filter: gt)',
        })
      ),
      execution_payload_gas_limit_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas limit for execution payload (filter: gte)',
        })
      ),
      execution_payload_gas_limit_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas limit for execution payload (filter: between_min)',
        })
      ),
      execution_payload_gas_limit_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas limit for execution payload (filter: between_max_value)',
        })
      ),
      execution_payload_gas_limit_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Gas limit for execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_gas_limit_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Gas limit for execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_gas_used_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for execution payload (filter: eq)',
        })
      ),
      execution_payload_gas_used_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for execution payload (filter: ne)',
        })
      ),
      execution_payload_gas_used_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for execution payload (filter: lt)',
        })
      ),
      execution_payload_gas_used_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for execution payload (filter: lte)',
        })
      ),
      execution_payload_gas_used_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for execution payload (filter: gt)',
        })
      ),
      execution_payload_gas_used_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for execution payload (filter: gte)',
        })
      ),
      execution_payload_gas_used_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for execution payload (filter: between_min)',
        })
      ),
      execution_payload_gas_used_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for execution payload (filter: between_max_value)',
        })
      ),
      execution_payload_gas_used_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Gas used for execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_gas_used_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Gas used for execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_state_root_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The state root of the execution payload (filter: eq)',
        })
      ),
      execution_payload_state_root_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The state root of the execution payload (filter: ne)',
        })
      ),
      execution_payload_state_root_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The state root of the execution payload (filter: contains)',
        })
      ),
      execution_payload_state_root_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The state root of the execution payload (filter: starts_with)',
        })
      ),
      execution_payload_state_root_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The state root of the execution payload (filter: ends_with)',
        })
      ),
      execution_payload_state_root_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The state root of the execution payload (filter: like)',
        })
      ),
      execution_payload_state_root_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The state root of the execution payload (filter: not_like)',
        })
      ),
      execution_payload_state_root_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The state root of the execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_state_root_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The state root of the execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_parent_hash_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the execution payload (filter: eq)',
        })
      ),
      execution_payload_parent_hash_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the execution payload (filter: ne)',
        })
      ),
      execution_payload_parent_hash_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the execution payload (filter: contains)',
        })
      ),
      execution_payload_parent_hash_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the execution payload (filter: starts_with)',
        })
      ),
      execution_payload_parent_hash_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the execution payload (filter: ends_with)',
        })
      ),
      execution_payload_parent_hash_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the execution payload (filter: like)',
        })
      ),
      execution_payload_parent_hash_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the execution payload (filter: not_like)',
        })
      ),
      execution_payload_parent_hash_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The parent hash of the execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_parent_hash_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The parent hash of the execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_transactions_count_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction count of the execution payload (filter: eq)',
        })
      ),
      execution_payload_transactions_count_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction count of the execution payload (filter: ne)',
        })
      ),
      execution_payload_transactions_count_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction count of the execution payload (filter: lt)',
        })
      ),
      execution_payload_transactions_count_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction count of the execution payload (filter: lte)',
        })
      ),
      execution_payload_transactions_count_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction count of the execution payload (filter: gt)',
        })
      ),
      execution_payload_transactions_count_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction count of the execution payload (filter: gte)',
        })
      ),
      execution_payload_transactions_count_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction count of the execution payload (filter: between_min)',
        })
      ),
      execution_payload_transactions_count_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction count of the execution payload (filter: between_max_value)',
        })
      ),
      execution_payload_transactions_count_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The transaction count of the execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_transactions_count_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The transaction count of the execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_transactions_total_bytes_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload (filter: eq)',
        })
      ),
      execution_payload_transactions_total_bytes_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload (filter: ne)',
        })
      ),
      execution_payload_transactions_total_bytes_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload (filter: lt)',
        })
      ),
      execution_payload_transactions_total_bytes_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload (filter: lte)',
        })
      ),
      execution_payload_transactions_total_bytes_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload (filter: gt)',
        })
      ),
      execution_payload_transactions_total_bytes_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload (filter: gte)',
        })
      ),
      execution_payload_transactions_total_bytes_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload (filter: between_min)',
        })
      ),
      execution_payload_transactions_total_bytes_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload (filter: between_max_value)',
        })
      ),
      execution_payload_transactions_total_bytes_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The transaction total bytes of the execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_transactions_total_bytes_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The transaction total bytes of the execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_transactions_total_bytes_compressed_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload when compressed using snappy (filter: eq)',
        })
      ),
      execution_payload_transactions_total_bytes_compressed_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload when compressed using snappy (filter: ne)',
        })
      ),
      execution_payload_transactions_total_bytes_compressed_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload when compressed using snappy (filter: lt)',
        })
      ),
      execution_payload_transactions_total_bytes_compressed_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The transaction total bytes of the execution payload when compressed using snappy (filter: lte)',
        })
      ),
      execution_payload_transactions_total_bytes_compressed_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload when compressed using snappy (filter: gt)',
        })
      ),
      execution_payload_transactions_total_bytes_compressed_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The transaction total bytes of the execution payload when compressed using snappy (filter: gte)',
        })
      ),
      execution_payload_transactions_total_bytes_compressed_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The transaction total bytes of the execution payload when compressed using snappy (filter: between_min)',
        })
      ),
      execution_payload_transactions_total_bytes_compressed_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The transaction total bytes of the execution payload when compressed using snappy (filter: between_max_value)',
        })
      ),
      execution_payload_transactions_total_bytes_compressed_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The transaction total bytes of the execution payload when compressed using snappy (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_transactions_total_bytes_compressed_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The transaction total bytes of the execution payload when compressed using snappy (filter: not_in_values) (comma-separated list)',
          })
      ),
      status_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical" or "orphaned" (filter: eq)',
        })
      ),
      status_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical" or "orphaned" (filter: ne)',
        })
      ),
      status_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical" or "orphaned" (filter: contains)',
        })
      ),
      status_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical" or "orphaned" (filter: starts_with)',
        })
      ),
      status_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical" or "orphaned" (filter: ends_with)',
        })
      ),
      status_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical" or "orphaned" (filter: like)',
        })
      ),
      status_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical" or "orphaned" (filter: not_like)',
        })
      ),
      status_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Can be "canonical" or "orphaned" (filter: in_values) (comma-separated list)',
          })
      ),
      status_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Can be "canonical" or "orphaned" (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_block to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctBlock` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctBlockServiceListResponse = zListFctBlockResponse;

export const zFctBlockServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    slot_start_date_time: z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the reorg slot started',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctBlockServiceGetResponse = zGetFctBlockResponse;

export const zFctBlockBlobCountServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      slot_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: eq)',
        })
      ),
      slot_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: ne)',
        })
      ),
      slot_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lt)',
        })
      ),
      slot_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lte)',
        })
      ),
      slot_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gt)',
        })
      ),
      slot_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gte)',
        })
      ),
      slot_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_min)',
        })
      ),
      slot_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_max_value)',
        })
      ),
      slot_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: in_values) (comma-separated list)',
          })
      ),
      slot_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_root_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: eq)',
        })
      ),
      block_root_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: ne)',
        })
      ),
      block_root_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: contains)',
        })
      ),
      block_root_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: starts_with)',
        })
      ),
      block_root_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: ends_with)',
        })
      ),
      block_root_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: like)',
        })
      ),
      block_root_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: not_like)',
        })
      ),
      block_root_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The beacon block root hash (filter: in_values) (comma-separated list)',
          })
      ),
      block_root_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The beacon block root hash (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      slot_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: eq)',
        })
      ),
      slot_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: ne)',
        })
      ),
      slot_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: lt)',
        })
      ),
      slot_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: lte)',
        })
      ),
      slot_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: gt)',
        })
      ),
      slot_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: gte)',
        })
      ),
      slot_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: between_min)',
        })
      ),
      slot_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: between_max_value)',
        })
      ),
      slot_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number (filter: in_values) (comma-separated list)',
          })
      ),
      slot_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: eq)',
        })
      ),
      epoch_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: ne)',
        })
      ),
      epoch_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: lt)',
        })
      ),
      epoch_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: lte)',
        })
      ),
      epoch_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: gt)',
        })
      ),
      epoch_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: gte)',
        })
      ),
      epoch_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: between_min)',
        })
      ),
      epoch_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: between_max_value)',
        })
      ),
      epoch_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number containing the slot (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number containing the slot (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: eq)',
        })
      ),
      epoch_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: ne)',
        })
      ),
      epoch_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lt)',
        })
      ),
      epoch_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lte)',
        })
      ),
      epoch_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gt)',
        })
      ),
      epoch_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gte)',
        })
      ),
      epoch_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_min)',
        })
      ),
      epoch_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_max_value)',
        })
      ),
      epoch_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: not_in_values) (comma-separated list)',
          })
      ),
      blob_count_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of blobs in the block (filter: eq)',
        })
      ),
      blob_count_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of blobs in the block (filter: ne)',
        })
      ),
      blob_count_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of blobs in the block (filter: lt)',
        })
      ),
      blob_count_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of blobs in the block (filter: lte)',
        })
      ),
      blob_count_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of blobs in the block (filter: gt)',
        })
      ),
      blob_count_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of blobs in the block (filter: gte)',
        })
      ),
      blob_count_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of blobs in the block (filter: between_min)',
        })
      ),
      blob_count_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of blobs in the block (filter: between_max_value)',
        })
      ),
      blob_count_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The number of blobs in the block (filter: in_values) (comma-separated list)',
          })
      ),
      blob_count_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The number of blobs in the block (filter: not_in_values) (comma-separated list)',
          })
      ),
      status_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical" or "orphaned" (filter: eq)',
        })
      ),
      status_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical" or "orphaned" (filter: ne)',
        })
      ),
      status_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical" or "orphaned" (filter: contains)',
        })
      ),
      status_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical" or "orphaned" (filter: starts_with)',
        })
      ),
      status_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical" or "orphaned" (filter: ends_with)',
        })
      ),
      status_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical" or "orphaned" (filter: like)',
        })
      ),
      status_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical" or "orphaned" (filter: not_like)',
        })
      ),
      status_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Can be "canonical" or "orphaned" (filter: in_values) (comma-separated list)',
          })
      ),
      status_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Can be "canonical" or "orphaned" (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_block_blob_count to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctBlockBlobCount` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctBlockBlobCountServiceListResponse = zListFctBlockBlobCountResponse;

export const zFctBlockBlobCountServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    slot_start_date_time: z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctBlockBlobCountServiceGetResponse = zGetFctBlockBlobCountResponse;

export const zFctBlockBlobCountHeadServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      slot_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: eq)',
        })
      ),
      slot_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: ne)',
        })
      ),
      slot_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lt)',
        })
      ),
      slot_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lte)',
        })
      ),
      slot_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gt)',
        })
      ),
      slot_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gte)',
        })
      ),
      slot_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_min)',
        })
      ),
      slot_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_max_value)',
        })
      ),
      slot_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: in_values) (comma-separated list)',
          })
      ),
      slot_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_root_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: eq)',
        })
      ),
      block_root_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: ne)',
        })
      ),
      block_root_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: contains)',
        })
      ),
      block_root_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: starts_with)',
        })
      ),
      block_root_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: ends_with)',
        })
      ),
      block_root_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: like)',
        })
      ),
      block_root_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: not_like)',
        })
      ),
      block_root_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The beacon block root hash (filter: in_values) (comma-separated list)',
          })
      ),
      block_root_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The beacon block root hash (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      slot_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: eq)',
        })
      ),
      slot_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: ne)',
        })
      ),
      slot_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: lt)',
        })
      ),
      slot_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: lte)',
        })
      ),
      slot_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: gt)',
        })
      ),
      slot_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: gte)',
        })
      ),
      slot_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: between_min)',
        })
      ),
      slot_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: between_max_value)',
        })
      ),
      slot_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number (filter: in_values) (comma-separated list)',
          })
      ),
      slot_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: eq)',
        })
      ),
      epoch_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: ne)',
        })
      ),
      epoch_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: lt)',
        })
      ),
      epoch_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: lte)',
        })
      ),
      epoch_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: gt)',
        })
      ),
      epoch_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: gte)',
        })
      ),
      epoch_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: between_min)',
        })
      ),
      epoch_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: between_max_value)',
        })
      ),
      epoch_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number containing the slot (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number containing the slot (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: eq)',
        })
      ),
      epoch_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: ne)',
        })
      ),
      epoch_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lt)',
        })
      ),
      epoch_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lte)',
        })
      ),
      epoch_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gt)',
        })
      ),
      epoch_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gte)',
        })
      ),
      epoch_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_min)',
        })
      ),
      epoch_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_max_value)',
        })
      ),
      epoch_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: not_in_values) (comma-separated list)',
          })
      ),
      blob_count_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of blobs in the block (filter: eq)',
        })
      ),
      blob_count_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of blobs in the block (filter: ne)',
        })
      ),
      blob_count_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of blobs in the block (filter: lt)',
        })
      ),
      blob_count_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of blobs in the block (filter: lte)',
        })
      ),
      blob_count_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of blobs in the block (filter: gt)',
        })
      ),
      blob_count_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of blobs in the block (filter: gte)',
        })
      ),
      blob_count_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of blobs in the block (filter: between_min)',
        })
      ),
      blob_count_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of blobs in the block (filter: between_max_value)',
        })
      ),
      blob_count_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The number of blobs in the block (filter: in_values) (comma-separated list)',
          })
      ),
      blob_count_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The number of blobs in the block (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_block_blob_count_head to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctBlockBlobCountHead` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctBlockBlobCountHeadServiceListResponse = zListFctBlockBlobCountHeadResponse;

export const zFctBlockBlobCountHeadServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    slot_start_date_time: z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctBlockBlobCountHeadServiceGetResponse = zGetFctBlockBlobCountHeadResponse;

export const zFctBlockBlobFirstSeenByNodeServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      slot_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: eq)',
        })
      ),
      slot_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: ne)',
        })
      ),
      slot_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lt)',
        })
      ),
      slot_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lte)',
        })
      ),
      slot_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gt)',
        })
      ),
      slot_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gte)',
        })
      ),
      slot_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_min)',
        })
      ),
      slot_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_max_value)',
        })
      ),
      slot_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: in_values) (comma-separated list)',
          })
      ),
      slot_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_root_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: eq)',
        })
      ),
      block_root_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: ne)',
        })
      ),
      block_root_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: contains)',
        })
      ),
      block_root_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: starts_with)',
        })
      ),
      block_root_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: ends_with)',
        })
      ),
      block_root_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: like)',
        })
      ),
      block_root_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: not_like)',
        })
      ),
      block_root_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The beacon block root hash (filter: in_values) (comma-separated list)',
          })
      ),
      block_root_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The beacon block root hash (filter: not_in_values) (comma-separated list)',
          })
      ),
      blob_index_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The blob index (filter: eq)',
        })
      ),
      blob_index_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The blob index (filter: ne)',
        })
      ),
      blob_index_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The blob index (filter: lt)',
        })
      ),
      blob_index_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The blob index (filter: lte)',
        })
      ),
      blob_index_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The blob index (filter: gt)',
        })
      ),
      blob_index_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The blob index (filter: gte)',
        })
      ),
      blob_index_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The blob index (filter: between_min)',
        })
      ),
      blob_index_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The blob index (filter: between_max_value)',
        })
      ),
      blob_index_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The blob index (filter: in_values) (comma-separated list)',
          })
      ),
      blob_index_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The blob index (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_name_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client (filter: eq)',
        })
      ),
      meta_client_name_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client (filter: ne)',
        })
      ),
      meta_client_name_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client (filter: contains)',
        })
      ),
      meta_client_name_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client (filter: starts_with)',
        })
      ),
      meta_client_name_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client (filter: ends_with)',
        })
      ),
      meta_client_name_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client (filter: like)',
        })
      ),
      meta_client_name_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client (filter: not_like)',
        })
      ),
      meta_client_name_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Name of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_name_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Name of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      source_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Source of the event (filter: eq)',
        })
      ),
      source_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Source of the event (filter: ne)',
        })
      ),
      source_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Source of the event (filter: contains)',
        })
      ),
      source_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Source of the event (filter: starts_with)',
        })
      ),
      source_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Source of the event (filter: ends_with)',
        })
      ),
      source_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Source of the event (filter: like)',
        })
      ),
      source_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Source of the event (filter: not_like)',
        })
      ),
      source_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Source of the event (filter: in_values) (comma-separated list)',
          })
      ),
      source_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Source of the event (filter: not_in_values) (comma-separated list)',
          })
      ),
      slot_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: eq)',
        })
      ),
      slot_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: ne)',
        })
      ),
      slot_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: lt)',
        })
      ),
      slot_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: lte)',
        })
      ),
      slot_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: gt)',
        })
      ),
      slot_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: gte)',
        })
      ),
      slot_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: between_min)',
        })
      ),
      slot_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: between_max_value)',
        })
      ),
      slot_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number (filter: in_values) (comma-separated list)',
          })
      ),
      slot_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: eq)',
        })
      ),
      epoch_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: ne)',
        })
      ),
      epoch_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: lt)',
        })
      ),
      epoch_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: lte)',
        })
      ),
      epoch_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: gt)',
        })
      ),
      epoch_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: gte)',
        })
      ),
      epoch_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: between_min)',
        })
      ),
      epoch_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: between_max_value)',
        })
      ),
      epoch_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number containing the slot (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number containing the slot (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: eq)',
        })
      ),
      epoch_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: ne)',
        })
      ),
      epoch_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lt)',
        })
      ),
      epoch_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lte)',
        })
      ),
      epoch_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gt)',
        })
      ),
      epoch_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gte)',
        })
      ),
      epoch_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_min)',
        })
      ),
      epoch_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_max_value)',
        })
      ),
      epoch_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: not_in_values) (comma-separated list)',
          })
      ),
      seen_slot_start_diff_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The time from slot start for the client to see the block (filter: eq)',
        })
      ),
      seen_slot_start_diff_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The time from slot start for the client to see the block (filter: ne)',
        })
      ),
      seen_slot_start_diff_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The time from slot start for the client to see the block (filter: lt)',
        })
      ),
      seen_slot_start_diff_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The time from slot start for the client to see the block (filter: lte)',
        })
      ),
      seen_slot_start_diff_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The time from slot start for the client to see the block (filter: gt)',
        })
      ),
      seen_slot_start_diff_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The time from slot start for the client to see the block (filter: gte)',
        })
      ),
      seen_slot_start_diff_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The time from slot start for the client to see the block (filter: between_min)',
        })
      ),
      seen_slot_start_diff_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The time from slot start for the client to see the block (filter: between_max_value)',
        })
      ),
      seen_slot_start_diff_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The time from slot start for the client to see the block (filter: in_values) (comma-separated list)',
          })
      ),
      seen_slot_start_diff_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The time from slot start for the client to see the block (filter: not_in_values) (comma-separated list)',
          })
      ),
      username_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Username of the node (filter: eq)',
        })
      ),
      username_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Username of the node (filter: ne)',
        })
      ),
      username_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Username of the node (filter: contains)',
        })
      ),
      username_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Username of the node (filter: starts_with)',
        })
      ),
      username_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Username of the node (filter: ends_with)',
        })
      ),
      username_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Username of the node (filter: like)',
        })
      ),
      username_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Username of the node (filter: not_like)',
        })
      ),
      username_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Username of the node (filter: in_values) (comma-separated list)',
          })
      ),
      username_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Username of the node (filter: not_in_values) (comma-separated list)',
          })
      ),
      node_id_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'ID of the node (filter: eq)',
        })
      ),
      node_id_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'ID of the node (filter: ne)',
        })
      ),
      node_id_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'ID of the node (filter: contains)',
        })
      ),
      node_id_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'ID of the node (filter: starts_with)',
        })
      ),
      node_id_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'ID of the node (filter: ends_with)',
        })
      ),
      node_id_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'ID of the node (filter: like)',
        })
      ),
      node_id_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'ID of the node (filter: not_like)',
        })
      ),
      node_id_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'ID of the node (filter: in_values) (comma-separated list)',
          })
      ),
      node_id_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'ID of the node (filter: not_in_values) (comma-separated list)',
          })
      ),
      classification_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: eq)',
        })
      ),
      classification_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: ne)',
        })
      ),
      classification_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: contains)',
        })
      ),
      classification_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: starts_with)',
        })
      ),
      classification_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: ends_with)',
        })
      ),
      classification_like: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: like)',
        })
      ),
      classification_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: not_like)',
        })
      ),
      classification_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: in_values) (comma-separated list)',
          })
      ),
      classification_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_version_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client (filter: eq)',
        })
      ),
      meta_client_version_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client (filter: ne)',
        })
      ),
      meta_client_version_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client (filter: contains)',
        })
      ),
      meta_client_version_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client (filter: starts_with)',
        })
      ),
      meta_client_version_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client (filter: ends_with)',
        })
      ),
      meta_client_version_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client (filter: like)',
        })
      ),
      meta_client_version_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client (filter: not_like)',
        })
      ),
      meta_client_version_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Version of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_version_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Version of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_implementation_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client (filter: eq)',
        })
      ),
      meta_client_implementation_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client (filter: ne)',
        })
      ),
      meta_client_implementation_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client (filter: contains)',
        })
      ),
      meta_client_implementation_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client (filter: starts_with)',
        })
      ),
      meta_client_implementation_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client (filter: ends_with)',
        })
      ),
      meta_client_implementation_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client (filter: like)',
        })
      ),
      meta_client_implementation_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client (filter: not_like)',
        })
      ),
      meta_client_implementation_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Implementation of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_implementation_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Implementation of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_city_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client (filter: eq)',
        })
      ),
      meta_client_geo_city_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client (filter: ne)',
        })
      ),
      meta_client_geo_city_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client (filter: contains)',
        })
      ),
      meta_client_geo_city_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client (filter: starts_with)',
        })
      ),
      meta_client_geo_city_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client (filter: ends_with)',
        })
      ),
      meta_client_geo_city_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client (filter: like)',
        })
      ),
      meta_client_geo_city_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client (filter: not_like)',
        })
      ),
      meta_client_geo_city_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'City of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_city_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'City of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_country_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client (filter: eq)',
        })
      ),
      meta_client_geo_country_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client (filter: ne)',
        })
      ),
      meta_client_geo_country_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client (filter: contains)',
        })
      ),
      meta_client_geo_country_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client (filter: starts_with)',
        })
      ),
      meta_client_geo_country_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client (filter: ends_with)',
        })
      ),
      meta_client_geo_country_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client (filter: like)',
        })
      ),
      meta_client_geo_country_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client (filter: not_like)',
        })
      ),
      meta_client_geo_country_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Country of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_country_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Country of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_country_code_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client (filter: eq)',
        })
      ),
      meta_client_geo_country_code_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client (filter: ne)',
        })
      ),
      meta_client_geo_country_code_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client (filter: contains)',
        })
      ),
      meta_client_geo_country_code_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client (filter: starts_with)',
        })
      ),
      meta_client_geo_country_code_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client (filter: ends_with)',
        })
      ),
      meta_client_geo_country_code_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client (filter: like)',
        })
      ),
      meta_client_geo_country_code_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client (filter: not_like)',
        })
      ),
      meta_client_geo_country_code_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Country code of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_country_code_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Country code of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_continent_code_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Continent code of the client (filter: eq)',
        })
      ),
      meta_client_geo_continent_code_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Continent code of the client (filter: ne)',
        })
      ),
      meta_client_geo_continent_code_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Continent code of the client (filter: contains)',
        })
      ),
      meta_client_geo_continent_code_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Continent code of the client (filter: starts_with)',
        })
      ),
      meta_client_geo_continent_code_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Continent code of the client (filter: ends_with)',
        })
      ),
      meta_client_geo_continent_code_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Continent code of the client (filter: like)',
        })
      ),
      meta_client_geo_continent_code_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Continent code of the client (filter: not_like)',
        })
      ),
      meta_client_geo_continent_code_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Continent code of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_continent_code_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Continent code of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_longitude_value: z.optional(
        z.number().register(z.globalRegistry, {
          description: 'Filter meta_client_geo_longitude using value',
        })
      ),
      meta_client_geo_latitude_value: z.optional(
        z.number().register(z.globalRegistry, {
          description: 'Filter meta_client_geo_latitude using value',
        })
      ),
      meta_client_geo_autonomous_system_number_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Autonomous system number of the client (filter: eq)',
        })
      ),
      meta_client_geo_autonomous_system_number_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Autonomous system number of the client (filter: ne)',
        })
      ),
      meta_client_geo_autonomous_system_number_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Autonomous system number of the client (filter: lt)',
        })
      ),
      meta_client_geo_autonomous_system_number_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Autonomous system number of the client (filter: lte)',
        })
      ),
      meta_client_geo_autonomous_system_number_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Autonomous system number of the client (filter: gt)',
        })
      ),
      meta_client_geo_autonomous_system_number_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Autonomous system number of the client (filter: gte)',
        })
      ),
      meta_client_geo_autonomous_system_number_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Autonomous system number of the client (filter: between_min)',
        })
      ),
      meta_client_geo_autonomous_system_number_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Autonomous system number of the client (filter: between_max_value)',
        })
      ),
      meta_client_geo_autonomous_system_number_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Autonomous system number of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_autonomous_system_number_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Autonomous system number of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_autonomous_system_organization_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Autonomous system organization of the client (filter: eq)',
        })
      ),
      meta_client_geo_autonomous_system_organization_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Autonomous system organization of the client (filter: ne)',
        })
      ),
      meta_client_geo_autonomous_system_organization_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Autonomous system organization of the client (filter: contains)',
        })
      ),
      meta_client_geo_autonomous_system_organization_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Autonomous system organization of the client (filter: starts_with)',
        })
      ),
      meta_client_geo_autonomous_system_organization_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Autonomous system organization of the client (filter: ends_with)',
        })
      ),
      meta_client_geo_autonomous_system_organization_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Autonomous system organization of the client (filter: like)',
        })
      ),
      meta_client_geo_autonomous_system_organization_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Autonomous system organization of the client (filter: not_like)',
        })
      ),
      meta_client_geo_autonomous_system_organization_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Autonomous system organization of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_autonomous_system_organization_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Autonomous system organization of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_consensus_version_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client version (filter: eq)',
        })
      ),
      meta_consensus_version_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client version (filter: ne)',
        })
      ),
      meta_consensus_version_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client version (filter: contains)',
        })
      ),
      meta_consensus_version_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client version (filter: starts_with)',
        })
      ),
      meta_consensus_version_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client version (filter: ends_with)',
        })
      ),
      meta_consensus_version_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client version (filter: like)',
        })
      ),
      meta_consensus_version_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client version (filter: not_like)',
        })
      ),
      meta_consensus_version_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Ethereum consensus client version (filter: in_values) (comma-separated list)',
          })
      ),
      meta_consensus_version_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Ethereum consensus client version (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_consensus_implementation_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client implementation (filter: eq)',
        })
      ),
      meta_consensus_implementation_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client implementation (filter: ne)',
        })
      ),
      meta_consensus_implementation_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client implementation (filter: contains)',
        })
      ),
      meta_consensus_implementation_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client implementation (filter: starts_with)',
        })
      ),
      meta_consensus_implementation_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client implementation (filter: ends_with)',
        })
      ),
      meta_consensus_implementation_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client implementation (filter: like)',
        })
      ),
      meta_consensus_implementation_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client implementation (filter: not_like)',
        })
      ),
      meta_consensus_implementation_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Ethereum consensus client implementation (filter: in_values) (comma-separated list)',
          })
      ),
      meta_consensus_implementation_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Ethereum consensus client implementation (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_block_blob_first_seen_by_node to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctBlockBlobFirstSeenByNode` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctBlockBlobFirstSeenByNodeServiceListResponse = zListFctBlockBlobFirstSeenByNodeResponse;

export const zFctBlockBlobFirstSeenByNodeServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    slot_start_date_time: z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctBlockBlobFirstSeenByNodeServiceGetResponse = zGetFctBlockBlobFirstSeenByNodeResponse;

export const zFctBlockFirstSeenByNodeServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      slot_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: eq)',
        })
      ),
      slot_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: ne)',
        })
      ),
      slot_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lt)',
        })
      ),
      slot_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lte)',
        })
      ),
      slot_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gt)',
        })
      ),
      slot_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gte)',
        })
      ),
      slot_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_min)',
        })
      ),
      slot_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_max_value)',
        })
      ),
      slot_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: in_values) (comma-separated list)',
          })
      ),
      slot_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_root_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: eq)',
        })
      ),
      block_root_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: ne)',
        })
      ),
      block_root_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: contains)',
        })
      ),
      block_root_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: starts_with)',
        })
      ),
      block_root_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: ends_with)',
        })
      ),
      block_root_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: like)',
        })
      ),
      block_root_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash (filter: not_like)',
        })
      ),
      block_root_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The beacon block root hash (filter: in_values) (comma-separated list)',
          })
      ),
      block_root_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The beacon block root hash (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_name_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client (filter: eq)',
        })
      ),
      meta_client_name_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client (filter: ne)',
        })
      ),
      meta_client_name_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client (filter: contains)',
        })
      ),
      meta_client_name_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client (filter: starts_with)',
        })
      ),
      meta_client_name_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client (filter: ends_with)',
        })
      ),
      meta_client_name_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client (filter: like)',
        })
      ),
      meta_client_name_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client (filter: not_like)',
        })
      ),
      meta_client_name_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Name of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_name_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Name of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      source_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Source of the event (filter: eq)',
        })
      ),
      source_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Source of the event (filter: ne)',
        })
      ),
      source_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Source of the event (filter: contains)',
        })
      ),
      source_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Source of the event (filter: starts_with)',
        })
      ),
      source_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Source of the event (filter: ends_with)',
        })
      ),
      source_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Source of the event (filter: like)',
        })
      ),
      source_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Source of the event (filter: not_like)',
        })
      ),
      source_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Source of the event (filter: in_values) (comma-separated list)',
          })
      ),
      source_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Source of the event (filter: not_in_values) (comma-separated list)',
          })
      ),
      slot_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: eq)',
        })
      ),
      slot_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: ne)',
        })
      ),
      slot_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: lt)',
        })
      ),
      slot_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: lte)',
        })
      ),
      slot_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: gt)',
        })
      ),
      slot_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: gte)',
        })
      ),
      slot_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: between_min)',
        })
      ),
      slot_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: between_max_value)',
        })
      ),
      slot_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number (filter: in_values) (comma-separated list)',
          })
      ),
      slot_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: eq)',
        })
      ),
      epoch_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: ne)',
        })
      ),
      epoch_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: lt)',
        })
      ),
      epoch_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: lte)',
        })
      ),
      epoch_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: gt)',
        })
      ),
      epoch_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: gte)',
        })
      ),
      epoch_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: between_min)',
        })
      ),
      epoch_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: between_max_value)',
        })
      ),
      epoch_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number containing the slot (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number containing the slot (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: eq)',
        })
      ),
      epoch_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: ne)',
        })
      ),
      epoch_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lt)',
        })
      ),
      epoch_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lte)',
        })
      ),
      epoch_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gt)',
        })
      ),
      epoch_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gte)',
        })
      ),
      epoch_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_min)',
        })
      ),
      epoch_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_max_value)',
        })
      ),
      epoch_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: not_in_values) (comma-separated list)',
          })
      ),
      seen_slot_start_diff_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The time from slot start for the client to see the block (filter: eq)',
        })
      ),
      seen_slot_start_diff_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The time from slot start for the client to see the block (filter: ne)',
        })
      ),
      seen_slot_start_diff_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The time from slot start for the client to see the block (filter: lt)',
        })
      ),
      seen_slot_start_diff_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The time from slot start for the client to see the block (filter: lte)',
        })
      ),
      seen_slot_start_diff_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The time from slot start for the client to see the block (filter: gt)',
        })
      ),
      seen_slot_start_diff_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The time from slot start for the client to see the block (filter: gte)',
        })
      ),
      seen_slot_start_diff_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The time from slot start for the client to see the block (filter: between_min)',
        })
      ),
      seen_slot_start_diff_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The time from slot start for the client to see the block (filter: between_max_value)',
        })
      ),
      seen_slot_start_diff_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The time from slot start for the client to see the block (filter: in_values) (comma-separated list)',
          })
      ),
      seen_slot_start_diff_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The time from slot start for the client to see the block (filter: not_in_values) (comma-separated list)',
          })
      ),
      username_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Username of the node (filter: eq)',
        })
      ),
      username_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Username of the node (filter: ne)',
        })
      ),
      username_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Username of the node (filter: contains)',
        })
      ),
      username_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Username of the node (filter: starts_with)',
        })
      ),
      username_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Username of the node (filter: ends_with)',
        })
      ),
      username_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Username of the node (filter: like)',
        })
      ),
      username_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Username of the node (filter: not_like)',
        })
      ),
      username_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Username of the node (filter: in_values) (comma-separated list)',
          })
      ),
      username_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Username of the node (filter: not_in_values) (comma-separated list)',
          })
      ),
      node_id_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'ID of the node (filter: eq)',
        })
      ),
      node_id_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'ID of the node (filter: ne)',
        })
      ),
      node_id_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'ID of the node (filter: contains)',
        })
      ),
      node_id_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'ID of the node (filter: starts_with)',
        })
      ),
      node_id_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'ID of the node (filter: ends_with)',
        })
      ),
      node_id_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'ID of the node (filter: like)',
        })
      ),
      node_id_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'ID of the node (filter: not_like)',
        })
      ),
      node_id_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'ID of the node (filter: in_values) (comma-separated list)',
          })
      ),
      node_id_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'ID of the node (filter: not_in_values) (comma-separated list)',
          })
      ),
      classification_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: eq)',
        })
      ),
      classification_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: ne)',
        })
      ),
      classification_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: contains)',
        })
      ),
      classification_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: starts_with)',
        })
      ),
      classification_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: ends_with)',
        })
      ),
      classification_like: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: like)',
        })
      ),
      classification_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: not_like)',
        })
      ),
      classification_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: in_values) (comma-separated list)',
          })
      ),
      classification_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_version_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client (filter: eq)',
        })
      ),
      meta_client_version_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client (filter: ne)',
        })
      ),
      meta_client_version_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client (filter: contains)',
        })
      ),
      meta_client_version_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client (filter: starts_with)',
        })
      ),
      meta_client_version_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client (filter: ends_with)',
        })
      ),
      meta_client_version_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client (filter: like)',
        })
      ),
      meta_client_version_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client (filter: not_like)',
        })
      ),
      meta_client_version_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Version of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_version_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Version of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_implementation_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client (filter: eq)',
        })
      ),
      meta_client_implementation_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client (filter: ne)',
        })
      ),
      meta_client_implementation_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client (filter: contains)',
        })
      ),
      meta_client_implementation_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client (filter: starts_with)',
        })
      ),
      meta_client_implementation_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client (filter: ends_with)',
        })
      ),
      meta_client_implementation_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client (filter: like)',
        })
      ),
      meta_client_implementation_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client (filter: not_like)',
        })
      ),
      meta_client_implementation_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Implementation of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_implementation_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Implementation of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_city_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client (filter: eq)',
        })
      ),
      meta_client_geo_city_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client (filter: ne)',
        })
      ),
      meta_client_geo_city_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client (filter: contains)',
        })
      ),
      meta_client_geo_city_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client (filter: starts_with)',
        })
      ),
      meta_client_geo_city_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client (filter: ends_with)',
        })
      ),
      meta_client_geo_city_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client (filter: like)',
        })
      ),
      meta_client_geo_city_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client (filter: not_like)',
        })
      ),
      meta_client_geo_city_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'City of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_city_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'City of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_country_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client (filter: eq)',
        })
      ),
      meta_client_geo_country_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client (filter: ne)',
        })
      ),
      meta_client_geo_country_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client (filter: contains)',
        })
      ),
      meta_client_geo_country_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client (filter: starts_with)',
        })
      ),
      meta_client_geo_country_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client (filter: ends_with)',
        })
      ),
      meta_client_geo_country_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client (filter: like)',
        })
      ),
      meta_client_geo_country_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client (filter: not_like)',
        })
      ),
      meta_client_geo_country_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Country of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_country_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Country of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_country_code_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client (filter: eq)',
        })
      ),
      meta_client_geo_country_code_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client (filter: ne)',
        })
      ),
      meta_client_geo_country_code_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client (filter: contains)',
        })
      ),
      meta_client_geo_country_code_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client (filter: starts_with)',
        })
      ),
      meta_client_geo_country_code_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client (filter: ends_with)',
        })
      ),
      meta_client_geo_country_code_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client (filter: like)',
        })
      ),
      meta_client_geo_country_code_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client (filter: not_like)',
        })
      ),
      meta_client_geo_country_code_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Country code of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_country_code_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Country code of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_continent_code_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Continent code of the client (filter: eq)',
        })
      ),
      meta_client_geo_continent_code_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Continent code of the client (filter: ne)',
        })
      ),
      meta_client_geo_continent_code_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Continent code of the client (filter: contains)',
        })
      ),
      meta_client_geo_continent_code_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Continent code of the client (filter: starts_with)',
        })
      ),
      meta_client_geo_continent_code_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Continent code of the client (filter: ends_with)',
        })
      ),
      meta_client_geo_continent_code_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Continent code of the client (filter: like)',
        })
      ),
      meta_client_geo_continent_code_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Continent code of the client (filter: not_like)',
        })
      ),
      meta_client_geo_continent_code_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Continent code of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_continent_code_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Continent code of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_longitude_value: z.optional(
        z.number().register(z.globalRegistry, {
          description: 'Filter meta_client_geo_longitude using value',
        })
      ),
      meta_client_geo_latitude_value: z.optional(
        z.number().register(z.globalRegistry, {
          description: 'Filter meta_client_geo_latitude using value',
        })
      ),
      meta_client_geo_autonomous_system_number_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Autonomous system number of the client (filter: eq)',
        })
      ),
      meta_client_geo_autonomous_system_number_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Autonomous system number of the client (filter: ne)',
        })
      ),
      meta_client_geo_autonomous_system_number_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Autonomous system number of the client (filter: lt)',
        })
      ),
      meta_client_geo_autonomous_system_number_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Autonomous system number of the client (filter: lte)',
        })
      ),
      meta_client_geo_autonomous_system_number_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Autonomous system number of the client (filter: gt)',
        })
      ),
      meta_client_geo_autonomous_system_number_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Autonomous system number of the client (filter: gte)',
        })
      ),
      meta_client_geo_autonomous_system_number_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Autonomous system number of the client (filter: between_min)',
        })
      ),
      meta_client_geo_autonomous_system_number_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Autonomous system number of the client (filter: between_max_value)',
        })
      ),
      meta_client_geo_autonomous_system_number_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Autonomous system number of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_autonomous_system_number_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Autonomous system number of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_autonomous_system_organization_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Autonomous system organization of the client (filter: eq)',
        })
      ),
      meta_client_geo_autonomous_system_organization_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Autonomous system organization of the client (filter: ne)',
        })
      ),
      meta_client_geo_autonomous_system_organization_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Autonomous system organization of the client (filter: contains)',
        })
      ),
      meta_client_geo_autonomous_system_organization_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Autonomous system organization of the client (filter: starts_with)',
        })
      ),
      meta_client_geo_autonomous_system_organization_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Autonomous system organization of the client (filter: ends_with)',
        })
      ),
      meta_client_geo_autonomous_system_organization_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Autonomous system organization of the client (filter: like)',
        })
      ),
      meta_client_geo_autonomous_system_organization_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Autonomous system organization of the client (filter: not_like)',
        })
      ),
      meta_client_geo_autonomous_system_organization_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Autonomous system organization of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_autonomous_system_organization_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Autonomous system organization of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_consensus_version_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client version (filter: eq)',
        })
      ),
      meta_consensus_version_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client version (filter: ne)',
        })
      ),
      meta_consensus_version_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client version (filter: contains)',
        })
      ),
      meta_consensus_version_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client version (filter: starts_with)',
        })
      ),
      meta_consensus_version_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client version (filter: ends_with)',
        })
      ),
      meta_consensus_version_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client version (filter: like)',
        })
      ),
      meta_consensus_version_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client version (filter: not_like)',
        })
      ),
      meta_consensus_version_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Ethereum consensus client version (filter: in_values) (comma-separated list)',
          })
      ),
      meta_consensus_version_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Ethereum consensus client version (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_consensus_implementation_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client implementation (filter: eq)',
        })
      ),
      meta_consensus_implementation_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client implementation (filter: ne)',
        })
      ),
      meta_consensus_implementation_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client implementation (filter: contains)',
        })
      ),
      meta_consensus_implementation_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client implementation (filter: starts_with)',
        })
      ),
      meta_consensus_implementation_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client implementation (filter: ends_with)',
        })
      ),
      meta_consensus_implementation_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client implementation (filter: like)',
        })
      ),
      meta_consensus_implementation_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client implementation (filter: not_like)',
        })
      ),
      meta_consensus_implementation_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Ethereum consensus client implementation (filter: in_values) (comma-separated list)',
          })
      ),
      meta_consensus_implementation_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Ethereum consensus client implementation (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_block_first_seen_by_node to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctBlockFirstSeenByNode` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctBlockFirstSeenByNodeServiceListResponse = zListFctBlockFirstSeenByNodeResponse;

export const zFctBlockFirstSeenByNodeServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    slot_start_date_time: z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctBlockFirstSeenByNodeServiceGetResponse = zGetFctBlockFirstSeenByNodeResponse;

export const zFctBlockHeadServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      slot_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the reorg slot started (filter: eq)',
        })
      ),
      slot_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the reorg slot started (filter: ne)',
        })
      ),
      slot_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the reorg slot started (filter: lt)',
        })
      ),
      slot_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the reorg slot started (filter: lte)',
        })
      ),
      slot_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the reorg slot started (filter: gt)',
        })
      ),
      slot_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the reorg slot started (filter: gte)',
        })
      ),
      slot_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the reorg slot started (filter: between_min)',
        })
      ),
      slot_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the reorg slot started (filter: between_max_value)',
        })
      ),
      slot_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the reorg slot started (filter: in_values) (comma-separated list)',
          })
      ),
      slot_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The wall clock time when the reorg slot started (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_root_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: eq)',
        })
      ),
      block_root_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: ne)',
        })
      ),
      block_root_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: contains)',
        })
      ),
      block_root_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: starts_with)',
        })
      ),
      block_root_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: ends_with)',
        })
      ),
      block_root_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: like)',
        })
      ),
      block_root_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: not_like)',
        })
      ),
      block_root_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The root hash of the beacon block (filter: in_values) (comma-separated list)',
          })
      ),
      block_root_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The root hash of the beacon block (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      slot_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number from beacon block payload (filter: eq)',
        })
      ),
      slot_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number from beacon block payload (filter: ne)',
        })
      ),
      slot_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number from beacon block payload (filter: lt)',
        })
      ),
      slot_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number from beacon block payload (filter: lte)',
        })
      ),
      slot_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number from beacon block payload (filter: gt)',
        })
      ),
      slot_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number from beacon block payload (filter: gte)',
        })
      ),
      slot_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number from beacon block payload (filter: between_min)',
        })
      ),
      slot_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number from beacon block payload (filter: between_max_value)',
        })
      ),
      slot_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number from beacon block payload (filter: in_values) (comma-separated list)',
          })
      ),
      slot_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number from beacon block payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number from beacon block payload (filter: eq)',
        })
      ),
      epoch_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number from beacon block payload (filter: ne)',
        })
      ),
      epoch_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number from beacon block payload (filter: lt)',
        })
      ),
      epoch_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number from beacon block payload (filter: lte)',
        })
      ),
      epoch_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number from beacon block payload (filter: gt)',
        })
      ),
      epoch_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number from beacon block payload (filter: gte)',
        })
      ),
      epoch_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number from beacon block payload (filter: between_min)',
        })
      ),
      epoch_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number from beacon block payload (filter: between_max_value)',
        })
      ),
      epoch_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number from beacon block payload (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number from beacon block payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: eq)',
        })
      ),
      epoch_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: ne)',
        })
      ),
      epoch_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lt)',
        })
      ),
      epoch_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lte)',
        })
      ),
      epoch_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gt)',
        })
      ),
      epoch_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gte)',
        })
      ),
      epoch_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_min)',
        })
      ),
      epoch_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_max_value)',
        })
      ),
      epoch_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_version_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The version of the beacon block (filter: eq)',
        })
      ),
      block_version_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The version of the beacon block (filter: ne)',
        })
      ),
      block_version_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The version of the beacon block (filter: contains)',
        })
      ),
      block_version_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The version of the beacon block (filter: starts_with)',
        })
      ),
      block_version_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The version of the beacon block (filter: ends_with)',
        })
      ),
      block_version_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The version of the beacon block (filter: like)',
        })
      ),
      block_version_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The version of the beacon block (filter: not_like)',
        })
      ),
      block_version_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The version of the beacon block (filter: in_values) (comma-separated list)',
          })
      ),
      block_version_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The version of the beacon block (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_total_bytes_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload (filter: eq)',
        })
      ),
      block_total_bytes_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload (filter: ne)',
        })
      ),
      block_total_bytes_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload (filter: lt)',
        })
      ),
      block_total_bytes_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload (filter: lte)',
        })
      ),
      block_total_bytes_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload (filter: gt)',
        })
      ),
      block_total_bytes_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload (filter: gte)',
        })
      ),
      block_total_bytes_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload (filter: between_min)',
        })
      ),
      block_total_bytes_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload (filter: between_max_value)',
        })
      ),
      block_total_bytes_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The total bytes of the beacon block payload (filter: in_values) (comma-separated list)',
          })
      ),
      block_total_bytes_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The total bytes of the beacon block payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_total_bytes_compressed_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload when compressed using snappy (filter: eq)',
        })
      ),
      block_total_bytes_compressed_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload when compressed using snappy (filter: ne)',
        })
      ),
      block_total_bytes_compressed_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload when compressed using snappy (filter: lt)',
        })
      ),
      block_total_bytes_compressed_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload when compressed using snappy (filter: lte)',
        })
      ),
      block_total_bytes_compressed_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload when compressed using snappy (filter: gt)',
        })
      ),
      block_total_bytes_compressed_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload when compressed using snappy (filter: gte)',
        })
      ),
      block_total_bytes_compressed_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload when compressed using snappy (filter: between_min)',
        })
      ),
      block_total_bytes_compressed_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The total bytes of the beacon block payload when compressed using snappy (filter: between_max_value)',
        })
      ),
      block_total_bytes_compressed_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The total bytes of the beacon block payload when compressed using snappy (filter: in_values) (comma-separated list)',
          })
      ),
      block_total_bytes_compressed_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The total bytes of the beacon block payload when compressed using snappy (filter: not_in_values) (comma-separated list)',
          })
      ),
      parent_root_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the parent beacon block (filter: eq)',
        })
      ),
      parent_root_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the parent beacon block (filter: ne)',
        })
      ),
      parent_root_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the parent beacon block (filter: contains)',
        })
      ),
      parent_root_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the parent beacon block (filter: starts_with)',
        })
      ),
      parent_root_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the parent beacon block (filter: ends_with)',
        })
      ),
      parent_root_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the parent beacon block (filter: like)',
        })
      ),
      parent_root_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the parent beacon block (filter: not_like)',
        })
      ),
      parent_root_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The root hash of the parent beacon block (filter: in_values) (comma-separated list)',
          })
      ),
      parent_root_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The root hash of the parent beacon block (filter: not_in_values) (comma-separated list)',
          })
      ),
      state_root_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon state at this block (filter: eq)',
        })
      ),
      state_root_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon state at this block (filter: ne)',
        })
      ),
      state_root_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon state at this block (filter: contains)',
        })
      ),
      state_root_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon state at this block (filter: starts_with)',
        })
      ),
      state_root_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon state at this block (filter: ends_with)',
        })
      ),
      state_root_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon state at this block (filter: like)',
        })
      ),
      state_root_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon state at this block (filter: not_like)',
        })
      ),
      state_root_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The root hash of the beacon state at this block (filter: in_values) (comma-separated list)',
          })
      ),
      state_root_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'The root hash of the beacon state at this block (filter: not_in_values) (comma-separated list)',
          })
      ),
      proposer_index_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator that proposed the beacon block (filter: eq)',
        })
      ),
      proposer_index_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator that proposed the beacon block (filter: ne)',
        })
      ),
      proposer_index_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator that proposed the beacon block (filter: lt)',
        })
      ),
      proposer_index_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator that proposed the beacon block (filter: lte)',
        })
      ),
      proposer_index_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator that proposed the beacon block (filter: gt)',
        })
      ),
      proposer_index_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator that proposed the beacon block (filter: gte)',
        })
      ),
      proposer_index_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator that proposed the beacon block (filter: between_min)',
        })
      ),
      proposer_index_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The index of the validator that proposed the beacon block (filter: between_max_value)',
        })
      ),
      proposer_index_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The index of the validator that proposed the beacon block (filter: in_values) (comma-separated list)',
          })
      ),
      proposer_index_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The index of the validator that proposed the beacon block (filter: not_in_values) (comma-separated list)',
          })
      ),
      eth1_data_block_hash_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the associated execution block (filter: eq)',
        })
      ),
      eth1_data_block_hash_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the associated execution block (filter: ne)',
        })
      ),
      eth1_data_block_hash_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the associated execution block (filter: contains)',
        })
      ),
      eth1_data_block_hash_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the associated execution block (filter: starts_with)',
        })
      ),
      eth1_data_block_hash_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the associated execution block (filter: ends_with)',
        })
      ),
      eth1_data_block_hash_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the associated execution block (filter: like)',
        })
      ),
      eth1_data_block_hash_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the associated execution block (filter: not_like)',
        })
      ),
      eth1_data_block_hash_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The block hash of the associated execution block (filter: in_values) (comma-separated list)',
          })
      ),
      eth1_data_block_hash_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'The block hash of the associated execution block (filter: not_in_values) (comma-separated list)',
          })
      ),
      eth1_data_deposit_root_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root of the deposit tree in the associated execution block (filter: eq)',
        })
      ),
      eth1_data_deposit_root_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root of the deposit tree in the associated execution block (filter: ne)',
        })
      ),
      eth1_data_deposit_root_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root of the deposit tree in the associated execution block (filter: contains)',
        })
      ),
      eth1_data_deposit_root_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root of the deposit tree in the associated execution block (filter: starts_with)',
        })
      ),
      eth1_data_deposit_root_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root of the deposit tree in the associated execution block (filter: ends_with)',
        })
      ),
      eth1_data_deposit_root_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root of the deposit tree in the associated execution block (filter: like)',
        })
      ),
      eth1_data_deposit_root_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root of the deposit tree in the associated execution block (filter: not_like)',
        })
      ),
      eth1_data_deposit_root_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'The root of the deposit tree in the associated execution block (filter: in_values) (comma-separated list)',
          })
      ),
      eth1_data_deposit_root_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'The root of the deposit tree in the associated execution block (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_block_hash_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the execution payload (filter: eq)',
        })
      ),
      execution_payload_block_hash_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the execution payload (filter: ne)',
        })
      ),
      execution_payload_block_hash_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the execution payload (filter: contains)',
        })
      ),
      execution_payload_block_hash_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the execution payload (filter: starts_with)',
        })
      ),
      execution_payload_block_hash_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the execution payload (filter: ends_with)',
        })
      ),
      execution_payload_block_hash_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the execution payload (filter: like)',
        })
      ),
      execution_payload_block_hash_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the execution payload (filter: not_like)',
        })
      ),
      execution_payload_block_hash_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The block hash of the execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_block_hash_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The block hash of the execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_block_number_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the execution payload (filter: eq)',
        })
      ),
      execution_payload_block_number_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the execution payload (filter: ne)',
        })
      ),
      execution_payload_block_number_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the execution payload (filter: lt)',
        })
      ),
      execution_payload_block_number_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the execution payload (filter: lte)',
        })
      ),
      execution_payload_block_number_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the execution payload (filter: gt)',
        })
      ),
      execution_payload_block_number_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the execution payload (filter: gte)',
        })
      ),
      execution_payload_block_number_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the execution payload (filter: between_min)',
        })
      ),
      execution_payload_block_number_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the execution payload (filter: between_max_value)',
        })
      ),
      execution_payload_block_number_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The block number of the execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_block_number_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The block number of the execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_fee_recipient_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The recipient of the fee for this execution payload (filter: eq)',
        })
      ),
      execution_payload_fee_recipient_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The recipient of the fee for this execution payload (filter: ne)',
        })
      ),
      execution_payload_fee_recipient_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The recipient of the fee for this execution payload (filter: contains)',
        })
      ),
      execution_payload_fee_recipient_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The recipient of the fee for this execution payload (filter: starts_with)',
        })
      ),
      execution_payload_fee_recipient_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The recipient of the fee for this execution payload (filter: ends_with)',
        })
      ),
      execution_payload_fee_recipient_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The recipient of the fee for this execution payload (filter: like)',
        })
      ),
      execution_payload_fee_recipient_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The recipient of the fee for this execution payload (filter: not_like)',
        })
      ),
      execution_payload_fee_recipient_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'The recipient of the fee for this execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_fee_recipient_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'The recipient of the fee for this execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_base_fee_per_gas_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Base fee per gas for execution payload (filter: eq)',
        })
      ),
      execution_payload_base_fee_per_gas_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Base fee per gas for execution payload (filter: ne)',
        })
      ),
      execution_payload_base_fee_per_gas_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Base fee per gas for execution payload (filter: contains)',
        })
      ),
      execution_payload_base_fee_per_gas_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Base fee per gas for execution payload (filter: starts_with)',
        })
      ),
      execution_payload_base_fee_per_gas_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Base fee per gas for execution payload (filter: ends_with)',
        })
      ),
      execution_payload_base_fee_per_gas_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Base fee per gas for execution payload (filter: like)',
        })
      ),
      execution_payload_base_fee_per_gas_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Base fee per gas for execution payload (filter: not_like)',
        })
      ),
      execution_payload_base_fee_per_gas_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Base fee per gas for execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_base_fee_per_gas_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Base fee per gas for execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_blob_gas_used_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for blobs in execution payload (filter: eq)',
        })
      ),
      execution_payload_blob_gas_used_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for blobs in execution payload (filter: ne)',
        })
      ),
      execution_payload_blob_gas_used_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for blobs in execution payload (filter: lt)',
        })
      ),
      execution_payload_blob_gas_used_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for blobs in execution payload (filter: lte)',
        })
      ),
      execution_payload_blob_gas_used_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for blobs in execution payload (filter: gt)',
        })
      ),
      execution_payload_blob_gas_used_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for blobs in execution payload (filter: gte)',
        })
      ),
      execution_payload_blob_gas_used_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for blobs in execution payload (filter: between_min)',
        })
      ),
      execution_payload_blob_gas_used_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for blobs in execution payload (filter: between_max_value)',
        })
      ),
      execution_payload_blob_gas_used_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Gas used for blobs in execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_blob_gas_used_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Gas used for blobs in execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_excess_blob_gas_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Excess gas used for blobs in execution payload (filter: eq)',
        })
      ),
      execution_payload_excess_blob_gas_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Excess gas used for blobs in execution payload (filter: ne)',
        })
      ),
      execution_payload_excess_blob_gas_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Excess gas used for blobs in execution payload (filter: lt)',
        })
      ),
      execution_payload_excess_blob_gas_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Excess gas used for blobs in execution payload (filter: lte)',
        })
      ),
      execution_payload_excess_blob_gas_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Excess gas used for blobs in execution payload (filter: gt)',
        })
      ),
      execution_payload_excess_blob_gas_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Excess gas used for blobs in execution payload (filter: gte)',
        })
      ),
      execution_payload_excess_blob_gas_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Excess gas used for blobs in execution payload (filter: between_min)',
        })
      ),
      execution_payload_excess_blob_gas_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Excess gas used for blobs in execution payload (filter: between_max_value)',
        })
      ),
      execution_payload_excess_blob_gas_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Excess gas used for blobs in execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_excess_blob_gas_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Excess gas used for blobs in execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_gas_limit_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas limit for execution payload (filter: eq)',
        })
      ),
      execution_payload_gas_limit_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas limit for execution payload (filter: ne)',
        })
      ),
      execution_payload_gas_limit_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas limit for execution payload (filter: lt)',
        })
      ),
      execution_payload_gas_limit_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas limit for execution payload (filter: lte)',
        })
      ),
      execution_payload_gas_limit_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas limit for execution payload (filter: gt)',
        })
      ),
      execution_payload_gas_limit_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas limit for execution payload (filter: gte)',
        })
      ),
      execution_payload_gas_limit_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas limit for execution payload (filter: between_min)',
        })
      ),
      execution_payload_gas_limit_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas limit for execution payload (filter: between_max_value)',
        })
      ),
      execution_payload_gas_limit_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Gas limit for execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_gas_limit_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Gas limit for execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_gas_used_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for execution payload (filter: eq)',
        })
      ),
      execution_payload_gas_used_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for execution payload (filter: ne)',
        })
      ),
      execution_payload_gas_used_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for execution payload (filter: lt)',
        })
      ),
      execution_payload_gas_used_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for execution payload (filter: lte)',
        })
      ),
      execution_payload_gas_used_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for execution payload (filter: gt)',
        })
      ),
      execution_payload_gas_used_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for execution payload (filter: gte)',
        })
      ),
      execution_payload_gas_used_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for execution payload (filter: between_min)',
        })
      ),
      execution_payload_gas_used_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for execution payload (filter: between_max_value)',
        })
      ),
      execution_payload_gas_used_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Gas used for execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_gas_used_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Gas used for execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_state_root_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The state root of the execution payload (filter: eq)',
        })
      ),
      execution_payload_state_root_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The state root of the execution payload (filter: ne)',
        })
      ),
      execution_payload_state_root_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The state root of the execution payload (filter: contains)',
        })
      ),
      execution_payload_state_root_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The state root of the execution payload (filter: starts_with)',
        })
      ),
      execution_payload_state_root_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The state root of the execution payload (filter: ends_with)',
        })
      ),
      execution_payload_state_root_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The state root of the execution payload (filter: like)',
        })
      ),
      execution_payload_state_root_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The state root of the execution payload (filter: not_like)',
        })
      ),
      execution_payload_state_root_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The state root of the execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_state_root_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The state root of the execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_parent_hash_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the execution payload (filter: eq)',
        })
      ),
      execution_payload_parent_hash_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the execution payload (filter: ne)',
        })
      ),
      execution_payload_parent_hash_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the execution payload (filter: contains)',
        })
      ),
      execution_payload_parent_hash_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the execution payload (filter: starts_with)',
        })
      ),
      execution_payload_parent_hash_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the execution payload (filter: ends_with)',
        })
      ),
      execution_payload_parent_hash_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the execution payload (filter: like)',
        })
      ),
      execution_payload_parent_hash_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the execution payload (filter: not_like)',
        })
      ),
      execution_payload_parent_hash_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The parent hash of the execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_parent_hash_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The parent hash of the execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_transactions_count_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction count of the execution payload (filter: eq)',
        })
      ),
      execution_payload_transactions_count_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction count of the execution payload (filter: ne)',
        })
      ),
      execution_payload_transactions_count_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction count of the execution payload (filter: lt)',
        })
      ),
      execution_payload_transactions_count_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction count of the execution payload (filter: lte)',
        })
      ),
      execution_payload_transactions_count_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction count of the execution payload (filter: gt)',
        })
      ),
      execution_payload_transactions_count_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction count of the execution payload (filter: gte)',
        })
      ),
      execution_payload_transactions_count_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction count of the execution payload (filter: between_min)',
        })
      ),
      execution_payload_transactions_count_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction count of the execution payload (filter: between_max_value)',
        })
      ),
      execution_payload_transactions_count_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The transaction count of the execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_transactions_count_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The transaction count of the execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_transactions_total_bytes_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload (filter: eq)',
        })
      ),
      execution_payload_transactions_total_bytes_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload (filter: ne)',
        })
      ),
      execution_payload_transactions_total_bytes_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload (filter: lt)',
        })
      ),
      execution_payload_transactions_total_bytes_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload (filter: lte)',
        })
      ),
      execution_payload_transactions_total_bytes_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload (filter: gt)',
        })
      ),
      execution_payload_transactions_total_bytes_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload (filter: gte)',
        })
      ),
      execution_payload_transactions_total_bytes_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload (filter: between_min)',
        })
      ),
      execution_payload_transactions_total_bytes_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload (filter: between_max_value)',
        })
      ),
      execution_payload_transactions_total_bytes_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The transaction total bytes of the execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_transactions_total_bytes_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The transaction total bytes of the execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_transactions_total_bytes_compressed_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload when compressed using snappy (filter: eq)',
        })
      ),
      execution_payload_transactions_total_bytes_compressed_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload when compressed using snappy (filter: ne)',
        })
      ),
      execution_payload_transactions_total_bytes_compressed_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload when compressed using snappy (filter: lt)',
        })
      ),
      execution_payload_transactions_total_bytes_compressed_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The transaction total bytes of the execution payload when compressed using snappy (filter: lte)',
        })
      ),
      execution_payload_transactions_total_bytes_compressed_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload when compressed using snappy (filter: gt)',
        })
      ),
      execution_payload_transactions_total_bytes_compressed_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The transaction total bytes of the execution payload when compressed using snappy (filter: gte)',
        })
      ),
      execution_payload_transactions_total_bytes_compressed_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The transaction total bytes of the execution payload when compressed using snappy (filter: between_min)',
        })
      ),
      execution_payload_transactions_total_bytes_compressed_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The transaction total bytes of the execution payload when compressed using snappy (filter: between_max_value)',
        })
      ),
      execution_payload_transactions_total_bytes_compressed_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The transaction total bytes of the execution payload when compressed using snappy (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_transactions_total_bytes_compressed_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The transaction total bytes of the execution payload when compressed using snappy (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_block_head to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctBlockHead` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctBlockHeadServiceListResponse = zListFctBlockHeadResponse;

export const zFctBlockHeadServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    slot_start_date_time: z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the reorg slot started',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctBlockHeadServiceGetResponse = zGetFctBlockHeadResponse;

export const zFctBlockMevServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      slot_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the proposer payload is for (filter: eq)',
        })
      ),
      slot_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the proposer payload is for (filter: ne)',
        })
      ),
      slot_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the proposer payload is for (filter: lt)',
        })
      ),
      slot_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the proposer payload is for (filter: lte)',
        })
      ),
      slot_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the proposer payload is for (filter: gt)',
        })
      ),
      slot_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the proposer payload is for (filter: gte)',
        })
      ),
      slot_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the proposer payload is for (filter: between_min)',
        })
      ),
      slot_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the proposer payload is for (filter: between_max_value)',
        })
      ),
      slot_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The start time for the slot that the proposer payload is for (filter: in_values) (comma-separated list)',
          })
      ),
      slot_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The start time for the slot that the proposer payload is for (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_root_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: eq)',
        })
      ),
      block_root_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: ne)',
        })
      ),
      block_root_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: contains)',
        })
      ),
      block_root_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: starts_with)',
        })
      ),
      block_root_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: ends_with)',
        })
      ),
      block_root_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: like)',
        })
      ),
      block_root_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: not_like)',
        })
      ),
      block_root_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The root hash of the beacon block (filter: in_values) (comma-separated list)',
          })
      ),
      block_root_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The root hash of the beacon block (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      slot_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block proposer payload (filter: eq)',
        })
      ),
      slot_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block proposer payload (filter: ne)',
        })
      ),
      slot_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block proposer payload (filter: lt)',
        })
      ),
      slot_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block proposer payload (filter: lte)',
        })
      ),
      slot_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block proposer payload (filter: gt)',
        })
      ),
      slot_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block proposer payload (filter: gte)',
        })
      ),
      slot_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block proposer payload (filter: between_min)',
        })
      ),
      slot_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block proposer payload (filter: between_max_value)',
        })
      ),
      slot_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Slot number within the block proposer payload (filter: in_values) (comma-separated list)',
          })
      ),
      slot_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Slot number within the block proposer payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the proposer payload is for (filter: eq)',
        })
      ),
      epoch_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the proposer payload is for (filter: ne)',
        })
      ),
      epoch_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the proposer payload is for (filter: lt)',
        })
      ),
      epoch_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the proposer payload is for (filter: lte)',
        })
      ),
      epoch_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the proposer payload is for (filter: gt)',
        })
      ),
      epoch_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the proposer payload is for (filter: gte)',
        })
      ),
      epoch_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the proposer payload is for (filter: between_min)',
        })
      ),
      epoch_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'Epoch number derived from the slot that the proposer payload is for (filter: between_max_value)',
        })
      ),
      epoch_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Epoch number derived from the slot that the proposer payload is for (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Epoch number derived from the slot that the proposer payload is for (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the proposer payload is for (filter: eq)',
        })
      ),
      epoch_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the proposer payload is for (filter: ne)',
        })
      ),
      epoch_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the proposer payload is for (filter: lt)',
        })
      ),
      epoch_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the proposer payload is for (filter: lte)',
        })
      ),
      epoch_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the proposer payload is for (filter: gt)',
        })
      ),
      epoch_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the proposer payload is for (filter: gte)',
        })
      ),
      epoch_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the proposer payload is for (filter: between_min)',
        })
      ),
      epoch_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the proposer payload is for (filter: between_max_value)',
        })
      ),
      epoch_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The start time for the epoch that the proposer payload is for (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The start time for the epoch that the proposer payload is for (filter: not_in_values) (comma-separated list)',
          })
      ),
      earliest_bid_date_time_eq: z.optional(
        z.coerce.bigint().register(z.globalRegistry, {
          description: 'The earliest timestamp of the accepted bid in milliseconds (filter: eq)',
        })
      ),
      earliest_bid_date_time_ne: z.optional(
        z.coerce.bigint().register(z.globalRegistry, {
          description: 'The earliest timestamp of the accepted bid in milliseconds (filter: ne)',
        })
      ),
      earliest_bid_date_time_lt: z.optional(
        z.coerce.bigint().register(z.globalRegistry, {
          description: 'The earliest timestamp of the accepted bid in milliseconds (filter: lt)',
        })
      ),
      earliest_bid_date_time_lte: z.optional(
        z.coerce.bigint().register(z.globalRegistry, {
          description: 'The earliest timestamp of the accepted bid in milliseconds (filter: lte)',
        })
      ),
      earliest_bid_date_time_gt: z.optional(
        z.coerce.bigint().register(z.globalRegistry, {
          description: 'The earliest timestamp of the accepted bid in milliseconds (filter: gt)',
        })
      ),
      earliest_bid_date_time_gte: z.optional(
        z.coerce.bigint().register(z.globalRegistry, {
          description: 'The earliest timestamp of the accepted bid in milliseconds (filter: gte)',
        })
      ),
      earliest_bid_date_time_between_min: z.optional(
        z.coerce.bigint().register(z.globalRegistry, {
          description: 'The earliest timestamp of the accepted bid in milliseconds (filter: between_min)',
        })
      ),
      earliest_bid_date_time_between_max_value: z.optional(
        z.coerce.bigint().register(z.globalRegistry, {
          description: 'The earliest timestamp of the accepted bid in milliseconds (filter: between_max_value)',
        })
      ),
      earliest_bid_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^-?\d+(,-?\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The earliest timestamp of the accepted bid in milliseconds (filter: in_values) (comma-separated list)',
          })
      ),
      earliest_bid_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^-?\d+(,-?\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The earliest timestamp of the accepted bid in milliseconds (filter: not_in_values) (comma-separated list)',
          })
      ),
      relay_names: z.optional(
        z.array(z.string()).register(z.globalRegistry, {
          description: 'Filter by relay_names - The relay names that delivered the proposer payload (optional)',
        })
      ),
      parent_hash_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the proposer payload (filter: eq)',
        })
      ),
      parent_hash_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the proposer payload (filter: ne)',
        })
      ),
      parent_hash_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the proposer payload (filter: contains)',
        })
      ),
      parent_hash_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the proposer payload (filter: starts_with)',
        })
      ),
      parent_hash_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the proposer payload (filter: ends_with)',
        })
      ),
      parent_hash_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the proposer payload (filter: like)',
        })
      ),
      parent_hash_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the proposer payload (filter: not_like)',
        })
      ),
      parent_hash_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The parent hash of the proposer payload (filter: in_values) (comma-separated list)',
          })
      ),
      parent_hash_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The parent hash of the proposer payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_number_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the proposer payload (filter: eq)',
        })
      ),
      block_number_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the proposer payload (filter: ne)',
        })
      ),
      block_number_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the proposer payload (filter: lt)',
        })
      ),
      block_number_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the proposer payload (filter: lte)',
        })
      ),
      block_number_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the proposer payload (filter: gt)',
        })
      ),
      block_number_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the proposer payload (filter: gte)',
        })
      ),
      block_number_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the proposer payload (filter: between_min)',
        })
      ),
      block_number_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the proposer payload (filter: between_max_value)',
        })
      ),
      block_number_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The block number of the proposer payload (filter: in_values) (comma-separated list)',
          })
      ),
      block_number_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The block number of the proposer payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_hash_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the proposer payload (filter: eq)',
        })
      ),
      block_hash_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the proposer payload (filter: ne)',
        })
      ),
      block_hash_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the proposer payload (filter: contains)',
        })
      ),
      block_hash_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the proposer payload (filter: starts_with)',
        })
      ),
      block_hash_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the proposer payload (filter: ends_with)',
        })
      ),
      block_hash_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the proposer payload (filter: like)',
        })
      ),
      block_hash_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the proposer payload (filter: not_like)',
        })
      ),
      block_hash_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The block hash of the proposer payload (filter: in_values) (comma-separated list)',
          })
      ),
      block_hash_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The block hash of the proposer payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      builder_pubkey_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The builder pubkey of the proposer payload (filter: eq)',
        })
      ),
      builder_pubkey_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The builder pubkey of the proposer payload (filter: ne)',
        })
      ),
      builder_pubkey_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The builder pubkey of the proposer payload (filter: contains)',
        })
      ),
      builder_pubkey_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The builder pubkey of the proposer payload (filter: starts_with)',
        })
      ),
      builder_pubkey_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The builder pubkey of the proposer payload (filter: ends_with)',
        })
      ),
      builder_pubkey_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The builder pubkey of the proposer payload (filter: like)',
        })
      ),
      builder_pubkey_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The builder pubkey of the proposer payload (filter: not_like)',
        })
      ),
      builder_pubkey_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The builder pubkey of the proposer payload (filter: in_values) (comma-separated list)',
          })
      ),
      builder_pubkey_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The builder pubkey of the proposer payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      proposer_pubkey_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer pubkey of the proposer payload (filter: eq)',
        })
      ),
      proposer_pubkey_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer pubkey of the proposer payload (filter: ne)',
        })
      ),
      proposer_pubkey_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer pubkey of the proposer payload (filter: contains)',
        })
      ),
      proposer_pubkey_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer pubkey of the proposer payload (filter: starts_with)',
        })
      ),
      proposer_pubkey_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer pubkey of the proposer payload (filter: ends_with)',
        })
      ),
      proposer_pubkey_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer pubkey of the proposer payload (filter: like)',
        })
      ),
      proposer_pubkey_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer pubkey of the proposer payload (filter: not_like)',
        })
      ),
      proposer_pubkey_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The proposer pubkey of the proposer payload (filter: in_values) (comma-separated list)',
          })
      ),
      proposer_pubkey_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The proposer pubkey of the proposer payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      proposer_fee_recipient_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer fee recipient of the proposer payload (filter: eq)',
        })
      ),
      proposer_fee_recipient_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer fee recipient of the proposer payload (filter: ne)',
        })
      ),
      proposer_fee_recipient_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer fee recipient of the proposer payload (filter: contains)',
        })
      ),
      proposer_fee_recipient_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer fee recipient of the proposer payload (filter: starts_with)',
        })
      ),
      proposer_fee_recipient_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer fee recipient of the proposer payload (filter: ends_with)',
        })
      ),
      proposer_fee_recipient_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer fee recipient of the proposer payload (filter: like)',
        })
      ),
      proposer_fee_recipient_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer fee recipient of the proposer payload (filter: not_like)',
        })
      ),
      proposer_fee_recipient_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'The proposer fee recipient of the proposer payload (filter: in_values) (comma-separated list)',
          })
      ),
      proposer_fee_recipient_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'The proposer fee recipient of the proposer payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      gas_limit_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas limit of the proposer payload (filter: eq)',
        })
      ),
      gas_limit_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas limit of the proposer payload (filter: ne)',
        })
      ),
      gas_limit_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas limit of the proposer payload (filter: lt)',
        })
      ),
      gas_limit_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas limit of the proposer payload (filter: lte)',
        })
      ),
      gas_limit_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas limit of the proposer payload (filter: gt)',
        })
      ),
      gas_limit_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas limit of the proposer payload (filter: gte)',
        })
      ),
      gas_limit_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas limit of the proposer payload (filter: between_min)',
        })
      ),
      gas_limit_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas limit of the proposer payload (filter: between_max_value)',
        })
      ),
      gas_limit_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The gas limit of the proposer payload (filter: in_values) (comma-separated list)',
          })
      ),
      gas_limit_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The gas limit of the proposer payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      gas_used_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas used of the proposer payload (filter: eq)',
        })
      ),
      gas_used_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas used of the proposer payload (filter: ne)',
        })
      ),
      gas_used_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas used of the proposer payload (filter: lt)',
        })
      ),
      gas_used_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas used of the proposer payload (filter: lte)',
        })
      ),
      gas_used_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas used of the proposer payload (filter: gt)',
        })
      ),
      gas_used_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas used of the proposer payload (filter: gte)',
        })
      ),
      gas_used_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas used of the proposer payload (filter: between_min)',
        })
      ),
      gas_used_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas used of the proposer payload (filter: between_max_value)',
        })
      ),
      gas_used_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The gas used of the proposer payload (filter: in_values) (comma-separated list)',
          })
      ),
      gas_used_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The gas used of the proposer payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      value_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The transaction value in wei (filter: eq)',
        })
      ),
      value_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The transaction value in wei (filter: ne)',
        })
      ),
      value_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The transaction value in wei (filter: contains)',
        })
      ),
      value_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The transaction value in wei (filter: starts_with)',
        })
      ),
      value_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The transaction value in wei (filter: ends_with)',
        })
      ),
      value_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The transaction value in wei (filter: like)',
        })
      ),
      value_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The transaction value in wei (filter: not_like)',
        })
      ),
      value_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The transaction value in wei (filter: in_values) (comma-separated list)',
          })
      ),
      value_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The transaction value in wei (filter: not_in_values) (comma-separated list)',
          })
      ),
      transaction_count_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of transactions in the proposer payload (filter: eq)',
        })
      ),
      transaction_count_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of transactions in the proposer payload (filter: ne)',
        })
      ),
      transaction_count_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of transactions in the proposer payload (filter: lt)',
        })
      ),
      transaction_count_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of transactions in the proposer payload (filter: lte)',
        })
      ),
      transaction_count_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of transactions in the proposer payload (filter: gt)',
        })
      ),
      transaction_count_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of transactions in the proposer payload (filter: gte)',
        })
      ),
      transaction_count_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of transactions in the proposer payload (filter: between_min)',
        })
      ),
      transaction_count_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of transactions in the proposer payload (filter: between_max_value)',
        })
      ),
      transaction_count_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The number of transactions in the proposer payload (filter: in_values) (comma-separated list)',
          })
      ),
      transaction_count_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The number of transactions in the proposer payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      status_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical" or "orphaned" (filter: eq)',
        })
      ),
      status_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical" or "orphaned" (filter: ne)',
        })
      ),
      status_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical" or "orphaned" (filter: contains)',
        })
      ),
      status_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical" or "orphaned" (filter: starts_with)',
        })
      ),
      status_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical" or "orphaned" (filter: ends_with)',
        })
      ),
      status_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical" or "orphaned" (filter: like)',
        })
      ),
      status_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical" or "orphaned" (filter: not_like)',
        })
      ),
      status_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Can be "canonical" or "orphaned" (filter: in_values) (comma-separated list)',
          })
      ),
      status_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Can be "canonical" or "orphaned" (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_block_mev to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctBlockMev` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctBlockMevServiceListResponse = zListFctBlockMevResponse;

export const zFctBlockMevServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    slot_start_date_time: z.int().register(z.globalRegistry, {
      description: 'The start time for the slot that the proposer payload is for',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctBlockMevServiceGetResponse = zGetFctBlockMevResponse;

export const zFctBlockMevHeadServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      slot_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the proposer payload is for (filter: eq)',
        })
      ),
      slot_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the proposer payload is for (filter: ne)',
        })
      ),
      slot_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the proposer payload is for (filter: lt)',
        })
      ),
      slot_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the proposer payload is for (filter: lte)',
        })
      ),
      slot_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the proposer payload is for (filter: gt)',
        })
      ),
      slot_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the proposer payload is for (filter: gte)',
        })
      ),
      slot_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the proposer payload is for (filter: between_min)',
        })
      ),
      slot_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the proposer payload is for (filter: between_max_value)',
        })
      ),
      slot_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The start time for the slot that the proposer payload is for (filter: in_values) (comma-separated list)',
          })
      ),
      slot_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The start time for the slot that the proposer payload is for (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_root_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: eq)',
        })
      ),
      block_root_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: ne)',
        })
      ),
      block_root_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: contains)',
        })
      ),
      block_root_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: starts_with)',
        })
      ),
      block_root_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: ends_with)',
        })
      ),
      block_root_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: like)',
        })
      ),
      block_root_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The root hash of the beacon block (filter: not_like)',
        })
      ),
      block_root_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The root hash of the beacon block (filter: in_values) (comma-separated list)',
          })
      ),
      block_root_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The root hash of the beacon block (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      slot_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block proposer payload (filter: eq)',
        })
      ),
      slot_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block proposer payload (filter: ne)',
        })
      ),
      slot_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block proposer payload (filter: lt)',
        })
      ),
      slot_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block proposer payload (filter: lte)',
        })
      ),
      slot_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block proposer payload (filter: gt)',
        })
      ),
      slot_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block proposer payload (filter: gte)',
        })
      ),
      slot_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block proposer payload (filter: between_min)',
        })
      ),
      slot_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block proposer payload (filter: between_max_value)',
        })
      ),
      slot_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Slot number within the block proposer payload (filter: in_values) (comma-separated list)',
          })
      ),
      slot_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Slot number within the block proposer payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the proposer payload is for (filter: eq)',
        })
      ),
      epoch_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the proposer payload is for (filter: ne)',
        })
      ),
      epoch_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the proposer payload is for (filter: lt)',
        })
      ),
      epoch_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the proposer payload is for (filter: lte)',
        })
      ),
      epoch_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the proposer payload is for (filter: gt)',
        })
      ),
      epoch_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the proposer payload is for (filter: gte)',
        })
      ),
      epoch_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the proposer payload is for (filter: between_min)',
        })
      ),
      epoch_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'Epoch number derived from the slot that the proposer payload is for (filter: between_max_value)',
        })
      ),
      epoch_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Epoch number derived from the slot that the proposer payload is for (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Epoch number derived from the slot that the proposer payload is for (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the proposer payload is for (filter: eq)',
        })
      ),
      epoch_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the proposer payload is for (filter: ne)',
        })
      ),
      epoch_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the proposer payload is for (filter: lt)',
        })
      ),
      epoch_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the proposer payload is for (filter: lte)',
        })
      ),
      epoch_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the proposer payload is for (filter: gt)',
        })
      ),
      epoch_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the proposer payload is for (filter: gte)',
        })
      ),
      epoch_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the proposer payload is for (filter: between_min)',
        })
      ),
      epoch_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the proposer payload is for (filter: between_max_value)',
        })
      ),
      epoch_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The start time for the epoch that the proposer payload is for (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The start time for the epoch that the proposer payload is for (filter: not_in_values) (comma-separated list)',
          })
      ),
      earliest_bid_date_time_eq: z.optional(
        z.coerce.bigint().register(z.globalRegistry, {
          description: 'The earliest timestamp of the accepted bid in milliseconds (filter: eq)',
        })
      ),
      earliest_bid_date_time_ne: z.optional(
        z.coerce.bigint().register(z.globalRegistry, {
          description: 'The earliest timestamp of the accepted bid in milliseconds (filter: ne)',
        })
      ),
      earliest_bid_date_time_lt: z.optional(
        z.coerce.bigint().register(z.globalRegistry, {
          description: 'The earliest timestamp of the accepted bid in milliseconds (filter: lt)',
        })
      ),
      earliest_bid_date_time_lte: z.optional(
        z.coerce.bigint().register(z.globalRegistry, {
          description: 'The earliest timestamp of the accepted bid in milliseconds (filter: lte)',
        })
      ),
      earliest_bid_date_time_gt: z.optional(
        z.coerce.bigint().register(z.globalRegistry, {
          description: 'The earliest timestamp of the accepted bid in milliseconds (filter: gt)',
        })
      ),
      earliest_bid_date_time_gte: z.optional(
        z.coerce.bigint().register(z.globalRegistry, {
          description: 'The earliest timestamp of the accepted bid in milliseconds (filter: gte)',
        })
      ),
      earliest_bid_date_time_between_min: z.optional(
        z.coerce.bigint().register(z.globalRegistry, {
          description: 'The earliest timestamp of the accepted bid in milliseconds (filter: between_min)',
        })
      ),
      earliest_bid_date_time_between_max_value: z.optional(
        z.coerce.bigint().register(z.globalRegistry, {
          description: 'The earliest timestamp of the accepted bid in milliseconds (filter: between_max_value)',
        })
      ),
      earliest_bid_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^-?\d+(,-?\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The earliest timestamp of the accepted bid in milliseconds (filter: in_values) (comma-separated list)',
          })
      ),
      earliest_bid_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^-?\d+(,-?\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The earliest timestamp of the accepted bid in milliseconds (filter: not_in_values) (comma-separated list)',
          })
      ),
      relay_names: z.optional(
        z.array(z.string()).register(z.globalRegistry, {
          description: 'Filter by relay_names - The relay names that delivered the proposer payload (optional)',
        })
      ),
      parent_hash_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the proposer payload (filter: eq)',
        })
      ),
      parent_hash_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the proposer payload (filter: ne)',
        })
      ),
      parent_hash_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the proposer payload (filter: contains)',
        })
      ),
      parent_hash_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the proposer payload (filter: starts_with)',
        })
      ),
      parent_hash_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the proposer payload (filter: ends_with)',
        })
      ),
      parent_hash_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the proposer payload (filter: like)',
        })
      ),
      parent_hash_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The parent hash of the proposer payload (filter: not_like)',
        })
      ),
      parent_hash_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The parent hash of the proposer payload (filter: in_values) (comma-separated list)',
          })
      ),
      parent_hash_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The parent hash of the proposer payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_number_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the proposer payload (filter: eq)',
        })
      ),
      block_number_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the proposer payload (filter: ne)',
        })
      ),
      block_number_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the proposer payload (filter: lt)',
        })
      ),
      block_number_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the proposer payload (filter: lte)',
        })
      ),
      block_number_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the proposer payload (filter: gt)',
        })
      ),
      block_number_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the proposer payload (filter: gte)',
        })
      ),
      block_number_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the proposer payload (filter: between_min)',
        })
      ),
      block_number_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the proposer payload (filter: between_max_value)',
        })
      ),
      block_number_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The block number of the proposer payload (filter: in_values) (comma-separated list)',
          })
      ),
      block_number_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The block number of the proposer payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_hash_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the proposer payload (filter: eq)',
        })
      ),
      block_hash_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the proposer payload (filter: ne)',
        })
      ),
      block_hash_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the proposer payload (filter: contains)',
        })
      ),
      block_hash_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the proposer payload (filter: starts_with)',
        })
      ),
      block_hash_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the proposer payload (filter: ends_with)',
        })
      ),
      block_hash_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the proposer payload (filter: like)',
        })
      ),
      block_hash_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The block hash of the proposer payload (filter: not_like)',
        })
      ),
      block_hash_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The block hash of the proposer payload (filter: in_values) (comma-separated list)',
          })
      ),
      block_hash_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The block hash of the proposer payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      builder_pubkey_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The builder pubkey of the proposer payload (filter: eq)',
        })
      ),
      builder_pubkey_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The builder pubkey of the proposer payload (filter: ne)',
        })
      ),
      builder_pubkey_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The builder pubkey of the proposer payload (filter: contains)',
        })
      ),
      builder_pubkey_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The builder pubkey of the proposer payload (filter: starts_with)',
        })
      ),
      builder_pubkey_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The builder pubkey of the proposer payload (filter: ends_with)',
        })
      ),
      builder_pubkey_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The builder pubkey of the proposer payload (filter: like)',
        })
      ),
      builder_pubkey_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The builder pubkey of the proposer payload (filter: not_like)',
        })
      ),
      builder_pubkey_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The builder pubkey of the proposer payload (filter: in_values) (comma-separated list)',
          })
      ),
      builder_pubkey_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The builder pubkey of the proposer payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      proposer_pubkey_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer pubkey of the proposer payload (filter: eq)',
        })
      ),
      proposer_pubkey_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer pubkey of the proposer payload (filter: ne)',
        })
      ),
      proposer_pubkey_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer pubkey of the proposer payload (filter: contains)',
        })
      ),
      proposer_pubkey_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer pubkey of the proposer payload (filter: starts_with)',
        })
      ),
      proposer_pubkey_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer pubkey of the proposer payload (filter: ends_with)',
        })
      ),
      proposer_pubkey_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer pubkey of the proposer payload (filter: like)',
        })
      ),
      proposer_pubkey_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer pubkey of the proposer payload (filter: not_like)',
        })
      ),
      proposer_pubkey_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The proposer pubkey of the proposer payload (filter: in_values) (comma-separated list)',
          })
      ),
      proposer_pubkey_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The proposer pubkey of the proposer payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      proposer_fee_recipient_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer fee recipient of the proposer payload (filter: eq)',
        })
      ),
      proposer_fee_recipient_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer fee recipient of the proposer payload (filter: ne)',
        })
      ),
      proposer_fee_recipient_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer fee recipient of the proposer payload (filter: contains)',
        })
      ),
      proposer_fee_recipient_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer fee recipient of the proposer payload (filter: starts_with)',
        })
      ),
      proposer_fee_recipient_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer fee recipient of the proposer payload (filter: ends_with)',
        })
      ),
      proposer_fee_recipient_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer fee recipient of the proposer payload (filter: like)',
        })
      ),
      proposer_fee_recipient_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The proposer fee recipient of the proposer payload (filter: not_like)',
        })
      ),
      proposer_fee_recipient_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'The proposer fee recipient of the proposer payload (filter: in_values) (comma-separated list)',
          })
      ),
      proposer_fee_recipient_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'The proposer fee recipient of the proposer payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      gas_limit_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas limit of the proposer payload (filter: eq)',
        })
      ),
      gas_limit_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas limit of the proposer payload (filter: ne)',
        })
      ),
      gas_limit_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas limit of the proposer payload (filter: lt)',
        })
      ),
      gas_limit_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas limit of the proposer payload (filter: lte)',
        })
      ),
      gas_limit_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas limit of the proposer payload (filter: gt)',
        })
      ),
      gas_limit_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas limit of the proposer payload (filter: gte)',
        })
      ),
      gas_limit_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas limit of the proposer payload (filter: between_min)',
        })
      ),
      gas_limit_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas limit of the proposer payload (filter: between_max_value)',
        })
      ),
      gas_limit_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The gas limit of the proposer payload (filter: in_values) (comma-separated list)',
          })
      ),
      gas_limit_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The gas limit of the proposer payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      gas_used_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas used of the proposer payload (filter: eq)',
        })
      ),
      gas_used_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas used of the proposer payload (filter: ne)',
        })
      ),
      gas_used_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas used of the proposer payload (filter: lt)',
        })
      ),
      gas_used_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas used of the proposer payload (filter: lte)',
        })
      ),
      gas_used_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas used of the proposer payload (filter: gt)',
        })
      ),
      gas_used_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas used of the proposer payload (filter: gte)',
        })
      ),
      gas_used_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas used of the proposer payload (filter: between_min)',
        })
      ),
      gas_used_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The gas used of the proposer payload (filter: between_max_value)',
        })
      ),
      gas_used_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The gas used of the proposer payload (filter: in_values) (comma-separated list)',
          })
      ),
      gas_used_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The gas used of the proposer payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      value_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The transaction value in wei (filter: eq)',
        })
      ),
      value_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The transaction value in wei (filter: ne)',
        })
      ),
      value_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The transaction value in wei (filter: contains)',
        })
      ),
      value_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The transaction value in wei (filter: starts_with)',
        })
      ),
      value_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The transaction value in wei (filter: ends_with)',
        })
      ),
      value_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The transaction value in wei (filter: like)',
        })
      ),
      value_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The transaction value in wei (filter: not_like)',
        })
      ),
      value_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The transaction value in wei (filter: in_values) (comma-separated list)',
          })
      ),
      value_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The transaction value in wei (filter: not_in_values) (comma-separated list)',
          })
      ),
      transaction_count_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of transactions in the proposer payload (filter: eq)',
        })
      ),
      transaction_count_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of transactions in the proposer payload (filter: ne)',
        })
      ),
      transaction_count_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of transactions in the proposer payload (filter: lt)',
        })
      ),
      transaction_count_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of transactions in the proposer payload (filter: lte)',
        })
      ),
      transaction_count_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of transactions in the proposer payload (filter: gt)',
        })
      ),
      transaction_count_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of transactions in the proposer payload (filter: gte)',
        })
      ),
      transaction_count_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of transactions in the proposer payload (filter: between_min)',
        })
      ),
      transaction_count_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The number of transactions in the proposer payload (filter: between_max_value)',
        })
      ),
      transaction_count_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The number of transactions in the proposer payload (filter: in_values) (comma-separated list)',
          })
      ),
      transaction_count_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The number of transactions in the proposer payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_block_mev_head to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctBlockMevHead` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctBlockMevHeadServiceListResponse = zListFctBlockMevHeadResponse;

export const zFctBlockMevHeadServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    slot_start_date_time: z.int().register(z.globalRegistry, {
      description: 'The start time for the slot that the proposer payload is for',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctBlockMevHeadServiceGetResponse = zGetFctBlockMevHeadResponse;

export const zFctBlockProposerServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      slot_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: eq)',
        })
      ),
      slot_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: ne)',
        })
      ),
      slot_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lt)',
        })
      ),
      slot_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lte)',
        })
      ),
      slot_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gt)',
        })
      ),
      slot_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gte)',
        })
      ),
      slot_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_min)',
        })
      ),
      slot_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_max_value)',
        })
      ),
      slot_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: in_values) (comma-separated list)',
          })
      ),
      slot_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      slot_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: eq)',
        })
      ),
      slot_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: ne)',
        })
      ),
      slot_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: lt)',
        })
      ),
      slot_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: lte)',
        })
      ),
      slot_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: gt)',
        })
      ),
      slot_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: gte)',
        })
      ),
      slot_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: between_min)',
        })
      ),
      slot_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: between_max_value)',
        })
      ),
      slot_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number (filter: in_values) (comma-separated list)',
          })
      ),
      slot_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: eq)',
        })
      ),
      epoch_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: ne)',
        })
      ),
      epoch_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: lt)',
        })
      ),
      epoch_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: lte)',
        })
      ),
      epoch_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: gt)',
        })
      ),
      epoch_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: gte)',
        })
      ),
      epoch_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: between_min)',
        })
      ),
      epoch_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: between_max_value)',
        })
      ),
      epoch_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number containing the slot (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number containing the slot (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: eq)',
        })
      ),
      epoch_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: ne)',
        })
      ),
      epoch_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lt)',
        })
      ),
      epoch_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lte)',
        })
      ),
      epoch_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gt)',
        })
      ),
      epoch_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gte)',
        })
      ),
      epoch_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_min)',
        })
      ),
      epoch_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_max_value)',
        })
      ),
      epoch_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: not_in_values) (comma-separated list)',
          })
      ),
      proposer_validator_index_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The validator index of the proposer for the slot (filter: eq)',
        })
      ),
      proposer_validator_index_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The validator index of the proposer for the slot (filter: ne)',
        })
      ),
      proposer_validator_index_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The validator index of the proposer for the slot (filter: lt)',
        })
      ),
      proposer_validator_index_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The validator index of the proposer for the slot (filter: lte)',
        })
      ),
      proposer_validator_index_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The validator index of the proposer for the slot (filter: gt)',
        })
      ),
      proposer_validator_index_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The validator index of the proposer for the slot (filter: gte)',
        })
      ),
      proposer_validator_index_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The validator index of the proposer for the slot (filter: between_min)',
        })
      ),
      proposer_validator_index_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The validator index of the proposer for the slot (filter: between_max_value)',
        })
      ),
      proposer_validator_index_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The validator index of the proposer for the slot (filter: in_values) (comma-separated list)',
          })
      ),
      proposer_validator_index_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The validator index of the proposer for the slot (filter: not_in_values) (comma-separated list)',
          })
      ),
      proposer_pubkey_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The public key of the validator proposer (filter: eq)',
        })
      ),
      proposer_pubkey_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The public key of the validator proposer (filter: ne)',
        })
      ),
      proposer_pubkey_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The public key of the validator proposer (filter: contains)',
        })
      ),
      proposer_pubkey_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The public key of the validator proposer (filter: starts_with)',
        })
      ),
      proposer_pubkey_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The public key of the validator proposer (filter: ends_with)',
        })
      ),
      proposer_pubkey_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The public key of the validator proposer (filter: like)',
        })
      ),
      proposer_pubkey_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The public key of the validator proposer (filter: not_like)',
        })
      ),
      proposer_pubkey_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The public key of the validator proposer (filter: in_values) (comma-separated list)',
          })
      ),
      proposer_pubkey_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The public key of the validator proposer (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_root_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The beacon block root hash. Null if a block was never seen by a sentry, aka "missed" (filter: eq)',
        })
      ),
      block_root_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The beacon block root hash. Null if a block was never seen by a sentry, aka "missed" (filter: ne)',
        })
      ),
      block_root_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The beacon block root hash. Null if a block was never seen by a sentry, aka "missed" (filter: contains)',
        })
      ),
      block_root_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The beacon block root hash. Null if a block was never seen by a sentry, aka "missed" (filter: starts_with)',
        })
      ),
      block_root_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The beacon block root hash. Null if a block was never seen by a sentry, aka "missed" (filter: ends_with)',
        })
      ),
      block_root_like: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The beacon block root hash. Null if a block was never seen by a sentry, aka "missed" (filter: like)',
        })
      ),
      block_root_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The beacon block root hash. Null if a block was never seen by a sentry, aka "missed" (filter: not_like)',
        })
      ),
      block_root_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'The beacon block root hash. Null if a block was never seen by a sentry, aka "missed" (filter: in_values) (comma-separated list)',
          })
      ),
      block_root_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'The beacon block root hash. Null if a block was never seen by a sentry, aka "missed" (filter: not_in_values) (comma-separated list)',
          })
      ),
      status_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical", "orphaned" or "missed" (filter: eq)',
        })
      ),
      status_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical", "orphaned" or "missed" (filter: ne)',
        })
      ),
      status_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical", "orphaned" or "missed" (filter: contains)',
        })
      ),
      status_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical", "orphaned" or "missed" (filter: starts_with)',
        })
      ),
      status_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical", "orphaned" or "missed" (filter: ends_with)',
        })
      ),
      status_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical", "orphaned" or "missed" (filter: like)',
        })
      ),
      status_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Can be "canonical", "orphaned" or "missed" (filter: not_like)',
        })
      ),
      status_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Can be "canonical", "orphaned" or "missed" (filter: in_values) (comma-separated list)',
          })
      ),
      status_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Can be "canonical", "orphaned" or "missed" (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_block_proposer to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctBlockProposer` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctBlockProposerServiceListResponse = zListFctBlockProposerResponse;

export const zFctBlockProposerServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    slot_start_date_time: z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctBlockProposerServiceGetResponse = zGetFctBlockProposerResponse;

export const zFctBlockProposerEntityServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      slot_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: eq)',
        })
      ),
      slot_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: ne)',
        })
      ),
      slot_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lt)',
        })
      ),
      slot_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lte)',
        })
      ),
      slot_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gt)',
        })
      ),
      slot_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gte)',
        })
      ),
      slot_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_min)',
        })
      ),
      slot_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_max_value)',
        })
      ),
      slot_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: in_values) (comma-separated list)',
          })
      ),
      slot_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      slot_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: eq)',
        })
      ),
      slot_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: ne)',
        })
      ),
      slot_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: lt)',
        })
      ),
      slot_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: lte)',
        })
      ),
      slot_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: gt)',
        })
      ),
      slot_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: gte)',
        })
      ),
      slot_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: between_min)',
        })
      ),
      slot_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: between_max_value)',
        })
      ),
      slot_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number (filter: in_values) (comma-separated list)',
          })
      ),
      slot_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: eq)',
        })
      ),
      epoch_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: ne)',
        })
      ),
      epoch_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: lt)',
        })
      ),
      epoch_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: lte)',
        })
      ),
      epoch_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: gt)',
        })
      ),
      epoch_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: gte)',
        })
      ),
      epoch_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: between_min)',
        })
      ),
      epoch_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: between_max_value)',
        })
      ),
      epoch_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number containing the slot (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number containing the slot (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: eq)',
        })
      ),
      epoch_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: ne)',
        })
      ),
      epoch_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lt)',
        })
      ),
      epoch_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lte)',
        })
      ),
      epoch_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gt)',
        })
      ),
      epoch_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gte)',
        })
      ),
      epoch_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_min)',
        })
      ),
      epoch_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_max_value)',
        })
      ),
      epoch_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: not_in_values) (comma-separated list)',
          })
      ),
      entity_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The entity that proposed the block (filter: eq)',
        })
      ),
      entity_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The entity that proposed the block (filter: ne)',
        })
      ),
      entity_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The entity that proposed the block (filter: contains)',
        })
      ),
      entity_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The entity that proposed the block (filter: starts_with)',
        })
      ),
      entity_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The entity that proposed the block (filter: ends_with)',
        })
      ),
      entity_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The entity that proposed the block (filter: like)',
        })
      ),
      entity_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The entity that proposed the block (filter: not_like)',
        })
      ),
      entity_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The entity that proposed the block (filter: in_values) (comma-separated list)',
          })
      ),
      entity_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The entity that proposed the block (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_block_proposer_entity to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctBlockProposerEntity` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctBlockProposerEntityServiceListResponse = zListFctBlockProposerEntityResponse;

export const zFctBlockProposerEntityServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    slot_start_date_time: z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctBlockProposerEntityServiceGetResponse = zGetFctBlockProposerEntityResponse;

export const zFctBlockProposerHeadServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      slot_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: eq)',
        })
      ),
      slot_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: ne)',
        })
      ),
      slot_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lt)',
        })
      ),
      slot_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lte)',
        })
      ),
      slot_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gt)',
        })
      ),
      slot_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gte)',
        })
      ),
      slot_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_min)',
        })
      ),
      slot_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_max_value)',
        })
      ),
      slot_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: in_values) (comma-separated list)',
          })
      ),
      slot_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: not_in_values) (comma-separated list)',
          })
      ),
      proposer_validator_index_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The validator index of the proposer for the slot (filter: eq)',
        })
      ),
      proposer_validator_index_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The validator index of the proposer for the slot (filter: ne)',
        })
      ),
      proposer_validator_index_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The validator index of the proposer for the slot (filter: lt)',
        })
      ),
      proposer_validator_index_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The validator index of the proposer for the slot (filter: lte)',
        })
      ),
      proposer_validator_index_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The validator index of the proposer for the slot (filter: gt)',
        })
      ),
      proposer_validator_index_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The validator index of the proposer for the slot (filter: gte)',
        })
      ),
      proposer_validator_index_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The validator index of the proposer for the slot (filter: between_min)',
        })
      ),
      proposer_validator_index_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The validator index of the proposer for the slot (filter: between_max_value)',
        })
      ),
      proposer_validator_index_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The validator index of the proposer for the slot (filter: in_values) (comma-separated list)',
          })
      ),
      proposer_validator_index_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The validator index of the proposer for the slot (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      slot_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: eq)',
        })
      ),
      slot_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: ne)',
        })
      ),
      slot_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: lt)',
        })
      ),
      slot_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: lte)',
        })
      ),
      slot_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: gt)',
        })
      ),
      slot_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: gte)',
        })
      ),
      slot_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: between_min)',
        })
      ),
      slot_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number (filter: between_max_value)',
        })
      ),
      slot_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number (filter: in_values) (comma-separated list)',
          })
      ),
      slot_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: eq)',
        })
      ),
      epoch_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: ne)',
        })
      ),
      epoch_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: lt)',
        })
      ),
      epoch_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: lte)',
        })
      ),
      epoch_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: gt)',
        })
      ),
      epoch_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: gte)',
        })
      ),
      epoch_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: between_min)',
        })
      ),
      epoch_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The epoch number containing the slot (filter: between_max_value)',
        })
      ),
      epoch_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number containing the slot (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The epoch number containing the slot (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: eq)',
        })
      ),
      epoch_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: ne)',
        })
      ),
      epoch_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lt)',
        })
      ),
      epoch_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: lte)',
        })
      ),
      epoch_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gt)',
        })
      ),
      epoch_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: gte)',
        })
      ),
      epoch_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_min)',
        })
      ),
      epoch_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the epoch started (filter: between_max_value)',
        })
      ),
      epoch_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the epoch started (filter: not_in_values) (comma-separated list)',
          })
      ),
      proposer_pubkey_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The public key of the validator proposer (filter: eq)',
        })
      ),
      proposer_pubkey_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The public key of the validator proposer (filter: ne)',
        })
      ),
      proposer_pubkey_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The public key of the validator proposer (filter: contains)',
        })
      ),
      proposer_pubkey_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The public key of the validator proposer (filter: starts_with)',
        })
      ),
      proposer_pubkey_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The public key of the validator proposer (filter: ends_with)',
        })
      ),
      proposer_pubkey_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The public key of the validator proposer (filter: like)',
        })
      ),
      proposer_pubkey_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The public key of the validator proposer (filter: not_like)',
        })
      ),
      proposer_pubkey_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The public key of the validator proposer (filter: in_values) (comma-separated list)',
          })
      ),
      proposer_pubkey_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The public key of the validator proposer (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_root_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash. Null if a block was never seen by a sentry (filter: eq)',
        })
      ),
      block_root_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash. Null if a block was never seen by a sentry (filter: ne)',
        })
      ),
      block_root_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash. Null if a block was never seen by a sentry (filter: contains)',
        })
      ),
      block_root_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash. Null if a block was never seen by a sentry (filter: starts_with)',
        })
      ),
      block_root_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash. Null if a block was never seen by a sentry (filter: ends_with)',
        })
      ),
      block_root_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash. Null if a block was never seen by a sentry (filter: like)',
        })
      ),
      block_root_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The beacon block root hash. Null if a block was never seen by a sentry (filter: not_like)',
        })
      ),
      block_root_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'The beacon block root hash. Null if a block was never seen by a sentry (filter: in_values) (comma-separated list)',
          })
      ),
      block_root_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'The beacon block root hash. Null if a block was never seen by a sentry (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_block_proposer_head to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctBlockProposerHead` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctBlockProposerHeadServiceListResponse = zListFctBlockProposerHeadResponse;

export const zFctBlockProposerHeadServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    slot_start_date_time: z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctBlockProposerHeadServiceGetResponse = zGetFctBlockProposerHeadResponse;

export const zFctMevBidCountByBuilderServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      slot_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the bid is for (filter: eq)',
        })
      ),
      slot_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the bid is for (filter: ne)',
        })
      ),
      slot_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the bid is for (filter: lt)',
        })
      ),
      slot_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the bid is for (filter: lte)',
        })
      ),
      slot_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the bid is for (filter: gt)',
        })
      ),
      slot_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the bid is for (filter: gte)',
        })
      ),
      slot_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the bid is for (filter: between_min)',
        })
      ),
      slot_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the bid is for (filter: between_max_value)',
        })
      ),
      slot_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The start time for the slot that the bid is for (filter: in_values) (comma-separated list)',
          })
      ),
      slot_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The start time for the slot that the bid is for (filter: not_in_values) (comma-separated list)',
          })
      ),
      builder_pubkey_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The relay that the bid was fetched from (filter: eq)',
        })
      ),
      builder_pubkey_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The relay that the bid was fetched from (filter: ne)',
        })
      ),
      builder_pubkey_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The relay that the bid was fetched from (filter: contains)',
        })
      ),
      builder_pubkey_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The relay that the bid was fetched from (filter: starts_with)',
        })
      ),
      builder_pubkey_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The relay that the bid was fetched from (filter: ends_with)',
        })
      ),
      builder_pubkey_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The relay that the bid was fetched from (filter: like)',
        })
      ),
      builder_pubkey_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The relay that the bid was fetched from (filter: not_like)',
        })
      ),
      builder_pubkey_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The relay that the bid was fetched from (filter: in_values) (comma-separated list)',
          })
      ),
      builder_pubkey_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The relay that the bid was fetched from (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      slot_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block bid (filter: eq)',
        })
      ),
      slot_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block bid (filter: ne)',
        })
      ),
      slot_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block bid (filter: lt)',
        })
      ),
      slot_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block bid (filter: lte)',
        })
      ),
      slot_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block bid (filter: gt)',
        })
      ),
      slot_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block bid (filter: gte)',
        })
      ),
      slot_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block bid (filter: between_min)',
        })
      ),
      slot_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block bid (filter: between_max_value)',
        })
      ),
      slot_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Slot number within the block bid (filter: in_values) (comma-separated list)',
          })
      ),
      slot_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Slot number within the block bid (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the bid is for (filter: eq)',
        })
      ),
      epoch_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the bid is for (filter: ne)',
        })
      ),
      epoch_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the bid is for (filter: lt)',
        })
      ),
      epoch_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the bid is for (filter: lte)',
        })
      ),
      epoch_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the bid is for (filter: gt)',
        })
      ),
      epoch_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the bid is for (filter: gte)',
        })
      ),
      epoch_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the bid is for (filter: between_min)',
        })
      ),
      epoch_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the bid is for (filter: between_max_value)',
        })
      ),
      epoch_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Epoch number derived from the slot that the bid is for (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Epoch number derived from the slot that the bid is for (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the bid is for (filter: eq)',
        })
      ),
      epoch_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the bid is for (filter: ne)',
        })
      ),
      epoch_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the bid is for (filter: lt)',
        })
      ),
      epoch_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the bid is for (filter: lte)',
        })
      ),
      epoch_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the bid is for (filter: gt)',
        })
      ),
      epoch_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the bid is for (filter: gte)',
        })
      ),
      epoch_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the bid is for (filter: between_min)',
        })
      ),
      epoch_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the bid is for (filter: between_max_value)',
        })
      ),
      epoch_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The start time for the epoch that the bid is for (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The start time for the epoch that the bid is for (filter: not_in_values) (comma-separated list)',
          })
      ),
      bid_total_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total number of bids from the builder (filter: eq)',
        })
      ),
      bid_total_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total number of bids from the builder (filter: ne)',
        })
      ),
      bid_total_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total number of bids from the builder (filter: lt)',
        })
      ),
      bid_total_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total number of bids from the builder (filter: lte)',
        })
      ),
      bid_total_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total number of bids from the builder (filter: gt)',
        })
      ),
      bid_total_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total number of bids from the builder (filter: gte)',
        })
      ),
      bid_total_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total number of bids from the builder (filter: between_min)',
        })
      ),
      bid_total_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total number of bids from the builder (filter: between_max_value)',
        })
      ),
      bid_total_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The total number of bids from the builder (filter: in_values) (comma-separated list)',
          })
      ),
      bid_total_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The total number of bids from the builder (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_mev_bid_count_by_builder to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctMevBidCountByBuilder` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctMevBidCountByBuilderServiceListResponse = zListFctMevBidCountByBuilderResponse;

export const zFctMevBidCountByBuilderServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    slot_start_date_time: z.int().register(z.globalRegistry, {
      description: 'The start time for the slot that the bid is for',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctMevBidCountByBuilderServiceGetResponse = zGetFctMevBidCountByBuilderResponse;

export const zFctMevBidCountByRelayServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      slot_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the bid is for (filter: eq)',
        })
      ),
      slot_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the bid is for (filter: ne)',
        })
      ),
      slot_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the bid is for (filter: lt)',
        })
      ),
      slot_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the bid is for (filter: lte)',
        })
      ),
      slot_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the bid is for (filter: gt)',
        })
      ),
      slot_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the bid is for (filter: gte)',
        })
      ),
      slot_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the bid is for (filter: between_min)',
        })
      ),
      slot_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the bid is for (filter: between_max_value)',
        })
      ),
      slot_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The start time for the slot that the bid is for (filter: in_values) (comma-separated list)',
          })
      ),
      slot_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The start time for the slot that the bid is for (filter: not_in_values) (comma-separated list)',
          })
      ),
      relay_name_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The relay that the bid was fetched from (filter: eq)',
        })
      ),
      relay_name_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The relay that the bid was fetched from (filter: ne)',
        })
      ),
      relay_name_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The relay that the bid was fetched from (filter: contains)',
        })
      ),
      relay_name_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The relay that the bid was fetched from (filter: starts_with)',
        })
      ),
      relay_name_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The relay that the bid was fetched from (filter: ends_with)',
        })
      ),
      relay_name_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The relay that the bid was fetched from (filter: like)',
        })
      ),
      relay_name_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The relay that the bid was fetched from (filter: not_like)',
        })
      ),
      relay_name_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The relay that the bid was fetched from (filter: in_values) (comma-separated list)',
          })
      ),
      relay_name_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The relay that the bid was fetched from (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      slot_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block bid (filter: eq)',
        })
      ),
      slot_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block bid (filter: ne)',
        })
      ),
      slot_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block bid (filter: lt)',
        })
      ),
      slot_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block bid (filter: lte)',
        })
      ),
      slot_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block bid (filter: gt)',
        })
      ),
      slot_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block bid (filter: gte)',
        })
      ),
      slot_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block bid (filter: between_min)',
        })
      ),
      slot_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block bid (filter: between_max_value)',
        })
      ),
      slot_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Slot number within the block bid (filter: in_values) (comma-separated list)',
          })
      ),
      slot_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Slot number within the block bid (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the bid is for (filter: eq)',
        })
      ),
      epoch_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the bid is for (filter: ne)',
        })
      ),
      epoch_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the bid is for (filter: lt)',
        })
      ),
      epoch_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the bid is for (filter: lte)',
        })
      ),
      epoch_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the bid is for (filter: gt)',
        })
      ),
      epoch_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the bid is for (filter: gte)',
        })
      ),
      epoch_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the bid is for (filter: between_min)',
        })
      ),
      epoch_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the bid is for (filter: between_max_value)',
        })
      ),
      epoch_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Epoch number derived from the slot that the bid is for (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Epoch number derived from the slot that the bid is for (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the bid is for (filter: eq)',
        })
      ),
      epoch_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the bid is for (filter: ne)',
        })
      ),
      epoch_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the bid is for (filter: lt)',
        })
      ),
      epoch_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the bid is for (filter: lte)',
        })
      ),
      epoch_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the bid is for (filter: gt)',
        })
      ),
      epoch_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the bid is for (filter: gte)',
        })
      ),
      epoch_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the bid is for (filter: between_min)',
        })
      ),
      epoch_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the bid is for (filter: between_max_value)',
        })
      ),
      epoch_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The start time for the epoch that the bid is for (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The start time for the epoch that the bid is for (filter: not_in_values) (comma-separated list)',
          })
      ),
      bid_total_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total number of bids for the relay (filter: eq)',
        })
      ),
      bid_total_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total number of bids for the relay (filter: ne)',
        })
      ),
      bid_total_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total number of bids for the relay (filter: lt)',
        })
      ),
      bid_total_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total number of bids for the relay (filter: lte)',
        })
      ),
      bid_total_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total number of bids for the relay (filter: gt)',
        })
      ),
      bid_total_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total number of bids for the relay (filter: gte)',
        })
      ),
      bid_total_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total number of bids for the relay (filter: between_min)',
        })
      ),
      bid_total_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total number of bids for the relay (filter: between_max_value)',
        })
      ),
      bid_total_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The total number of bids for the relay (filter: in_values) (comma-separated list)',
          })
      ),
      bid_total_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The total number of bids for the relay (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_mev_bid_count_by_relay to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctMevBidCountByRelay` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctMevBidCountByRelayServiceListResponse = zListFctMevBidCountByRelayResponse;

export const zFctMevBidCountByRelayServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    slot_start_date_time: z.int().register(z.globalRegistry, {
      description: 'The start time for the slot that the bid is for',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctMevBidCountByRelayServiceGetResponse = zGetFctMevBidCountByRelayResponse;

export const zFctMevBidHighestValueByBuilderChunked50MsServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      slot_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the bid is for (filter: eq)',
        })
      ),
      slot_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the bid is for (filter: ne)',
        })
      ),
      slot_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the bid is for (filter: lt)',
        })
      ),
      slot_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the bid is for (filter: lte)',
        })
      ),
      slot_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the bid is for (filter: gt)',
        })
      ),
      slot_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the bid is for (filter: gte)',
        })
      ),
      slot_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the bid is for (filter: between_min)',
        })
      ),
      slot_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the slot that the bid is for (filter: between_max_value)',
        })
      ),
      slot_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The start time for the slot that the bid is for (filter: in_values) (comma-separated list)',
          })
      ),
      slot_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The start time for the slot that the bid is for (filter: not_in_values) (comma-separated list)',
          })
      ),
      chunk_slot_start_diff_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The difference between the chunk start time and slot_start_date_time. "1500" would mean the earliest bid for this block_hash was between 1500ms and 1550ms into the slot. Negative values indicate bids received before slot start (filter: eq)',
        })
      ),
      chunk_slot_start_diff_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The difference between the chunk start time and slot_start_date_time. "1500" would mean the earliest bid for this block_hash was between 1500ms and 1550ms into the slot. Negative values indicate bids received before slot start (filter: ne)',
        })
      ),
      chunk_slot_start_diff_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The difference between the chunk start time and slot_start_date_time. "1500" would mean the earliest bid for this block_hash was between 1500ms and 1550ms into the slot. Negative values indicate bids received before slot start (filter: lt)',
        })
      ),
      chunk_slot_start_diff_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The difference between the chunk start time and slot_start_date_time. "1500" would mean the earliest bid for this block_hash was between 1500ms and 1550ms into the slot. Negative values indicate bids received before slot start (filter: lte)',
        })
      ),
      chunk_slot_start_diff_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The difference between the chunk start time and slot_start_date_time. "1500" would mean the earliest bid for this block_hash was between 1500ms and 1550ms into the slot. Negative values indicate bids received before slot start (filter: gt)',
        })
      ),
      chunk_slot_start_diff_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The difference between the chunk start time and slot_start_date_time. "1500" would mean the earliest bid for this block_hash was between 1500ms and 1550ms into the slot. Negative values indicate bids received before slot start (filter: gte)',
        })
      ),
      chunk_slot_start_diff_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The difference between the chunk start time and slot_start_date_time. "1500" would mean the earliest bid for this block_hash was between 1500ms and 1550ms into the slot. Negative values indicate bids received before slot start (filter: between_min)',
        })
      ),
      chunk_slot_start_diff_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The difference between the chunk start time and slot_start_date_time. "1500" would mean the earliest bid for this block_hash was between 1500ms and 1550ms into the slot. Negative values indicate bids received before slot start (filter: between_max_value)',
        })
      ),
      chunk_slot_start_diff_in_values: z.optional(
        z
          .string()
          .regex(/^-?\d+(,-?\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The difference between the chunk start time and slot_start_date_time. "1500" would mean the earliest bid for this block_hash was between 1500ms and 1550ms into the slot. Negative values indicate bids received before slot start (filter: in_values) (comma-separated list)',
          })
      ),
      chunk_slot_start_diff_not_in_values: z.optional(
        z
          .string()
          .regex(/^-?\d+(,-?\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The difference between the chunk start time and slot_start_date_time. "1500" would mean the earliest bid for this block_hash was between 1500ms and 1550ms into the slot. Negative values indicate bids received before slot start (filter: not_in_values) (comma-separated list)',
          })
      ),
      builder_pubkey_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The builder pubkey of the bid (filter: eq)',
        })
      ),
      builder_pubkey_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The builder pubkey of the bid (filter: ne)',
        })
      ),
      builder_pubkey_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The builder pubkey of the bid (filter: contains)',
        })
      ),
      builder_pubkey_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The builder pubkey of the bid (filter: starts_with)',
        })
      ),
      builder_pubkey_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The builder pubkey of the bid (filter: ends_with)',
        })
      ),
      builder_pubkey_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The builder pubkey of the bid (filter: like)',
        })
      ),
      builder_pubkey_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The builder pubkey of the bid (filter: not_like)',
        })
      ),
      builder_pubkey_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The builder pubkey of the bid (filter: in_values) (comma-separated list)',
          })
      ),
      builder_pubkey_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The builder pubkey of the bid (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      slot_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block bid (filter: eq)',
        })
      ),
      slot_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block bid (filter: ne)',
        })
      ),
      slot_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block bid (filter: lt)',
        })
      ),
      slot_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block bid (filter: lte)',
        })
      ),
      slot_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block bid (filter: gt)',
        })
      ),
      slot_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block bid (filter: gte)',
        })
      ),
      slot_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block bid (filter: between_min)',
        })
      ),
      slot_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Slot number within the block bid (filter: between_max_value)',
        })
      ),
      slot_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Slot number within the block bid (filter: in_values) (comma-separated list)',
          })
      ),
      slot_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Slot number within the block bid (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the bid is for (filter: eq)',
        })
      ),
      epoch_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the bid is for (filter: ne)',
        })
      ),
      epoch_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the bid is for (filter: lt)',
        })
      ),
      epoch_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the bid is for (filter: lte)',
        })
      ),
      epoch_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the bid is for (filter: gt)',
        })
      ),
      epoch_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the bid is for (filter: gte)',
        })
      ),
      epoch_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the bid is for (filter: between_min)',
        })
      ),
      epoch_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Epoch number derived from the slot that the bid is for (filter: between_max_value)',
        })
      ),
      epoch_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Epoch number derived from the slot that the bid is for (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'Epoch number derived from the slot that the bid is for (filter: not_in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the bid is for (filter: eq)',
        })
      ),
      epoch_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the bid is for (filter: ne)',
        })
      ),
      epoch_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the bid is for (filter: lt)',
        })
      ),
      epoch_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the bid is for (filter: lte)',
        })
      ),
      epoch_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the bid is for (filter: gt)',
        })
      ),
      epoch_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the bid is for (filter: gte)',
        })
      ),
      epoch_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the bid is for (filter: between_min)',
        })
      ),
      epoch_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The start time for the epoch that the bid is for (filter: between_max_value)',
        })
      ),
      epoch_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The start time for the epoch that the bid is for (filter: in_values) (comma-separated list)',
          })
      ),
      epoch_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The start time for the epoch that the bid is for (filter: not_in_values) (comma-separated list)',
          })
      ),
      earliest_bid_date_time_eq: z.optional(
        z.coerce.bigint().register(z.globalRegistry, {
          description: 'The timestamp of the earliest bid for this block_hash from this builder (filter: eq)',
        })
      ),
      earliest_bid_date_time_ne: z.optional(
        z.coerce.bigint().register(z.globalRegistry, {
          description: 'The timestamp of the earliest bid for this block_hash from this builder (filter: ne)',
        })
      ),
      earliest_bid_date_time_lt: z.optional(
        z.coerce.bigint().register(z.globalRegistry, {
          description: 'The timestamp of the earliest bid for this block_hash from this builder (filter: lt)',
        })
      ),
      earliest_bid_date_time_lte: z.optional(
        z.coerce.bigint().register(z.globalRegistry, {
          description: 'The timestamp of the earliest bid for this block_hash from this builder (filter: lte)',
        })
      ),
      earliest_bid_date_time_gt: z.optional(
        z.coerce.bigint().register(z.globalRegistry, {
          description: 'The timestamp of the earliest bid for this block_hash from this builder (filter: gt)',
        })
      ),
      earliest_bid_date_time_gte: z.optional(
        z.coerce.bigint().register(z.globalRegistry, {
          description: 'The timestamp of the earliest bid for this block_hash from this builder (filter: gte)',
        })
      ),
      earliest_bid_date_time_between_min: z.optional(
        z.coerce.bigint().register(z.globalRegistry, {
          description: 'The timestamp of the earliest bid for this block_hash from this builder (filter: between_min)',
        })
      ),
      earliest_bid_date_time_between_max_value: z.optional(
        z.coerce.bigint().register(z.globalRegistry, {
          description:
            'The timestamp of the earliest bid for this block_hash from this builder (filter: between_max_value)',
        })
      ),
      earliest_bid_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^-?\d+(,-?\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The timestamp of the earliest bid for this block_hash from this builder (filter: in_values) (comma-separated list)',
          })
      ),
      earliest_bid_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^-?\d+(,-?\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The timestamp of the earliest bid for this block_hash from this builder (filter: not_in_values) (comma-separated list)',
          })
      ),
      relay_names: z.optional(
        z.array(z.string()).register(z.globalRegistry, {
          description: 'Filter by relay_names - The relay that the bid was fetched from (optional)',
        })
      ),
      block_hash_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The execution block hash of the bid (filter: eq)',
        })
      ),
      block_hash_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The execution block hash of the bid (filter: ne)',
        })
      ),
      block_hash_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The execution block hash of the bid (filter: contains)',
        })
      ),
      block_hash_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The execution block hash of the bid (filter: starts_with)',
        })
      ),
      block_hash_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The execution block hash of the bid (filter: ends_with)',
        })
      ),
      block_hash_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The execution block hash of the bid (filter: like)',
        })
      ),
      block_hash_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The execution block hash of the bid (filter: not_like)',
        })
      ),
      block_hash_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The execution block hash of the bid (filter: in_values) (comma-separated list)',
          })
      ),
      block_hash_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The execution block hash of the bid (filter: not_in_values) (comma-separated list)',
          })
      ),
      value_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The transaction value in wei (filter: eq)',
        })
      ),
      value_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The transaction value in wei (filter: ne)',
        })
      ),
      value_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The transaction value in wei (filter: contains)',
        })
      ),
      value_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The transaction value in wei (filter: starts_with)',
        })
      ),
      value_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The transaction value in wei (filter: ends_with)',
        })
      ),
      value_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The transaction value in wei (filter: like)',
        })
      ),
      value_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The transaction value in wei (filter: not_like)',
        })
      ),
      value_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The transaction value in wei (filter: in_values) (comma-separated list)',
          })
      ),
      value_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The transaction value in wei (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_mev_bid_highest_value_by_builder_chunked_50ms to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctMevBidHighestValueByBuilderChunked50ms` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctMevBidHighestValueByBuilderChunked50MsServiceListResponse =
  zListFctMevBidHighestValueByBuilderChunked50MsResponse;

export const zFctMevBidHighestValueByBuilderChunked50MsServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    slot_start_date_time: z.int().register(z.globalRegistry, {
      description: 'The start time for the slot that the bid is for',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctMevBidHighestValueByBuilderChunked50MsServiceGetResponse =
  zGetFctMevBidHighestValueByBuilderChunked50MsResponse;

export const zFctNodeActiveLast24hServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      meta_client_name_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client (filter: eq)',
        })
      ),
      meta_client_name_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client (filter: ne)',
        })
      ),
      meta_client_name_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client (filter: contains)',
        })
      ),
      meta_client_name_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client (filter: starts_with)',
        })
      ),
      meta_client_name_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client (filter: ends_with)',
        })
      ),
      meta_client_name_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client (filter: like)',
        })
      ),
      meta_client_name_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client (filter: not_like)',
        })
      ),
      meta_client_name_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Name of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_name_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Name of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      last_seen_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the node was last seen (filter: eq)',
        })
      ),
      last_seen_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the node was last seen (filter: ne)',
        })
      ),
      last_seen_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the node was last seen (filter: lt)',
        })
      ),
      last_seen_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the node was last seen (filter: lte)',
        })
      ),
      last_seen_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the node was last seen (filter: gt)',
        })
      ),
      last_seen_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the node was last seen (filter: gte)',
        })
      ),
      last_seen_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the node was last seen (filter: between_min)',
        })
      ),
      last_seen_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the node was last seen (filter: between_max_value)',
        })
      ),
      last_seen_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the node was last seen (filter: in_values) (comma-separated list)',
          })
      ),
      last_seen_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the node was last seen (filter: not_in_values) (comma-separated list)',
          })
      ),
      username_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Username of the node (filter: eq)',
        })
      ),
      username_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Username of the node (filter: ne)',
        })
      ),
      username_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Username of the node (filter: contains)',
        })
      ),
      username_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Username of the node (filter: starts_with)',
        })
      ),
      username_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Username of the node (filter: ends_with)',
        })
      ),
      username_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Username of the node (filter: like)',
        })
      ),
      username_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Username of the node (filter: not_like)',
        })
      ),
      username_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Username of the node (filter: in_values) (comma-separated list)',
          })
      ),
      username_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Username of the node (filter: not_in_values) (comma-separated list)',
          })
      ),
      node_id_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'ID of the node (filter: eq)',
        })
      ),
      node_id_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'ID of the node (filter: ne)',
        })
      ),
      node_id_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'ID of the node (filter: contains)',
        })
      ),
      node_id_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'ID of the node (filter: starts_with)',
        })
      ),
      node_id_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'ID of the node (filter: ends_with)',
        })
      ),
      node_id_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'ID of the node (filter: like)',
        })
      ),
      node_id_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'ID of the node (filter: not_like)',
        })
      ),
      node_id_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'ID of the node (filter: in_values) (comma-separated list)',
          })
      ),
      node_id_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'ID of the node (filter: not_in_values) (comma-separated list)',
          })
      ),
      classification_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: eq)',
        })
      ),
      classification_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: ne)',
        })
      ),
      classification_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: contains)',
        })
      ),
      classification_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: starts_with)',
        })
      ),
      classification_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: ends_with)',
        })
      ),
      classification_like: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: like)',
        })
      ),
      classification_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: not_like)',
        })
      ),
      classification_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: in_values) (comma-separated list)',
          })
      ),
      classification_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'Classification of the node, e.g. "individual", "corporate", "internal" (aka ethPandaOps) or "unclassified" (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_version_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client (filter: eq)',
        })
      ),
      meta_client_version_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client (filter: ne)',
        })
      ),
      meta_client_version_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client (filter: contains)',
        })
      ),
      meta_client_version_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client (filter: starts_with)',
        })
      ),
      meta_client_version_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client (filter: ends_with)',
        })
      ),
      meta_client_version_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client (filter: like)',
        })
      ),
      meta_client_version_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client (filter: not_like)',
        })
      ),
      meta_client_version_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Version of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_version_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Version of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_implementation_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client (filter: eq)',
        })
      ),
      meta_client_implementation_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client (filter: ne)',
        })
      ),
      meta_client_implementation_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client (filter: contains)',
        })
      ),
      meta_client_implementation_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client (filter: starts_with)',
        })
      ),
      meta_client_implementation_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client (filter: ends_with)',
        })
      ),
      meta_client_implementation_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client (filter: like)',
        })
      ),
      meta_client_implementation_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client (filter: not_like)',
        })
      ),
      meta_client_implementation_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Implementation of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_implementation_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Implementation of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_city_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client (filter: eq)',
        })
      ),
      meta_client_geo_city_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client (filter: ne)',
        })
      ),
      meta_client_geo_city_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client (filter: contains)',
        })
      ),
      meta_client_geo_city_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client (filter: starts_with)',
        })
      ),
      meta_client_geo_city_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client (filter: ends_with)',
        })
      ),
      meta_client_geo_city_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client (filter: like)',
        })
      ),
      meta_client_geo_city_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client (filter: not_like)',
        })
      ),
      meta_client_geo_city_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'City of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_city_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'City of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_country_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client (filter: eq)',
        })
      ),
      meta_client_geo_country_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client (filter: ne)',
        })
      ),
      meta_client_geo_country_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client (filter: contains)',
        })
      ),
      meta_client_geo_country_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client (filter: starts_with)',
        })
      ),
      meta_client_geo_country_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client (filter: ends_with)',
        })
      ),
      meta_client_geo_country_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client (filter: like)',
        })
      ),
      meta_client_geo_country_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client (filter: not_like)',
        })
      ),
      meta_client_geo_country_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Country of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_country_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Country of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_country_code_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client (filter: eq)',
        })
      ),
      meta_client_geo_country_code_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client (filter: ne)',
        })
      ),
      meta_client_geo_country_code_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client (filter: contains)',
        })
      ),
      meta_client_geo_country_code_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client (filter: starts_with)',
        })
      ),
      meta_client_geo_country_code_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client (filter: ends_with)',
        })
      ),
      meta_client_geo_country_code_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client (filter: like)',
        })
      ),
      meta_client_geo_country_code_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client (filter: not_like)',
        })
      ),
      meta_client_geo_country_code_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Country code of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_country_code_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Country code of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_continent_code_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Continent code of the client (filter: eq)',
        })
      ),
      meta_client_geo_continent_code_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Continent code of the client (filter: ne)',
        })
      ),
      meta_client_geo_continent_code_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Continent code of the client (filter: contains)',
        })
      ),
      meta_client_geo_continent_code_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Continent code of the client (filter: starts_with)',
        })
      ),
      meta_client_geo_continent_code_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Continent code of the client (filter: ends_with)',
        })
      ),
      meta_client_geo_continent_code_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Continent code of the client (filter: like)',
        })
      ),
      meta_client_geo_continent_code_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Continent code of the client (filter: not_like)',
        })
      ),
      meta_client_geo_continent_code_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Continent code of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_continent_code_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Continent code of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_longitude_value: z.optional(
        z.number().register(z.globalRegistry, {
          description: 'Filter meta_client_geo_longitude using value',
        })
      ),
      meta_client_geo_latitude_value: z.optional(
        z.number().register(z.globalRegistry, {
          description: 'Filter meta_client_geo_latitude using value',
        })
      ),
      meta_client_geo_autonomous_system_number_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Autonomous system number of the client (filter: eq)',
        })
      ),
      meta_client_geo_autonomous_system_number_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Autonomous system number of the client (filter: ne)',
        })
      ),
      meta_client_geo_autonomous_system_number_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Autonomous system number of the client (filter: lt)',
        })
      ),
      meta_client_geo_autonomous_system_number_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Autonomous system number of the client (filter: lte)',
        })
      ),
      meta_client_geo_autonomous_system_number_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Autonomous system number of the client (filter: gt)',
        })
      ),
      meta_client_geo_autonomous_system_number_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Autonomous system number of the client (filter: gte)',
        })
      ),
      meta_client_geo_autonomous_system_number_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Autonomous system number of the client (filter: between_min)',
        })
      ),
      meta_client_geo_autonomous_system_number_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Autonomous system number of the client (filter: between_max_value)',
        })
      ),
      meta_client_geo_autonomous_system_number_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Autonomous system number of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_autonomous_system_number_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Autonomous system number of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_autonomous_system_organization_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Autonomous system organization of the client (filter: eq)',
        })
      ),
      meta_client_geo_autonomous_system_organization_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Autonomous system organization of the client (filter: ne)',
        })
      ),
      meta_client_geo_autonomous_system_organization_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Autonomous system organization of the client (filter: contains)',
        })
      ),
      meta_client_geo_autonomous_system_organization_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Autonomous system organization of the client (filter: starts_with)',
        })
      ),
      meta_client_geo_autonomous_system_organization_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Autonomous system organization of the client (filter: ends_with)',
        })
      ),
      meta_client_geo_autonomous_system_organization_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Autonomous system organization of the client (filter: like)',
        })
      ),
      meta_client_geo_autonomous_system_organization_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Autonomous system organization of the client (filter: not_like)',
        })
      ),
      meta_client_geo_autonomous_system_organization_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Autonomous system organization of the client (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_autonomous_system_organization_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Autonomous system organization of the client (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_consensus_version_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client version (filter: eq)',
        })
      ),
      meta_consensus_version_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client version (filter: ne)',
        })
      ),
      meta_consensus_version_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client version (filter: contains)',
        })
      ),
      meta_consensus_version_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client version (filter: starts_with)',
        })
      ),
      meta_consensus_version_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client version (filter: ends_with)',
        })
      ),
      meta_consensus_version_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client version (filter: like)',
        })
      ),
      meta_consensus_version_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client version (filter: not_like)',
        })
      ),
      meta_consensus_version_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Ethereum consensus client version (filter: in_values) (comma-separated list)',
          })
      ),
      meta_consensus_version_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Ethereum consensus client version (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_consensus_implementation_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client implementation (filter: eq)',
        })
      ),
      meta_consensus_implementation_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client implementation (filter: ne)',
        })
      ),
      meta_consensus_implementation_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client implementation (filter: contains)',
        })
      ),
      meta_consensus_implementation_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client implementation (filter: starts_with)',
        })
      ),
      meta_consensus_implementation_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client implementation (filter: ends_with)',
        })
      ),
      meta_consensus_implementation_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client implementation (filter: like)',
        })
      ),
      meta_consensus_implementation_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Ethereum consensus client implementation (filter: not_like)',
        })
      ),
      meta_consensus_implementation_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Ethereum consensus client implementation (filter: in_values) (comma-separated list)',
          })
      ),
      meta_consensus_implementation_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Ethereum consensus client implementation (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_node_active_last_24h to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctNodeActiveLast24h` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctNodeActiveLast24hServiceListResponse = zListFctNodeActiveLast24hResponse;

export const zFctNodeActiveLast24hServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    meta_client_name: z.string().register(z.globalRegistry, {
      description: 'Name of the client',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctNodeActiveLast24hServiceGetResponse = zGetFctNodeActiveLast24hResponse;

export const zFctPreparedBlockServiceListData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      slot_start_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: eq)',
        })
      ),
      slot_start_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: ne)',
        })
      ),
      slot_start_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lt)',
        })
      ),
      slot_start_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: lte)',
        })
      ),
      slot_start_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gt)',
        })
      ),
      slot_start_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: gte)',
        })
      ),
      slot_start_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_min)',
        })
      ),
      slot_start_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the slot started (filter: between_max_value)',
        })
      ),
      slot_start_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: in_values) (comma-separated list)',
          })
      ),
      slot_start_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the slot started (filter: not_in_values) (comma-separated list)',
          })
      ),
      slot_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number from beacon block (filter: eq)',
        })
      ),
      slot_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number from beacon block (filter: ne)',
        })
      ),
      slot_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number from beacon block (filter: lt)',
        })
      ),
      slot_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number from beacon block (filter: lte)',
        })
      ),
      slot_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number from beacon block (filter: gt)',
        })
      ),
      slot_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number from beacon block (filter: gte)',
        })
      ),
      slot_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number from beacon block (filter: between_min)',
        })
      ),
      slot_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The slot number from beacon block (filter: between_max_value)',
        })
      ),
      slot_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number from beacon block (filter: in_values) (comma-separated list)',
          })
      ),
      slot_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The slot number from beacon block (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_name_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client that generated the event (filter: eq)',
        })
      ),
      meta_client_name_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client that generated the event (filter: ne)',
        })
      ),
      meta_client_name_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client that generated the event (filter: contains)',
        })
      ),
      meta_client_name_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client that generated the event (filter: starts_with)',
        })
      ),
      meta_client_name_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client that generated the event (filter: ends_with)',
        })
      ),
      meta_client_name_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client that generated the event (filter: like)',
        })
      ),
      meta_client_name_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Name of the client that generated the event (filter: not_like)',
        })
      ),
      meta_client_name_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Name of the client that generated the event (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_name_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Name of the client that generated the event (filter: not_in_values) (comma-separated list)',
          })
      ),
      event_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the event was received (filter: eq)',
        })
      ),
      event_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the event was received (filter: ne)',
        })
      ),
      event_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the event was received (filter: lt)',
        })
      ),
      event_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the event was received (filter: lte)',
        })
      ),
      event_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the event was received (filter: gt)',
        })
      ),
      event_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the event was received (filter: gte)',
        })
      ),
      event_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the event was received (filter: between_min)',
        })
      ),
      event_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The wall clock time when the event was received (filter: between_max_value)',
        })
      ),
      event_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The wall clock time when the event was received (filter: in_values) (comma-separated list)',
          })
      ),
      event_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The wall clock time when the event was received (filter: not_in_values) (comma-separated list)',
          })
      ),
      updated_date_time_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: eq)',
        })
      ),
      updated_date_time_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: ne)',
        })
      ),
      updated_date_time_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lt)',
        })
      ),
      updated_date_time_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: lte)',
        })
      ),
      updated_date_time_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gt)',
        })
      ),
      updated_date_time_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: gte)',
        })
      ),
      updated_date_time_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_min)',
        })
      ),
      updated_date_time_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Timestamp when the record was last updated (filter: between_max_value)',
        })
      ),
      updated_date_time_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: in_values) (comma-separated list)',
          })
      ),
      updated_date_time_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Timestamp when the record was last updated (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_version_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client that generated the event (filter: eq)',
        })
      ),
      meta_client_version_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client that generated the event (filter: ne)',
        })
      ),
      meta_client_version_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client that generated the event (filter: contains)',
        })
      ),
      meta_client_version_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client that generated the event (filter: starts_with)',
        })
      ),
      meta_client_version_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client that generated the event (filter: ends_with)',
        })
      ),
      meta_client_version_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client that generated the event (filter: like)',
        })
      ),
      meta_client_version_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Version of the client that generated the event (filter: not_like)',
        })
      ),
      meta_client_version_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Version of the client that generated the event (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_version_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'Version of the client that generated the event (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_implementation_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client that generated the event (filter: eq)',
        })
      ),
      meta_client_implementation_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client that generated the event (filter: ne)',
        })
      ),
      meta_client_implementation_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client that generated the event (filter: contains)',
        })
      ),
      meta_client_implementation_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client that generated the event (filter: starts_with)',
        })
      ),
      meta_client_implementation_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client that generated the event (filter: ends_with)',
        })
      ),
      meta_client_implementation_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client that generated the event (filter: like)',
        })
      ),
      meta_client_implementation_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Implementation of the client that generated the event (filter: not_like)',
        })
      ),
      meta_client_implementation_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'Implementation of the client that generated the event (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_implementation_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'Implementation of the client that generated the event (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_consensus_implementation_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Consensus implementation of the validator (filter: eq)',
        })
      ),
      meta_consensus_implementation_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Consensus implementation of the validator (filter: ne)',
        })
      ),
      meta_consensus_implementation_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Consensus implementation of the validator (filter: contains)',
        })
      ),
      meta_consensus_implementation_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Consensus implementation of the validator (filter: starts_with)',
        })
      ),
      meta_consensus_implementation_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Consensus implementation of the validator (filter: ends_with)',
        })
      ),
      meta_consensus_implementation_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Consensus implementation of the validator (filter: like)',
        })
      ),
      meta_consensus_implementation_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Consensus implementation of the validator (filter: not_like)',
        })
      ),
      meta_consensus_implementation_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Consensus implementation of the validator (filter: in_values) (comma-separated list)',
          })
      ),
      meta_consensus_implementation_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Consensus implementation of the validator (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_consensus_version_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Consensus version of the validator (filter: eq)',
        })
      ),
      meta_consensus_version_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Consensus version of the validator (filter: ne)',
        })
      ),
      meta_consensus_version_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Consensus version of the validator (filter: contains)',
        })
      ),
      meta_consensus_version_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Consensus version of the validator (filter: starts_with)',
        })
      ),
      meta_consensus_version_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Consensus version of the validator (filter: ends_with)',
        })
      ),
      meta_consensus_version_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Consensus version of the validator (filter: like)',
        })
      ),
      meta_consensus_version_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Consensus version of the validator (filter: not_like)',
        })
      ),
      meta_consensus_version_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Consensus version of the validator (filter: in_values) (comma-separated list)',
          })
      ),
      meta_consensus_version_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Consensus version of the validator (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_city_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client that generated the event (filter: eq)',
        })
      ),
      meta_client_geo_city_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client that generated the event (filter: ne)',
        })
      ),
      meta_client_geo_city_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client that generated the event (filter: contains)',
        })
      ),
      meta_client_geo_city_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client that generated the event (filter: starts_with)',
        })
      ),
      meta_client_geo_city_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client that generated the event (filter: ends_with)',
        })
      ),
      meta_client_geo_city_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client that generated the event (filter: like)',
        })
      ),
      meta_client_geo_city_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'City of the client that generated the event (filter: not_like)',
        })
      ),
      meta_client_geo_city_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'City of the client that generated the event (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_city_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'City of the client that generated the event (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_country_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client that generated the event (filter: eq)',
        })
      ),
      meta_client_geo_country_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client that generated the event (filter: ne)',
        })
      ),
      meta_client_geo_country_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client that generated the event (filter: contains)',
        })
      ),
      meta_client_geo_country_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client that generated the event (filter: starts_with)',
        })
      ),
      meta_client_geo_country_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client that generated the event (filter: ends_with)',
        })
      ),
      meta_client_geo_country_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client that generated the event (filter: like)',
        })
      ),
      meta_client_geo_country_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country of the client that generated the event (filter: not_like)',
        })
      ),
      meta_client_geo_country_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'Country of the client that generated the event (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_country_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'Country of the client that generated the event (filter: not_in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_country_code_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client that generated the event (filter: eq)',
        })
      ),
      meta_client_geo_country_code_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client that generated the event (filter: ne)',
        })
      ),
      meta_client_geo_country_code_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client that generated the event (filter: contains)',
        })
      ),
      meta_client_geo_country_code_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client that generated the event (filter: starts_with)',
        })
      ),
      meta_client_geo_country_code_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client that generated the event (filter: ends_with)',
        })
      ),
      meta_client_geo_country_code_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client that generated the event (filter: like)',
        })
      ),
      meta_client_geo_country_code_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Country code of the client that generated the event (filter: not_like)',
        })
      ),
      meta_client_geo_country_code_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'Country code of the client that generated the event (filter: in_values) (comma-separated list)',
          })
      ),
      meta_client_geo_country_code_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description:
              'Country code of the client that generated the event (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_version_eq: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The version of the beacon block (filter: eq)',
        })
      ),
      block_version_ne: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The version of the beacon block (filter: ne)',
        })
      ),
      block_version_contains: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The version of the beacon block (filter: contains)',
        })
      ),
      block_version_starts_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The version of the beacon block (filter: starts_with)',
        })
      ),
      block_version_ends_with: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The version of the beacon block (filter: ends_with)',
        })
      ),
      block_version_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The version of the beacon block (filter: like)',
        })
      ),
      block_version_not_like: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'The version of the beacon block (filter: not_like)',
        })
      ),
      block_version_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The version of the beacon block (filter: in_values) (comma-separated list)',
          })
      ),
      block_version_not_in_values: z.optional(
        z
          .string()
          .regex(/^[^,]+(,[^,]+)*$/)
          .register(z.globalRegistry, {
            description: 'The version of the beacon block (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_total_bytes_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload (filter: eq)',
        })
      ),
      block_total_bytes_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload (filter: ne)',
        })
      ),
      block_total_bytes_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload (filter: lt)',
        })
      ),
      block_total_bytes_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload (filter: lte)',
        })
      ),
      block_total_bytes_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload (filter: gt)',
        })
      ),
      block_total_bytes_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload (filter: gte)',
        })
      ),
      block_total_bytes_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload (filter: between_min)',
        })
      ),
      block_total_bytes_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload (filter: between_max_value)',
        })
      ),
      block_total_bytes_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The total bytes of the beacon block payload (filter: in_values) (comma-separated list)',
          })
      ),
      block_total_bytes_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The total bytes of the beacon block payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      block_total_bytes_compressed_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload when compressed using snappy (filter: eq)',
        })
      ),
      block_total_bytes_compressed_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload when compressed using snappy (filter: ne)',
        })
      ),
      block_total_bytes_compressed_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload when compressed using snappy (filter: lt)',
        })
      ),
      block_total_bytes_compressed_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload when compressed using snappy (filter: lte)',
        })
      ),
      block_total_bytes_compressed_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload when compressed using snappy (filter: gt)',
        })
      ),
      block_total_bytes_compressed_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload when compressed using snappy (filter: gte)',
        })
      ),
      block_total_bytes_compressed_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The total bytes of the beacon block payload when compressed using snappy (filter: between_min)',
        })
      ),
      block_total_bytes_compressed_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The total bytes of the beacon block payload when compressed using snappy (filter: between_max_value)',
        })
      ),
      block_total_bytes_compressed_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The total bytes of the beacon block payload when compressed using snappy (filter: in_values) (comma-separated list)',
          })
      ),
      block_total_bytes_compressed_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The total bytes of the beacon block payload when compressed using snappy (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_value_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The value of the execution payload in wei (filter: eq)',
        })
      ),
      execution_payload_value_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The value of the execution payload in wei (filter: ne)',
        })
      ),
      execution_payload_value_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The value of the execution payload in wei (filter: lt)',
        })
      ),
      execution_payload_value_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The value of the execution payload in wei (filter: lte)',
        })
      ),
      execution_payload_value_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The value of the execution payload in wei (filter: gt)',
        })
      ),
      execution_payload_value_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The value of the execution payload in wei (filter: gte)',
        })
      ),
      execution_payload_value_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The value of the execution payload in wei (filter: between_min)',
        })
      ),
      execution_payload_value_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The value of the execution payload in wei (filter: between_max_value)',
        })
      ),
      execution_payload_value_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The value of the execution payload in wei (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_value_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The value of the execution payload in wei (filter: not_in_values) (comma-separated list)',
          })
      ),
      consensus_payload_value_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The value of the consensus payload in wei (filter: eq)',
        })
      ),
      consensus_payload_value_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The value of the consensus payload in wei (filter: ne)',
        })
      ),
      consensus_payload_value_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The value of the consensus payload in wei (filter: lt)',
        })
      ),
      consensus_payload_value_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The value of the consensus payload in wei (filter: lte)',
        })
      ),
      consensus_payload_value_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The value of the consensus payload in wei (filter: gt)',
        })
      ),
      consensus_payload_value_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The value of the consensus payload in wei (filter: gte)',
        })
      ),
      consensus_payload_value_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The value of the consensus payload in wei (filter: between_min)',
        })
      ),
      consensus_payload_value_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The value of the consensus payload in wei (filter: between_max_value)',
        })
      ),
      consensus_payload_value_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The value of the consensus payload in wei (filter: in_values) (comma-separated list)',
          })
      ),
      consensus_payload_value_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The value of the consensus payload in wei (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_block_number_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the execution payload (filter: eq)',
        })
      ),
      execution_payload_block_number_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the execution payload (filter: ne)',
        })
      ),
      execution_payload_block_number_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the execution payload (filter: lt)',
        })
      ),
      execution_payload_block_number_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the execution payload (filter: lte)',
        })
      ),
      execution_payload_block_number_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the execution payload (filter: gt)',
        })
      ),
      execution_payload_block_number_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the execution payload (filter: gte)',
        })
      ),
      execution_payload_block_number_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the execution payload (filter: between_min)',
        })
      ),
      execution_payload_block_number_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The block number of the execution payload (filter: between_max_value)',
        })
      ),
      execution_payload_block_number_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The block number of the execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_block_number_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The block number of the execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_gas_limit_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas limit for execution payload (filter: eq)',
        })
      ),
      execution_payload_gas_limit_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas limit for execution payload (filter: ne)',
        })
      ),
      execution_payload_gas_limit_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas limit for execution payload (filter: lt)',
        })
      ),
      execution_payload_gas_limit_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas limit for execution payload (filter: lte)',
        })
      ),
      execution_payload_gas_limit_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas limit for execution payload (filter: gt)',
        })
      ),
      execution_payload_gas_limit_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas limit for execution payload (filter: gte)',
        })
      ),
      execution_payload_gas_limit_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas limit for execution payload (filter: between_min)',
        })
      ),
      execution_payload_gas_limit_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas limit for execution payload (filter: between_max_value)',
        })
      ),
      execution_payload_gas_limit_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Gas limit for execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_gas_limit_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Gas limit for execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_gas_used_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for execution payload (filter: eq)',
        })
      ),
      execution_payload_gas_used_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for execution payload (filter: ne)',
        })
      ),
      execution_payload_gas_used_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for execution payload (filter: lt)',
        })
      ),
      execution_payload_gas_used_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for execution payload (filter: lte)',
        })
      ),
      execution_payload_gas_used_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for execution payload (filter: gt)',
        })
      ),
      execution_payload_gas_used_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for execution payload (filter: gte)',
        })
      ),
      execution_payload_gas_used_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for execution payload (filter: between_min)',
        })
      ),
      execution_payload_gas_used_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'Gas used for execution payload (filter: between_max_value)',
        })
      ),
      execution_payload_gas_used_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Gas used for execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_gas_used_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'Gas used for execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_transactions_count_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction count of the execution payload (filter: eq)',
        })
      ),
      execution_payload_transactions_count_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction count of the execution payload (filter: ne)',
        })
      ),
      execution_payload_transactions_count_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction count of the execution payload (filter: lt)',
        })
      ),
      execution_payload_transactions_count_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction count of the execution payload (filter: lte)',
        })
      ),
      execution_payload_transactions_count_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction count of the execution payload (filter: gt)',
        })
      ),
      execution_payload_transactions_count_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction count of the execution payload (filter: gte)',
        })
      ),
      execution_payload_transactions_count_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction count of the execution payload (filter: between_min)',
        })
      ),
      execution_payload_transactions_count_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction count of the execution payload (filter: between_max_value)',
        })
      ),
      execution_payload_transactions_count_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description: 'The transaction count of the execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_transactions_count_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The transaction count of the execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      execution_payload_transactions_total_bytes_eq: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload (filter: eq)',
        })
      ),
      execution_payload_transactions_total_bytes_ne: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload (filter: ne)',
        })
      ),
      execution_payload_transactions_total_bytes_lt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload (filter: lt)',
        })
      ),
      execution_payload_transactions_total_bytes_lte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload (filter: lte)',
        })
      ),
      execution_payload_transactions_total_bytes_gt: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload (filter: gt)',
        })
      ),
      execution_payload_transactions_total_bytes_gte: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload (filter: gte)',
        })
      ),
      execution_payload_transactions_total_bytes_between_min: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload (filter: between_min)',
        })
      ),
      execution_payload_transactions_total_bytes_between_max_value: z.optional(
        z.int().register(z.globalRegistry, {
          description: 'The transaction total bytes of the execution payload (filter: between_max_value)',
        })
      ),
      execution_payload_transactions_total_bytes_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The transaction total bytes of the execution payload (filter: in_values) (comma-separated list)',
          })
      ),
      execution_payload_transactions_total_bytes_not_in_values: z.optional(
        z
          .string()
          .regex(/^\d+(,\d+)*$/)
          .register(z.globalRegistry, {
            description:
              'The transaction total bytes of the execution payload (filter: not_in_values) (comma-separated list)',
          })
      ),
      page_size: z.optional(
        z.int().register(z.globalRegistry, {
          description:
            'The maximum number of fct_prepared_block to return. If unspecified, at most 100 items will be returned. The maximum value is 10000; values above 10000 will be coerced to 10000.',
        })
      ),
      page_token: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'A page token, received from a previous `ListFctPreparedBlock` call. Provide this to retrieve the subsequent page.',
        })
      ),
      order_by: z.optional(
        z.string().register(z.globalRegistry, {
          description:
            'The order of results. Format: comma-separated list of fields. Example: "foo,bar" or "foo desc,bar" for descending order on foo. If unspecified, results will be returned in the default order.',
        })
      ),
    })
  ),
});

/**
 * OK
 */
export const zFctPreparedBlockServiceListResponse = zListFctPreparedBlockResponse;

export const zFctPreparedBlockServiceGetData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    slot_start_date_time: z.int().register(z.globalRegistry, {
      description: 'The wall clock time when the slot started',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * OK
 */
export const zFctPreparedBlockServiceGetResponse = zGetFctPreparedBlockResponse;
