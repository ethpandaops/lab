// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file vendor/xatu-cbt/clickhouse/fct_attestation_correctness_by_validator_canonical.proto (package cbt, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, StringValue, UInt32Value } from "@bufbuild/protobuf";
import { NullableStringFilter, NullableUInt32Filter, StringFilter, UInt32Filter } from "./common_pb.js";

/**
 * @generated from message cbt.FctAttestationCorrectnessByValidatorCanonical
 */
export class FctAttestationCorrectnessByValidatorCanonical extends Message<FctAttestationCorrectnessByValidatorCanonical> {
  /**
   * Timestamp when the record was last updated
   *
   * @generated from field: uint32 updated_date_time = 11;
   */
  updatedDateTime = 0;

  /**
   * The slot number
   *
   * @generated from field: uint32 slot = 12;
   */
  slot = 0;

  /**
   * The wall clock time when the slot started
   *
   * @generated from field: uint32 slot_start_date_time = 13;
   */
  slotStartDateTime = 0;

  /**
   * The epoch number containing the slot
   *
   * @generated from field: uint32 epoch = 14;
   */
  epoch = 0;

  /**
   * The wall clock time when the epoch started
   *
   * @generated from field: uint32 epoch_start_date_time = 15;
   */
  epochStartDateTime = 0;

  /**
   * The index of the validator attesting
   *
   * @generated from field: uint32 attesting_validator_index = 16;
   */
  attestingValidatorIndex = 0;

  /**
   * The beacon block root hash that was attested
   *
   * @generated from field: google.protobuf.StringValue block_root = 17;
   */
  blockRoot?: string;

  /**
   * The distance from the slot to the attested block. If the attested block is the same as the slot, the distance is 0, if the attested block is the previous slot, the distance is 1, etc. If null, the attestation was missed, the block was orphaned and never seen by a sentry or the block was more than 64 slots ago
   *
   * @generated from field: google.protobuf.UInt32Value slot_distance = 18;
   */
  slotDistance?: number;

  /**
   * The distance from the slot when the attestation was included in a block
   *
   * @generated from field: google.protobuf.UInt32Value inclusion_distance = 19;
   */
  inclusionDistance?: number;

  /**
   * Can be "canonical", "orphaned", "missed" or "unknown" (validator attested but block data not available)
   *
   * @generated from field: string status = 20;
   */
  status = "";

  constructor(data?: PartialMessage<FctAttestationCorrectnessByValidatorCanonical>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.FctAttestationCorrectnessByValidatorCanonical";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 11, name: "updated_date_time", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 12, name: "slot", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 13, name: "slot_start_date_time", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 14, name: "epoch", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 15, name: "epoch_start_date_time", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 16, name: "attesting_validator_index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 17, name: "block_root", kind: "message", T: StringValue },
    { no: 18, name: "slot_distance", kind: "message", T: UInt32Value },
    { no: 19, name: "inclusion_distance", kind: "message", T: UInt32Value },
    { no: 20, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FctAttestationCorrectnessByValidatorCanonical {
    return new FctAttestationCorrectnessByValidatorCanonical().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FctAttestationCorrectnessByValidatorCanonical {
    return new FctAttestationCorrectnessByValidatorCanonical().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FctAttestationCorrectnessByValidatorCanonical {
    return new FctAttestationCorrectnessByValidatorCanonical().fromJsonString(jsonString, options);
  }

  static equals(a: FctAttestationCorrectnessByValidatorCanonical | PlainMessage<FctAttestationCorrectnessByValidatorCanonical> | undefined, b: FctAttestationCorrectnessByValidatorCanonical | PlainMessage<FctAttestationCorrectnessByValidatorCanonical> | undefined): boolean {
    return proto3.util.equals(FctAttestationCorrectnessByValidatorCanonical, a, b);
  }
}

/**
 * ListFctAttestationCorrectnessByValidatorCanonicalRequest is the request message for listing fct_attestation_correctness_by_validator_canonical records
 *
 * @generated from message cbt.ListFctAttestationCorrectnessByValidatorCanonicalRequest
 */
export class ListFctAttestationCorrectnessByValidatorCanonicalRequest extends Message<ListFctAttestationCorrectnessByValidatorCanonicalRequest> {
  /**
   * Filter by slot_start_date_time (PRIMARY KEY - required)
   *
   * @generated from field: cbt.UInt32Filter slot_start_date_time = 1;
   */
  slotStartDateTime?: UInt32Filter;

  /**
   * Filter by attesting_validator_index (ORDER BY column 2 - optional)
   *
   * @generated from field: cbt.UInt32Filter attesting_validator_index = 2;
   */
  attestingValidatorIndex?: UInt32Filter;

  /**
   * Filter by updated_date_time (optional)
   *
   * @generated from field: cbt.UInt32Filter updated_date_time = 3;
   */
  updatedDateTime?: UInt32Filter;

  /**
   * Filter by slot (optional)
   *
   * @generated from field: cbt.UInt32Filter slot = 4;
   */
  slot?: UInt32Filter;

  /**
   * Filter by epoch (optional)
   *
   * @generated from field: cbt.UInt32Filter epoch = 5;
   */
  epoch?: UInt32Filter;

  /**
   * Filter by epoch_start_date_time (optional)
   *
   * @generated from field: cbt.UInt32Filter epoch_start_date_time = 6;
   */
  epochStartDateTime?: UInt32Filter;

  /**
   * Filter by block_root (optional)
   *
   * @generated from field: cbt.NullableStringFilter block_root = 7;
   */
  blockRoot?: NullableStringFilter;

  /**
   * Filter by slot_distance (optional)
   *
   * @generated from field: cbt.NullableUInt32Filter slot_distance = 8;
   */
  slotDistance?: NullableUInt32Filter;

  /**
   * Filter by inclusion_distance (optional)
   *
   * @generated from field: cbt.NullableUInt32Filter inclusion_distance = 9;
   */
  inclusionDistance?: NullableUInt32Filter;

  /**
   * Filter by status (optional)
   *
   * @generated from field: cbt.StringFilter status = 10;
   */
  status?: StringFilter;

  /**
   * The maximum number of fct_attestation_correctness_by_validator_canonical to return.
   * If unspecified, at most 100 items will be returned.
   * The maximum value is 10000; values above 10000 will be coerced to 10000.
   *
   * @generated from field: int32 page_size = 11;
   */
  pageSize = 0;

  /**
   * A page token, received from a previous `ListFctAttestationCorrectnessByValidatorCanonical` call.
   * Provide this to retrieve the subsequent page.
   *
   * @generated from field: string page_token = 12;
   */
  pageToken = "";

  /**
   * The order of results. Format: comma-separated list of fields.
   * Example: "foo,bar" or "foo desc,bar" for descending order on foo.
   * If unspecified, results will be returned in the default order.
   *
   * @generated from field: string order_by = 13;
   */
  orderBy = "";

  constructor(data?: PartialMessage<ListFctAttestationCorrectnessByValidatorCanonicalRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.ListFctAttestationCorrectnessByValidatorCanonicalRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "slot_start_date_time", kind: "message", T: UInt32Filter },
    { no: 2, name: "attesting_validator_index", kind: "message", T: UInt32Filter },
    { no: 3, name: "updated_date_time", kind: "message", T: UInt32Filter },
    { no: 4, name: "slot", kind: "message", T: UInt32Filter },
    { no: 5, name: "epoch", kind: "message", T: UInt32Filter },
    { no: 6, name: "epoch_start_date_time", kind: "message", T: UInt32Filter },
    { no: 7, name: "block_root", kind: "message", T: NullableStringFilter },
    { no: 8, name: "slot_distance", kind: "message", T: NullableUInt32Filter },
    { no: 9, name: "inclusion_distance", kind: "message", T: NullableUInt32Filter },
    { no: 10, name: "status", kind: "message", T: StringFilter },
    { no: 11, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 12, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "order_by", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListFctAttestationCorrectnessByValidatorCanonicalRequest {
    return new ListFctAttestationCorrectnessByValidatorCanonicalRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListFctAttestationCorrectnessByValidatorCanonicalRequest {
    return new ListFctAttestationCorrectnessByValidatorCanonicalRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListFctAttestationCorrectnessByValidatorCanonicalRequest {
    return new ListFctAttestationCorrectnessByValidatorCanonicalRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListFctAttestationCorrectnessByValidatorCanonicalRequest | PlainMessage<ListFctAttestationCorrectnessByValidatorCanonicalRequest> | undefined, b: ListFctAttestationCorrectnessByValidatorCanonicalRequest | PlainMessage<ListFctAttestationCorrectnessByValidatorCanonicalRequest> | undefined): boolean {
    return proto3.util.equals(ListFctAttestationCorrectnessByValidatorCanonicalRequest, a, b);
  }
}

/**
 * ListFctAttestationCorrectnessByValidatorCanonicalResponse is the response message for listing fct_attestation_correctness_by_validator_canonical records
 *
 * @generated from message cbt.ListFctAttestationCorrectnessByValidatorCanonicalResponse
 */
export class ListFctAttestationCorrectnessByValidatorCanonicalResponse extends Message<ListFctAttestationCorrectnessByValidatorCanonicalResponse> {
  /**
   * The list of fct_attestation_correctness_by_validator_canonical.
   *
   * @generated from field: repeated cbt.FctAttestationCorrectnessByValidatorCanonical fct_attestation_correctness_by_validator_canonical = 1;
   */
  fctAttestationCorrectnessByValidatorCanonical: FctAttestationCorrectnessByValidatorCanonical[] = [];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListFctAttestationCorrectnessByValidatorCanonicalResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.ListFctAttestationCorrectnessByValidatorCanonicalResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fct_attestation_correctness_by_validator_canonical", kind: "message", T: FctAttestationCorrectnessByValidatorCanonical, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListFctAttestationCorrectnessByValidatorCanonicalResponse {
    return new ListFctAttestationCorrectnessByValidatorCanonicalResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListFctAttestationCorrectnessByValidatorCanonicalResponse {
    return new ListFctAttestationCorrectnessByValidatorCanonicalResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListFctAttestationCorrectnessByValidatorCanonicalResponse {
    return new ListFctAttestationCorrectnessByValidatorCanonicalResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListFctAttestationCorrectnessByValidatorCanonicalResponse | PlainMessage<ListFctAttestationCorrectnessByValidatorCanonicalResponse> | undefined, b: ListFctAttestationCorrectnessByValidatorCanonicalResponse | PlainMessage<ListFctAttestationCorrectnessByValidatorCanonicalResponse> | undefined): boolean {
    return proto3.util.equals(ListFctAttestationCorrectnessByValidatorCanonicalResponse, a, b);
  }
}

/**
 * GetFctAttestationCorrectnessByValidatorCanonicalRequest is the request message for getting a single fct_attestation_correctness_by_validator_canonical record by primary key
 *
 * @generated from message cbt.GetFctAttestationCorrectnessByValidatorCanonicalRequest
 */
export class GetFctAttestationCorrectnessByValidatorCanonicalRequest extends Message<GetFctAttestationCorrectnessByValidatorCanonicalRequest> {
  /**
   * The wall clock time when the slot started
   *
   * Primary key (required)
   *
   * @generated from field: uint32 slot_start_date_time = 1;
   */
  slotStartDateTime = 0;

  constructor(data?: PartialMessage<GetFctAttestationCorrectnessByValidatorCanonicalRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.GetFctAttestationCorrectnessByValidatorCanonicalRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "slot_start_date_time", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetFctAttestationCorrectnessByValidatorCanonicalRequest {
    return new GetFctAttestationCorrectnessByValidatorCanonicalRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetFctAttestationCorrectnessByValidatorCanonicalRequest {
    return new GetFctAttestationCorrectnessByValidatorCanonicalRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetFctAttestationCorrectnessByValidatorCanonicalRequest {
    return new GetFctAttestationCorrectnessByValidatorCanonicalRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetFctAttestationCorrectnessByValidatorCanonicalRequest | PlainMessage<GetFctAttestationCorrectnessByValidatorCanonicalRequest> | undefined, b: GetFctAttestationCorrectnessByValidatorCanonicalRequest | PlainMessage<GetFctAttestationCorrectnessByValidatorCanonicalRequest> | undefined): boolean {
    return proto3.util.equals(GetFctAttestationCorrectnessByValidatorCanonicalRequest, a, b);
  }
}

/**
 * GetFctAttestationCorrectnessByValidatorCanonicalResponse is the response message for getting a single fct_attestation_correctness_by_validator_canonical record
 *
 * @generated from message cbt.GetFctAttestationCorrectnessByValidatorCanonicalResponse
 */
export class GetFctAttestationCorrectnessByValidatorCanonicalResponse extends Message<GetFctAttestationCorrectnessByValidatorCanonicalResponse> {
  /**
   * @generated from field: cbt.FctAttestationCorrectnessByValidatorCanonical item = 1;
   */
  item?: FctAttestationCorrectnessByValidatorCanonical;

  constructor(data?: PartialMessage<GetFctAttestationCorrectnessByValidatorCanonicalResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.GetFctAttestationCorrectnessByValidatorCanonicalResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "item", kind: "message", T: FctAttestationCorrectnessByValidatorCanonical },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetFctAttestationCorrectnessByValidatorCanonicalResponse {
    return new GetFctAttestationCorrectnessByValidatorCanonicalResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetFctAttestationCorrectnessByValidatorCanonicalResponse {
    return new GetFctAttestationCorrectnessByValidatorCanonicalResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetFctAttestationCorrectnessByValidatorCanonicalResponse {
    return new GetFctAttestationCorrectnessByValidatorCanonicalResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetFctAttestationCorrectnessByValidatorCanonicalResponse | PlainMessage<GetFctAttestationCorrectnessByValidatorCanonicalResponse> | undefined, b: GetFctAttestationCorrectnessByValidatorCanonicalResponse | PlainMessage<GetFctAttestationCorrectnessByValidatorCanonicalResponse> | undefined): boolean {
    return proto3.util.equals(GetFctAttestationCorrectnessByValidatorCanonicalResponse, a, b);
  }
}

