// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file vendor/xatu-cbt/clickhouse/fct_block_proposer.proto (package cbt, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, StringValue } from "@bufbuild/protobuf";
import { NullableStringFilter, StringFilter, UInt32Filter } from "./common_pb.js";

/**
 * @generated from message cbt.FctBlockProposer
 */
export class FctBlockProposer extends Message<FctBlockProposer> {
  /**
   * Timestamp when the record was last updated
   *
   * @generated from field: uint32 updated_date_time = 11;
   */
  updatedDateTime = 0;

  /**
   * The slot number
   *
   * @generated from field: uint32 slot = 12;
   */
  slot = 0;

  /**
   * The wall clock time when the slot started
   *
   * @generated from field: uint32 slot_start_date_time = 13;
   */
  slotStartDateTime = 0;

  /**
   * The epoch number containing the slot
   *
   * @generated from field: uint32 epoch = 14;
   */
  epoch = 0;

  /**
   * The wall clock time when the epoch started
   *
   * @generated from field: uint32 epoch_start_date_time = 15;
   */
  epochStartDateTime = 0;

  /**
   * The validator index of the proposer for the slot
   *
   * @generated from field: uint32 proposer_validator_index = 16;
   */
  proposerValidatorIndex = 0;

  /**
   * The public key of the validator proposer
   *
   * @generated from field: string proposer_pubkey = 17;
   */
  proposerPubkey = "";

  /**
   * The beacon block root hash. Null if a block was never seen by a sentry, aka "missed"
   *
   * @generated from field: google.protobuf.StringValue block_root = 18;
   */
  blockRoot?: string;

  /**
   * Can be "canonical", "orphaned" or "missed"
   *
   * @generated from field: string status = 19;
   */
  status = "";

  constructor(data?: PartialMessage<FctBlockProposer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.FctBlockProposer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 11, name: "updated_date_time", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 12, name: "slot", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 13, name: "slot_start_date_time", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 14, name: "epoch", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 15, name: "epoch_start_date_time", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 16, name: "proposer_validator_index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 17, name: "proposer_pubkey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 18, name: "block_root", kind: "message", T: StringValue },
    { no: 19, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FctBlockProposer {
    return new FctBlockProposer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FctBlockProposer {
    return new FctBlockProposer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FctBlockProposer {
    return new FctBlockProposer().fromJsonString(jsonString, options);
  }

  static equals(a: FctBlockProposer | PlainMessage<FctBlockProposer> | undefined, b: FctBlockProposer | PlainMessage<FctBlockProposer> | undefined): boolean {
    return proto3.util.equals(FctBlockProposer, a, b);
  }
}

/**
 * Request for listing fct_block_proposer records
 *
 * @generated from message cbt.ListFctBlockProposerRequest
 */
export class ListFctBlockProposerRequest extends Message<ListFctBlockProposerRequest> {
  /**
   * Filter by slot_start_date_time - The wall clock time when the slot started (PRIMARY KEY - required unless using alternatives: slot)
   *
   * @generated from field: cbt.UInt32Filter slot_start_date_time = 1;
   */
  slotStartDateTime?: UInt32Filter;

  /**
   * Filter by updated_date_time - Timestamp when the record was last updated (optional)
   *
   * @generated from field: cbt.UInt32Filter updated_date_time = 2;
   */
  updatedDateTime?: UInt32Filter;

  /**
   * Filter by slot - The slot number (PROJECTION: p_by_slot - alternative to slot_start_date_time)
   *
   * @generated from field: cbt.UInt32Filter slot = 3;
   */
  slot?: UInt32Filter;

  /**
   * Filter by epoch - The epoch number containing the slot (optional)
   *
   * @generated from field: cbt.UInt32Filter epoch = 4;
   */
  epoch?: UInt32Filter;

  /**
   * Filter by epoch_start_date_time - The wall clock time when the epoch started (optional)
   *
   * @generated from field: cbt.UInt32Filter epoch_start_date_time = 5;
   */
  epochStartDateTime?: UInt32Filter;

  /**
   * Filter by proposer_validator_index - The validator index of the proposer for the slot (optional)
   *
   * @generated from field: cbt.UInt32Filter proposer_validator_index = 6;
   */
  proposerValidatorIndex?: UInt32Filter;

  /**
   * Filter by proposer_pubkey - The public key of the validator proposer (optional)
   *
   * @generated from field: cbt.StringFilter proposer_pubkey = 7;
   */
  proposerPubkey?: StringFilter;

  /**
   * Filter by block_root - The beacon block root hash. Null if a block was never seen by a sentry, aka "missed" (optional)
   *
   * @generated from field: cbt.NullableStringFilter block_root = 8;
   */
  blockRoot?: NullableStringFilter;

  /**
   * Filter by status - Can be "canonical", "orphaned" or "missed" (optional)
   *
   * @generated from field: cbt.StringFilter status = 9;
   */
  status?: StringFilter;

  /**
   * The maximum number of fct_block_proposer to return.
   * If unspecified, at most 100 items will be returned.
   * The maximum value is 10000; values above 10000 will be coerced to 10000.
   *
   * @generated from field: int32 page_size = 10;
   */
  pageSize = 0;

  /**
   * A page token, received from a previous `ListFctBlockProposer` call.
   * Provide this to retrieve the subsequent page.
   *
   * @generated from field: string page_token = 11;
   */
  pageToken = "";

  /**
   * The order of results. Format: comma-separated list of fields.
   * Example: "foo,bar" or "foo desc,bar" for descending order on foo.
   * If unspecified, results will be returned in the default order.
   *
   * @generated from field: string order_by = 12;
   */
  orderBy = "";

  constructor(data?: PartialMessage<ListFctBlockProposerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.ListFctBlockProposerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "slot_start_date_time", kind: "message", T: UInt32Filter },
    { no: 2, name: "updated_date_time", kind: "message", T: UInt32Filter },
    { no: 3, name: "slot", kind: "message", T: UInt32Filter },
    { no: 4, name: "epoch", kind: "message", T: UInt32Filter },
    { no: 5, name: "epoch_start_date_time", kind: "message", T: UInt32Filter },
    { no: 6, name: "proposer_validator_index", kind: "message", T: UInt32Filter },
    { no: 7, name: "proposer_pubkey", kind: "message", T: StringFilter },
    { no: 8, name: "block_root", kind: "message", T: NullableStringFilter },
    { no: 9, name: "status", kind: "message", T: StringFilter },
    { no: 10, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 11, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "order_by", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListFctBlockProposerRequest {
    return new ListFctBlockProposerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListFctBlockProposerRequest {
    return new ListFctBlockProposerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListFctBlockProposerRequest {
    return new ListFctBlockProposerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListFctBlockProposerRequest | PlainMessage<ListFctBlockProposerRequest> | undefined, b: ListFctBlockProposerRequest | PlainMessage<ListFctBlockProposerRequest> | undefined): boolean {
    return proto3.util.equals(ListFctBlockProposerRequest, a, b);
  }
}

/**
 * Response for listing fct_block_proposer records
 *
 * @generated from message cbt.ListFctBlockProposerResponse
 */
export class ListFctBlockProposerResponse extends Message<ListFctBlockProposerResponse> {
  /**
   * The list of fct_block_proposer.
   *
   * @generated from field: repeated cbt.FctBlockProposer fct_block_proposer = 1;
   */
  fctBlockProposer: FctBlockProposer[] = [];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListFctBlockProposerResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.ListFctBlockProposerResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fct_block_proposer", kind: "message", T: FctBlockProposer, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListFctBlockProposerResponse {
    return new ListFctBlockProposerResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListFctBlockProposerResponse {
    return new ListFctBlockProposerResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListFctBlockProposerResponse {
    return new ListFctBlockProposerResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListFctBlockProposerResponse | PlainMessage<ListFctBlockProposerResponse> | undefined, b: ListFctBlockProposerResponse | PlainMessage<ListFctBlockProposerResponse> | undefined): boolean {
    return proto3.util.equals(ListFctBlockProposerResponse, a, b);
  }
}

/**
 * Request for getting a single fct_block_proposer record by primary key
 *
 * @generated from message cbt.GetFctBlockProposerRequest
 */
export class GetFctBlockProposerRequest extends Message<GetFctBlockProposerRequest> {
  /**
   * The wall clock time when the slot started
   *
   * Primary key (required)
   *
   * @generated from field: uint32 slot_start_date_time = 1;
   */
  slotStartDateTime = 0;

  constructor(data?: PartialMessage<GetFctBlockProposerRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.GetFctBlockProposerRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "slot_start_date_time", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetFctBlockProposerRequest {
    return new GetFctBlockProposerRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetFctBlockProposerRequest {
    return new GetFctBlockProposerRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetFctBlockProposerRequest {
    return new GetFctBlockProposerRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetFctBlockProposerRequest | PlainMessage<GetFctBlockProposerRequest> | undefined, b: GetFctBlockProposerRequest | PlainMessage<GetFctBlockProposerRequest> | undefined): boolean {
    return proto3.util.equals(GetFctBlockProposerRequest, a, b);
  }
}

/**
 * Response for getting a single fct_block_proposer record
 *
 * @generated from message cbt.GetFctBlockProposerResponse
 */
export class GetFctBlockProposerResponse extends Message<GetFctBlockProposerResponse> {
  /**
   * @generated from field: cbt.FctBlockProposer item = 1;
   */
  item?: FctBlockProposer;

  constructor(data?: PartialMessage<GetFctBlockProposerResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.GetFctBlockProposerResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "item", kind: "message", T: FctBlockProposer },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetFctBlockProposerResponse {
    return new GetFctBlockProposerResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetFctBlockProposerResponse {
    return new GetFctBlockProposerResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetFctBlockProposerResponse {
    return new GetFctBlockProposerResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetFctBlockProposerResponse | PlainMessage<GetFctBlockProposerResponse> | undefined, b: GetFctBlockProposerResponse | PlainMessage<GetFctBlockProposerResponse> | undefined): boolean {
    return proto3.util.equals(GetFctBlockProposerResponse, a, b);
  }
}

