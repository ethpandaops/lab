// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file vendor/xatu-cbt/clickhouse/int_attestation_attested_canonical.proto (package cbt, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { StringFilter, UInt32Filter } from "./common_pb.js";

/**
 * @generated from message cbt.IntAttestationAttestedCanonical
 */
export class IntAttestationAttestedCanonical extends Message<IntAttestationAttestedCanonical> {
  /**
   * Timestamp when the record was last updated
   *
   * @generated from field: uint32 updated_date_time = 11;
   */
  updatedDateTime = 0;

  /**
   * The slot number
   *
   * @generated from field: uint32 slot = 12;
   */
  slot = 0;

  /**
   * The wall clock time when the slot started
   *
   * @generated from field: uint32 slot_start_date_time = 13;
   */
  slotStartDateTime = 0;

  /**
   * The epoch number containing the slot
   *
   * @generated from field: uint32 epoch = 14;
   */
  epoch = 0;

  /**
   * The wall clock time when the epoch started
   *
   * @generated from field: uint32 epoch_start_date_time = 15;
   */
  epochStartDateTime = 0;

  /**
   * The source epoch number in the attestation group
   *
   * @generated from field: uint32 source_epoch = 16;
   */
  sourceEpoch = 0;

  /**
   * The wall clock time when the source epoch started
   *
   * @generated from field: uint32 source_epoch_start_date_time = 17;
   */
  sourceEpochStartDateTime = 0;

  /**
   * The source beacon block root hash in the attestation group
   *
   * @generated from field: string source_root = 18;
   */
  sourceRoot = "";

  /**
   * The target epoch number in the attestation group
   *
   * @generated from field: uint32 target_epoch = 19;
   */
  targetEpoch = 0;

  /**
   * The wall clock time when the target epoch started
   *
   * @generated from field: uint32 target_epoch_start_date_time = 20;
   */
  targetEpochStartDateTime = 0;

  /**
   * The target beacon block root hash in the attestation group
   *
   * @generated from field: string target_root = 21;
   */
  targetRoot = "";

  /**
   * The beacon block root hash
   *
   * @generated from field: string block_root = 22;
   */
  blockRoot = "";

  /**
   * The index of the validator attesting
   *
   * @generated from field: uint32 attesting_validator_index = 23;
   */
  attestingValidatorIndex = 0;

  /**
   * The distance from the slot when the attestation was included
   *
   * @generated from field: uint32 inclusion_distance = 24;
   */
  inclusionDistance = 0;

  constructor(data?: PartialMessage<IntAttestationAttestedCanonical>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.IntAttestationAttestedCanonical";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 11, name: "updated_date_time", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 12, name: "slot", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 13, name: "slot_start_date_time", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 14, name: "epoch", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 15, name: "epoch_start_date_time", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 16, name: "source_epoch", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 17, name: "source_epoch_start_date_time", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 18, name: "source_root", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 19, name: "target_epoch", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 20, name: "target_epoch_start_date_time", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 21, name: "target_root", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 22, name: "block_root", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 23, name: "attesting_validator_index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 24, name: "inclusion_distance", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IntAttestationAttestedCanonical {
    return new IntAttestationAttestedCanonical().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IntAttestationAttestedCanonical {
    return new IntAttestationAttestedCanonical().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IntAttestationAttestedCanonical {
    return new IntAttestationAttestedCanonical().fromJsonString(jsonString, options);
  }

  static equals(a: IntAttestationAttestedCanonical | PlainMessage<IntAttestationAttestedCanonical> | undefined, b: IntAttestationAttestedCanonical | PlainMessage<IntAttestationAttestedCanonical> | undefined): boolean {
    return proto3.util.equals(IntAttestationAttestedCanonical, a, b);
  }
}

/**
 * ListIntAttestationAttestedCanonicalRequest is the request message for listing int_attestation_attested_canonical records
 *
 * @generated from message cbt.ListIntAttestationAttestedCanonicalRequest
 */
export class ListIntAttestationAttestedCanonicalRequest extends Message<ListIntAttestationAttestedCanonicalRequest> {
  /**
   * Filter by slot_start_date_time (PRIMARY KEY - required)
   *
   * @generated from field: cbt.UInt32Filter slot_start_date_time = 1;
   */
  slotStartDateTime?: UInt32Filter;

  /**
   * Filter by block_root (ORDER BY column 2 - optional)
   *
   * @generated from field: cbt.StringFilter block_root = 2;
   */
  blockRoot?: StringFilter;

  /**
   * Filter by attesting_validator_index (ORDER BY column 3 - optional)
   *
   * @generated from field: cbt.UInt32Filter attesting_validator_index = 3;
   */
  attestingValidatorIndex?: UInt32Filter;

  /**
   * Filter by updated_date_time (optional)
   *
   * @generated from field: cbt.UInt32Filter updated_date_time = 4;
   */
  updatedDateTime?: UInt32Filter;

  /**
   * Filter by slot (optional)
   *
   * @generated from field: cbt.UInt32Filter slot = 5;
   */
  slot?: UInt32Filter;

  /**
   * Filter by epoch (optional)
   *
   * @generated from field: cbt.UInt32Filter epoch = 6;
   */
  epoch?: UInt32Filter;

  /**
   * Filter by epoch_start_date_time (optional)
   *
   * @generated from field: cbt.UInt32Filter epoch_start_date_time = 7;
   */
  epochStartDateTime?: UInt32Filter;

  /**
   * Filter by source_epoch (optional)
   *
   * @generated from field: cbt.UInt32Filter source_epoch = 8;
   */
  sourceEpoch?: UInt32Filter;

  /**
   * Filter by source_epoch_start_date_time (optional)
   *
   * @generated from field: cbt.UInt32Filter source_epoch_start_date_time = 9;
   */
  sourceEpochStartDateTime?: UInt32Filter;

  /**
   * Filter by source_root (optional)
   *
   * @generated from field: cbt.StringFilter source_root = 10;
   */
  sourceRoot?: StringFilter;

  /**
   * Filter by target_epoch (optional)
   *
   * @generated from field: cbt.UInt32Filter target_epoch = 11;
   */
  targetEpoch?: UInt32Filter;

  /**
   * Filter by target_epoch_start_date_time (optional)
   *
   * @generated from field: cbt.UInt32Filter target_epoch_start_date_time = 12;
   */
  targetEpochStartDateTime?: UInt32Filter;

  /**
   * Filter by target_root (optional)
   *
   * @generated from field: cbt.StringFilter target_root = 13;
   */
  targetRoot?: StringFilter;

  /**
   * Filter by inclusion_distance (optional)
   *
   * @generated from field: cbt.UInt32Filter inclusion_distance = 14;
   */
  inclusionDistance?: UInt32Filter;

  /**
   * The maximum number of int_attestation_attested_canonical to return.
   * If unspecified, at most 100 items will be returned.
   * The maximum value is 10000; values above 10000 will be coerced to 10000.
   *
   * @generated from field: int32 page_size = 15;
   */
  pageSize = 0;

  /**
   * A page token, received from a previous `ListIntAttestationAttestedCanonical` call.
   * Provide this to retrieve the subsequent page.
   *
   * @generated from field: string page_token = 16;
   */
  pageToken = "";

  /**
   * The order of results. Format: comma-separated list of fields.
   * Example: "foo,bar" or "foo desc,bar" for descending order on foo.
   * If unspecified, results will be returned in the default order.
   *
   * @generated from field: string order_by = 17;
   */
  orderBy = "";

  constructor(data?: PartialMessage<ListIntAttestationAttestedCanonicalRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.ListIntAttestationAttestedCanonicalRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "slot_start_date_time", kind: "message", T: UInt32Filter },
    { no: 2, name: "block_root", kind: "message", T: StringFilter },
    { no: 3, name: "attesting_validator_index", kind: "message", T: UInt32Filter },
    { no: 4, name: "updated_date_time", kind: "message", T: UInt32Filter },
    { no: 5, name: "slot", kind: "message", T: UInt32Filter },
    { no: 6, name: "epoch", kind: "message", T: UInt32Filter },
    { no: 7, name: "epoch_start_date_time", kind: "message", T: UInt32Filter },
    { no: 8, name: "source_epoch", kind: "message", T: UInt32Filter },
    { no: 9, name: "source_epoch_start_date_time", kind: "message", T: UInt32Filter },
    { no: 10, name: "source_root", kind: "message", T: StringFilter },
    { no: 11, name: "target_epoch", kind: "message", T: UInt32Filter },
    { no: 12, name: "target_epoch_start_date_time", kind: "message", T: UInt32Filter },
    { no: 13, name: "target_root", kind: "message", T: StringFilter },
    { no: 14, name: "inclusion_distance", kind: "message", T: UInt32Filter },
    { no: 15, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 16, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 17, name: "order_by", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListIntAttestationAttestedCanonicalRequest {
    return new ListIntAttestationAttestedCanonicalRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListIntAttestationAttestedCanonicalRequest {
    return new ListIntAttestationAttestedCanonicalRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListIntAttestationAttestedCanonicalRequest {
    return new ListIntAttestationAttestedCanonicalRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListIntAttestationAttestedCanonicalRequest | PlainMessage<ListIntAttestationAttestedCanonicalRequest> | undefined, b: ListIntAttestationAttestedCanonicalRequest | PlainMessage<ListIntAttestationAttestedCanonicalRequest> | undefined): boolean {
    return proto3.util.equals(ListIntAttestationAttestedCanonicalRequest, a, b);
  }
}

/**
 * ListIntAttestationAttestedCanonicalResponse is the response message for listing int_attestation_attested_canonical records
 *
 * @generated from message cbt.ListIntAttestationAttestedCanonicalResponse
 */
export class ListIntAttestationAttestedCanonicalResponse extends Message<ListIntAttestationAttestedCanonicalResponse> {
  /**
   * The list of int_attestation_attested_canonical.
   *
   * @generated from field: repeated cbt.IntAttestationAttestedCanonical int_attestation_attested_canonical = 1;
   */
  intAttestationAttestedCanonical: IntAttestationAttestedCanonical[] = [];

  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListIntAttestationAttestedCanonicalResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.ListIntAttestationAttestedCanonicalResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "int_attestation_attested_canonical", kind: "message", T: IntAttestationAttestedCanonical, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListIntAttestationAttestedCanonicalResponse {
    return new ListIntAttestationAttestedCanonicalResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListIntAttestationAttestedCanonicalResponse {
    return new ListIntAttestationAttestedCanonicalResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListIntAttestationAttestedCanonicalResponse {
    return new ListIntAttestationAttestedCanonicalResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListIntAttestationAttestedCanonicalResponse | PlainMessage<ListIntAttestationAttestedCanonicalResponse> | undefined, b: ListIntAttestationAttestedCanonicalResponse | PlainMessage<ListIntAttestationAttestedCanonicalResponse> | undefined): boolean {
    return proto3.util.equals(ListIntAttestationAttestedCanonicalResponse, a, b);
  }
}

/**
 * GetIntAttestationAttestedCanonicalRequest is the request message for getting a single int_attestation_attested_canonical record by primary key
 *
 * @generated from message cbt.GetIntAttestationAttestedCanonicalRequest
 */
export class GetIntAttestationAttestedCanonicalRequest extends Message<GetIntAttestationAttestedCanonicalRequest> {
  /**
   * The wall clock time when the slot started
   *
   * Primary key (required)
   *
   * @generated from field: uint32 slot_start_date_time = 1;
   */
  slotStartDateTime = 0;

  constructor(data?: PartialMessage<GetIntAttestationAttestedCanonicalRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.GetIntAttestationAttestedCanonicalRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "slot_start_date_time", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIntAttestationAttestedCanonicalRequest {
    return new GetIntAttestationAttestedCanonicalRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIntAttestationAttestedCanonicalRequest {
    return new GetIntAttestationAttestedCanonicalRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIntAttestationAttestedCanonicalRequest {
    return new GetIntAttestationAttestedCanonicalRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetIntAttestationAttestedCanonicalRequest | PlainMessage<GetIntAttestationAttestedCanonicalRequest> | undefined, b: GetIntAttestationAttestedCanonicalRequest | PlainMessage<GetIntAttestationAttestedCanonicalRequest> | undefined): boolean {
    return proto3.util.equals(GetIntAttestationAttestedCanonicalRequest, a, b);
  }
}

/**
 * GetIntAttestationAttestedCanonicalResponse is the response message for getting a single int_attestation_attested_canonical record
 *
 * @generated from message cbt.GetIntAttestationAttestedCanonicalResponse
 */
export class GetIntAttestationAttestedCanonicalResponse extends Message<GetIntAttestationAttestedCanonicalResponse> {
  /**
   * @generated from field: cbt.IntAttestationAttestedCanonical item = 1;
   */
  item?: IntAttestationAttestedCanonical;

  constructor(data?: PartialMessage<GetIntAttestationAttestedCanonicalResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.GetIntAttestationAttestedCanonicalResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "item", kind: "message", T: IntAttestationAttestedCanonical },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetIntAttestationAttestedCanonicalResponse {
    return new GetIntAttestationAttestedCanonicalResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetIntAttestationAttestedCanonicalResponse {
    return new GetIntAttestationAttestedCanonicalResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetIntAttestationAttestedCanonicalResponse {
    return new GetIntAttestationAttestedCanonicalResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetIntAttestationAttestedCanonicalResponse | PlainMessage<GetIntAttestationAttestedCanonicalResponse> | undefined, b: GetIntAttestationAttestedCanonicalResponse | PlainMessage<GetIntAttestationAttestedCanonicalResponse> | undefined): boolean {
    return proto3.util.equals(GetIntAttestationAttestedCanonicalResponse, a, b);
  }
}

