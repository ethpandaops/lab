// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file vendor/xatu-cbt/clickhouse/common.proto (package cbt, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Empty, Int32Value, Int64Value, Message, proto3, protoInt64, UInt32Value, UInt64Value } from "@bufbuild/protobuf";

/**
 * SortOrder defines the order of results
 *
 * @generated from enum cbt.SortOrder
 */
export enum SortOrder {
  /**
   * @generated from enum value: ASC = 0;
   */
  ASC = 0,

  /**
   * @generated from enum value: DESC = 1;
   */
  DESC = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(SortOrder)
proto3.util.setEnumType(SortOrder, "cbt.SortOrder", [
  { no: 0, name: "ASC" },
  { no: 1, name: "DESC" },
]);

/**
 * UInt32Filter represents filtering options for non-nullable uint32 values
 *
 * @generated from message cbt.UInt32Filter
 */
export class UInt32Filter extends Message<UInt32Filter> {
  /**
   * @generated from oneof cbt.UInt32Filter.filter
   */
  filter: {
    /**
     * Equal to value
     *
     * @generated from field: uint32 eq = 1;
     */
    value: number;
    case: "eq";
  } | {
    /**
     * Not equal to value
     *
     * @generated from field: uint32 ne = 2;
     */
    value: number;
    case: "ne";
  } | {
    /**
     * Less than value
     *
     * @generated from field: uint32 lt = 3;
     */
    value: number;
    case: "lt";
  } | {
    /**
     * Less than or equal to value
     *
     * @generated from field: uint32 lte = 4;
     */
    value: number;
    case: "lte";
  } | {
    /**
     * Greater than value
     *
     * @generated from field: uint32 gt = 5;
     */
    value: number;
    case: "gt";
  } | {
    /**
     * Greater than or equal to value
     *
     * @generated from field: uint32 gte = 6;
     */
    value: number;
    case: "gte";
  } | {
    /**
     * Between min and max (inclusive)
     *
     * @generated from field: cbt.UInt32Range between = 7;
     */
    value: UInt32Range;
    case: "between";
  } | {
    /**
     * In list of values
     *
     * @generated from field: cbt.UInt32List in = 8;
     */
    value: UInt32List;
    case: "in";
  } | {
    /**
     * Not in list of values
     *
     * @generated from field: cbt.UInt32List not_in = 9;
     */
    value: UInt32List;
    case: "notIn";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<UInt32Filter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.UInt32Filter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "eq", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "filter" },
    { no: 2, name: "ne", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "filter" },
    { no: 3, name: "lt", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "filter" },
    { no: 4, name: "lte", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "filter" },
    { no: 5, name: "gt", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "filter" },
    { no: 6, name: "gte", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "filter" },
    { no: 7, name: "between", kind: "message", T: UInt32Range, oneof: "filter" },
    { no: 8, name: "in", kind: "message", T: UInt32List, oneof: "filter" },
    { no: 9, name: "not_in", kind: "message", T: UInt32List, oneof: "filter" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt32Filter {
    return new UInt32Filter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt32Filter {
    return new UInt32Filter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt32Filter {
    return new UInt32Filter().fromJsonString(jsonString, options);
  }

  static equals(a: UInt32Filter | PlainMessage<UInt32Filter> | undefined, b: UInt32Filter | PlainMessage<UInt32Filter> | undefined): boolean {
    return proto3.util.equals(UInt32Filter, a, b);
  }
}

/**
 * NullableUInt32Filter represents filtering options for nullable uint32 values
 *
 * @generated from message cbt.NullableUInt32Filter
 */
export class NullableUInt32Filter extends Message<NullableUInt32Filter> {
  /**
   * @generated from oneof cbt.NullableUInt32Filter.filter
   */
  filter: {
    /**
     * Equal to value
     *
     * @generated from field: uint32 eq = 1;
     */
    value: number;
    case: "eq";
  } | {
    /**
     * Not equal to value
     *
     * @generated from field: uint32 ne = 2;
     */
    value: number;
    case: "ne";
  } | {
    /**
     * Less than value
     *
     * @generated from field: uint32 lt = 3;
     */
    value: number;
    case: "lt";
  } | {
    /**
     * Less than or equal to value
     *
     * @generated from field: uint32 lte = 4;
     */
    value: number;
    case: "lte";
  } | {
    /**
     * Greater than value
     *
     * @generated from field: uint32 gt = 5;
     */
    value: number;
    case: "gt";
  } | {
    /**
     * Greater than or equal to value
     *
     * @generated from field: uint32 gte = 6;
     */
    value: number;
    case: "gte";
  } | {
    /**
     * Between min and max (inclusive)
     *
     * @generated from field: cbt.UInt32Range between = 7;
     */
    value: UInt32Range;
    case: "between";
  } | {
    /**
     * In list of values
     *
     * @generated from field: cbt.UInt32List in = 8;
     */
    value: UInt32List;
    case: "in";
  } | {
    /**
     * Not in list of values
     *
     * @generated from field: cbt.UInt32List not_in = 9;
     */
    value: UInt32List;
    case: "notIn";
  } | {
    /**
     * IS NULL check
     *
     * @generated from field: google.protobuf.Empty is_null = 10;
     */
    value: Empty;
    case: "isNull";
  } | {
    /**
     * IS NOT NULL check
     *
     * @generated from field: google.protobuf.Empty is_not_null = 11;
     */
    value: Empty;
    case: "isNotNull";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<NullableUInt32Filter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.NullableUInt32Filter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "eq", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "filter" },
    { no: 2, name: "ne", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "filter" },
    { no: 3, name: "lt", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "filter" },
    { no: 4, name: "lte", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "filter" },
    { no: 5, name: "gt", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "filter" },
    { no: 6, name: "gte", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "filter" },
    { no: 7, name: "between", kind: "message", T: UInt32Range, oneof: "filter" },
    { no: 8, name: "in", kind: "message", T: UInt32List, oneof: "filter" },
    { no: 9, name: "not_in", kind: "message", T: UInt32List, oneof: "filter" },
    { no: 10, name: "is_null", kind: "message", T: Empty, oneof: "filter" },
    { no: 11, name: "is_not_null", kind: "message", T: Empty, oneof: "filter" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NullableUInt32Filter {
    return new NullableUInt32Filter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NullableUInt32Filter {
    return new NullableUInt32Filter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NullableUInt32Filter {
    return new NullableUInt32Filter().fromJsonString(jsonString, options);
  }

  static equals(a: NullableUInt32Filter | PlainMessage<NullableUInt32Filter> | undefined, b: NullableUInt32Filter | PlainMessage<NullableUInt32Filter> | undefined): boolean {
    return proto3.util.equals(NullableUInt32Filter, a, b);
  }
}

/**
 * UInt32Range represents a range of uint32 values
 *
 * @generated from message cbt.UInt32Range
 */
export class UInt32Range extends Message<UInt32Range> {
  /**
   * @generated from field: uint32 min = 1;
   */
  min = 0;

  /**
   * If not set, matches exact value (min)
   *
   * @generated from field: google.protobuf.UInt32Value max = 2;
   */
  max?: number;

  constructor(data?: PartialMessage<UInt32Range>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.UInt32Range";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "min", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "max", kind: "message", T: UInt32Value },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt32Range {
    return new UInt32Range().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt32Range {
    return new UInt32Range().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt32Range {
    return new UInt32Range().fromJsonString(jsonString, options);
  }

  static equals(a: UInt32Range | PlainMessage<UInt32Range> | undefined, b: UInt32Range | PlainMessage<UInt32Range> | undefined): boolean {
    return proto3.util.equals(UInt32Range, a, b);
  }
}

/**
 * UInt32List represents a list of uint32 values
 *
 * @generated from message cbt.UInt32List
 */
export class UInt32List extends Message<UInt32List> {
  /**
   * @generated from field: repeated uint32 values = 1;
   */
  values: number[] = [];

  constructor(data?: PartialMessage<UInt32List>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.UInt32List";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt32List {
    return new UInt32List().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt32List {
    return new UInt32List().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt32List {
    return new UInt32List().fromJsonString(jsonString, options);
  }

  static equals(a: UInt32List | PlainMessage<UInt32List> | undefined, b: UInt32List | PlainMessage<UInt32List> | undefined): boolean {
    return proto3.util.equals(UInt32List, a, b);
  }
}

/**
 * UInt64Filter represents filtering options for non-nullable uint64 values
 *
 * @generated from message cbt.UInt64Filter
 */
export class UInt64Filter extends Message<UInt64Filter> {
  /**
   * @generated from oneof cbt.UInt64Filter.filter
   */
  filter: {
    /**
     * Equal to value
     *
     * @generated from field: uint64 eq = 1;
     */
    value: bigint;
    case: "eq";
  } | {
    /**
     * Not equal to value
     *
     * @generated from field: uint64 ne = 2;
     */
    value: bigint;
    case: "ne";
  } | {
    /**
     * Less than value
     *
     * @generated from field: uint64 lt = 3;
     */
    value: bigint;
    case: "lt";
  } | {
    /**
     * Less than or equal to value
     *
     * @generated from field: uint64 lte = 4;
     */
    value: bigint;
    case: "lte";
  } | {
    /**
     * Greater than value
     *
     * @generated from field: uint64 gt = 5;
     */
    value: bigint;
    case: "gt";
  } | {
    /**
     * Greater than or equal to value
     *
     * @generated from field: uint64 gte = 6;
     */
    value: bigint;
    case: "gte";
  } | {
    /**
     * Between min and max (inclusive)
     *
     * @generated from field: cbt.UInt64Range between = 7;
     */
    value: UInt64Range;
    case: "between";
  } | {
    /**
     * In list of values
     *
     * @generated from field: cbt.UInt64List in = 8;
     */
    value: UInt64List;
    case: "in";
  } | {
    /**
     * Not in list of values
     *
     * @generated from field: cbt.UInt64List not_in = 9;
     */
    value: UInt64List;
    case: "notIn";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<UInt64Filter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.UInt64Filter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "eq", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "filter" },
    { no: 2, name: "ne", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "filter" },
    { no: 3, name: "lt", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "filter" },
    { no: 4, name: "lte", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "filter" },
    { no: 5, name: "gt", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "filter" },
    { no: 6, name: "gte", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "filter" },
    { no: 7, name: "between", kind: "message", T: UInt64Range, oneof: "filter" },
    { no: 8, name: "in", kind: "message", T: UInt64List, oneof: "filter" },
    { no: 9, name: "not_in", kind: "message", T: UInt64List, oneof: "filter" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt64Filter {
    return new UInt64Filter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt64Filter {
    return new UInt64Filter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt64Filter {
    return new UInt64Filter().fromJsonString(jsonString, options);
  }

  static equals(a: UInt64Filter | PlainMessage<UInt64Filter> | undefined, b: UInt64Filter | PlainMessage<UInt64Filter> | undefined): boolean {
    return proto3.util.equals(UInt64Filter, a, b);
  }
}

/**
 * NullableUInt64Filter represents filtering options for nullable uint64 values
 *
 * @generated from message cbt.NullableUInt64Filter
 */
export class NullableUInt64Filter extends Message<NullableUInt64Filter> {
  /**
   * @generated from oneof cbt.NullableUInt64Filter.filter
   */
  filter: {
    /**
     * Equal to value
     *
     * @generated from field: uint64 eq = 1;
     */
    value: bigint;
    case: "eq";
  } | {
    /**
     * Not equal to value
     *
     * @generated from field: uint64 ne = 2;
     */
    value: bigint;
    case: "ne";
  } | {
    /**
     * Less than value
     *
     * @generated from field: uint64 lt = 3;
     */
    value: bigint;
    case: "lt";
  } | {
    /**
     * Less than or equal to value
     *
     * @generated from field: uint64 lte = 4;
     */
    value: bigint;
    case: "lte";
  } | {
    /**
     * Greater than value
     *
     * @generated from field: uint64 gt = 5;
     */
    value: bigint;
    case: "gt";
  } | {
    /**
     * Greater than or equal to value
     *
     * @generated from field: uint64 gte = 6;
     */
    value: bigint;
    case: "gte";
  } | {
    /**
     * Between min and max (inclusive)
     *
     * @generated from field: cbt.UInt64Range between = 7;
     */
    value: UInt64Range;
    case: "between";
  } | {
    /**
     * In list of values
     *
     * @generated from field: cbt.UInt64List in = 8;
     */
    value: UInt64List;
    case: "in";
  } | {
    /**
     * Not in list of values
     *
     * @generated from field: cbt.UInt64List not_in = 9;
     */
    value: UInt64List;
    case: "notIn";
  } | {
    /**
     * IS NULL check
     *
     * @generated from field: google.protobuf.Empty is_null = 10;
     */
    value: Empty;
    case: "isNull";
  } | {
    /**
     * IS NOT NULL check
     *
     * @generated from field: google.protobuf.Empty is_not_null = 11;
     */
    value: Empty;
    case: "isNotNull";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<NullableUInt64Filter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.NullableUInt64Filter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "eq", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "filter" },
    { no: 2, name: "ne", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "filter" },
    { no: 3, name: "lt", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "filter" },
    { no: 4, name: "lte", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "filter" },
    { no: 5, name: "gt", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "filter" },
    { no: 6, name: "gte", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "filter" },
    { no: 7, name: "between", kind: "message", T: UInt64Range, oneof: "filter" },
    { no: 8, name: "in", kind: "message", T: UInt64List, oneof: "filter" },
    { no: 9, name: "not_in", kind: "message", T: UInt64List, oneof: "filter" },
    { no: 10, name: "is_null", kind: "message", T: Empty, oneof: "filter" },
    { no: 11, name: "is_not_null", kind: "message", T: Empty, oneof: "filter" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NullableUInt64Filter {
    return new NullableUInt64Filter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NullableUInt64Filter {
    return new NullableUInt64Filter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NullableUInt64Filter {
    return new NullableUInt64Filter().fromJsonString(jsonString, options);
  }

  static equals(a: NullableUInt64Filter | PlainMessage<NullableUInt64Filter> | undefined, b: NullableUInt64Filter | PlainMessage<NullableUInt64Filter> | undefined): boolean {
    return proto3.util.equals(NullableUInt64Filter, a, b);
  }
}

/**
 * UInt64Range represents a range of uint64 values
 *
 * @generated from message cbt.UInt64Range
 */
export class UInt64Range extends Message<UInt64Range> {
  /**
   * @generated from field: uint64 min = 1;
   */
  min = protoInt64.zero;

  /**
   * @generated from field: google.protobuf.UInt64Value max = 2;
   */
  max?: bigint;

  constructor(data?: PartialMessage<UInt64Range>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.UInt64Range";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "min", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "max", kind: "message", T: UInt64Value },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt64Range {
    return new UInt64Range().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt64Range {
    return new UInt64Range().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt64Range {
    return new UInt64Range().fromJsonString(jsonString, options);
  }

  static equals(a: UInt64Range | PlainMessage<UInt64Range> | undefined, b: UInt64Range | PlainMessage<UInt64Range> | undefined): boolean {
    return proto3.util.equals(UInt64Range, a, b);
  }
}

/**
 * UInt64List represents a list of uint64 values
 *
 * @generated from message cbt.UInt64List
 */
export class UInt64List extends Message<UInt64List> {
  /**
   * @generated from field: repeated uint64 values = 1;
   */
  values: bigint[] = [];

  constructor(data?: PartialMessage<UInt64List>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.UInt64List";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UInt64List {
    return new UInt64List().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UInt64List {
    return new UInt64List().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UInt64List {
    return new UInt64List().fromJsonString(jsonString, options);
  }

  static equals(a: UInt64List | PlainMessage<UInt64List> | undefined, b: UInt64List | PlainMessage<UInt64List> | undefined): boolean {
    return proto3.util.equals(UInt64List, a, b);
  }
}

/**
 * Int32Filter represents filtering options for non-nullable int32 values
 *
 * @generated from message cbt.Int32Filter
 */
export class Int32Filter extends Message<Int32Filter> {
  /**
   * @generated from oneof cbt.Int32Filter.filter
   */
  filter: {
    /**
     * Equal to value
     *
     * @generated from field: int32 eq = 1;
     */
    value: number;
    case: "eq";
  } | {
    /**
     * Not equal to value
     *
     * @generated from field: int32 ne = 2;
     */
    value: number;
    case: "ne";
  } | {
    /**
     * Less than value
     *
     * @generated from field: int32 lt = 3;
     */
    value: number;
    case: "lt";
  } | {
    /**
     * Less than or equal to value
     *
     * @generated from field: int32 lte = 4;
     */
    value: number;
    case: "lte";
  } | {
    /**
     * Greater than value
     *
     * @generated from field: int32 gt = 5;
     */
    value: number;
    case: "gt";
  } | {
    /**
     * Greater than or equal to value
     *
     * @generated from field: int32 gte = 6;
     */
    value: number;
    case: "gte";
  } | {
    /**
     * Between min and max (inclusive)
     *
     * @generated from field: cbt.Int32Range between = 7;
     */
    value: Int32Range;
    case: "between";
  } | {
    /**
     * In list of values
     *
     * @generated from field: cbt.Int32List in = 8;
     */
    value: Int32List;
    case: "in";
  } | {
    /**
     * Not in list of values
     *
     * @generated from field: cbt.Int32List not_in = 9;
     */
    value: Int32List;
    case: "notIn";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Int32Filter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.Int32Filter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "eq", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "filter" },
    { no: 2, name: "ne", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "filter" },
    { no: 3, name: "lt", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "filter" },
    { no: 4, name: "lte", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "filter" },
    { no: 5, name: "gt", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "filter" },
    { no: 6, name: "gte", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "filter" },
    { no: 7, name: "between", kind: "message", T: Int32Range, oneof: "filter" },
    { no: 8, name: "in", kind: "message", T: Int32List, oneof: "filter" },
    { no: 9, name: "not_in", kind: "message", T: Int32List, oneof: "filter" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int32Filter {
    return new Int32Filter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int32Filter {
    return new Int32Filter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int32Filter {
    return new Int32Filter().fromJsonString(jsonString, options);
  }

  static equals(a: Int32Filter | PlainMessage<Int32Filter> | undefined, b: Int32Filter | PlainMessage<Int32Filter> | undefined): boolean {
    return proto3.util.equals(Int32Filter, a, b);
  }
}

/**
 * NullableInt32Filter represents filtering options for nullable int32 values
 *
 * @generated from message cbt.NullableInt32Filter
 */
export class NullableInt32Filter extends Message<NullableInt32Filter> {
  /**
   * @generated from oneof cbt.NullableInt32Filter.filter
   */
  filter: {
    /**
     * Equal to value
     *
     * @generated from field: int32 eq = 1;
     */
    value: number;
    case: "eq";
  } | {
    /**
     * Not equal to value
     *
     * @generated from field: int32 ne = 2;
     */
    value: number;
    case: "ne";
  } | {
    /**
     * Less than value
     *
     * @generated from field: int32 lt = 3;
     */
    value: number;
    case: "lt";
  } | {
    /**
     * Less than or equal to value
     *
     * @generated from field: int32 lte = 4;
     */
    value: number;
    case: "lte";
  } | {
    /**
     * Greater than value
     *
     * @generated from field: int32 gt = 5;
     */
    value: number;
    case: "gt";
  } | {
    /**
     * Greater than or equal to value
     *
     * @generated from field: int32 gte = 6;
     */
    value: number;
    case: "gte";
  } | {
    /**
     * Between min and max (inclusive)
     *
     * @generated from field: cbt.Int32Range between = 7;
     */
    value: Int32Range;
    case: "between";
  } | {
    /**
     * In list of values
     *
     * @generated from field: cbt.Int32List in = 8;
     */
    value: Int32List;
    case: "in";
  } | {
    /**
     * Not in list of values
     *
     * @generated from field: cbt.Int32List not_in = 9;
     */
    value: Int32List;
    case: "notIn";
  } | {
    /**
     * IS NULL check
     *
     * @generated from field: google.protobuf.Empty is_null = 10;
     */
    value: Empty;
    case: "isNull";
  } | {
    /**
     * IS NOT NULL check
     *
     * @generated from field: google.protobuf.Empty is_not_null = 11;
     */
    value: Empty;
    case: "isNotNull";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<NullableInt32Filter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.NullableInt32Filter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "eq", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "filter" },
    { no: 2, name: "ne", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "filter" },
    { no: 3, name: "lt", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "filter" },
    { no: 4, name: "lte", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "filter" },
    { no: 5, name: "gt", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "filter" },
    { no: 6, name: "gte", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "filter" },
    { no: 7, name: "between", kind: "message", T: Int32Range, oneof: "filter" },
    { no: 8, name: "in", kind: "message", T: Int32List, oneof: "filter" },
    { no: 9, name: "not_in", kind: "message", T: Int32List, oneof: "filter" },
    { no: 10, name: "is_null", kind: "message", T: Empty, oneof: "filter" },
    { no: 11, name: "is_not_null", kind: "message", T: Empty, oneof: "filter" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NullableInt32Filter {
    return new NullableInt32Filter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NullableInt32Filter {
    return new NullableInt32Filter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NullableInt32Filter {
    return new NullableInt32Filter().fromJsonString(jsonString, options);
  }

  static equals(a: NullableInt32Filter | PlainMessage<NullableInt32Filter> | undefined, b: NullableInt32Filter | PlainMessage<NullableInt32Filter> | undefined): boolean {
    return proto3.util.equals(NullableInt32Filter, a, b);
  }
}

/**
 * Int32Range represents a range of int32 values
 *
 * @generated from message cbt.Int32Range
 */
export class Int32Range extends Message<Int32Range> {
  /**
   * @generated from field: int32 min = 1;
   */
  min = 0;

  /**
   * @generated from field: google.protobuf.Int32Value max = 2;
   */
  max?: number;

  constructor(data?: PartialMessage<Int32Range>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.Int32Range";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "min", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "max", kind: "message", T: Int32Value },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int32Range {
    return new Int32Range().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int32Range {
    return new Int32Range().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int32Range {
    return new Int32Range().fromJsonString(jsonString, options);
  }

  static equals(a: Int32Range | PlainMessage<Int32Range> | undefined, b: Int32Range | PlainMessage<Int32Range> | undefined): boolean {
    return proto3.util.equals(Int32Range, a, b);
  }
}

/**
 * Int32List represents a list of int32 values
 *
 * @generated from message cbt.Int32List
 */
export class Int32List extends Message<Int32List> {
  /**
   * @generated from field: repeated int32 values = 1;
   */
  values: number[] = [];

  constructor(data?: PartialMessage<Int32List>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.Int32List";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int32List {
    return new Int32List().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int32List {
    return new Int32List().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int32List {
    return new Int32List().fromJsonString(jsonString, options);
  }

  static equals(a: Int32List | PlainMessage<Int32List> | undefined, b: Int32List | PlainMessage<Int32List> | undefined): boolean {
    return proto3.util.equals(Int32List, a, b);
  }
}

/**
 * Int64Filter represents filtering options for non-nullable int64 values
 *
 * @generated from message cbt.Int64Filter
 */
export class Int64Filter extends Message<Int64Filter> {
  /**
   * @generated from oneof cbt.Int64Filter.filter
   */
  filter: {
    /**
     * Equal to value
     *
     * @generated from field: int64 eq = 1;
     */
    value: bigint;
    case: "eq";
  } | {
    /**
     * Not equal to value
     *
     * @generated from field: int64 ne = 2;
     */
    value: bigint;
    case: "ne";
  } | {
    /**
     * Less than value
     *
     * @generated from field: int64 lt = 3;
     */
    value: bigint;
    case: "lt";
  } | {
    /**
     * Less than or equal to value
     *
     * @generated from field: int64 lte = 4;
     */
    value: bigint;
    case: "lte";
  } | {
    /**
     * Greater than value
     *
     * @generated from field: int64 gt = 5;
     */
    value: bigint;
    case: "gt";
  } | {
    /**
     * Greater than or equal to value
     *
     * @generated from field: int64 gte = 6;
     */
    value: bigint;
    case: "gte";
  } | {
    /**
     * Between min and max (inclusive)
     *
     * @generated from field: cbt.Int64Range between = 7;
     */
    value: Int64Range;
    case: "between";
  } | {
    /**
     * In list of values
     *
     * @generated from field: cbt.Int64List in = 8;
     */
    value: Int64List;
    case: "in";
  } | {
    /**
     * Not in list of values
     *
     * @generated from field: cbt.Int64List not_in = 9;
     */
    value: Int64List;
    case: "notIn";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Int64Filter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.Int64Filter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "eq", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "filter" },
    { no: 2, name: "ne", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "filter" },
    { no: 3, name: "lt", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "filter" },
    { no: 4, name: "lte", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "filter" },
    { no: 5, name: "gt", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "filter" },
    { no: 6, name: "gte", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "filter" },
    { no: 7, name: "between", kind: "message", T: Int64Range, oneof: "filter" },
    { no: 8, name: "in", kind: "message", T: Int64List, oneof: "filter" },
    { no: 9, name: "not_in", kind: "message", T: Int64List, oneof: "filter" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int64Filter {
    return new Int64Filter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int64Filter {
    return new Int64Filter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int64Filter {
    return new Int64Filter().fromJsonString(jsonString, options);
  }

  static equals(a: Int64Filter | PlainMessage<Int64Filter> | undefined, b: Int64Filter | PlainMessage<Int64Filter> | undefined): boolean {
    return proto3.util.equals(Int64Filter, a, b);
  }
}

/**
 * NullableInt64Filter represents filtering options for nullable int64 values
 *
 * @generated from message cbt.NullableInt64Filter
 */
export class NullableInt64Filter extends Message<NullableInt64Filter> {
  /**
   * @generated from oneof cbt.NullableInt64Filter.filter
   */
  filter: {
    /**
     * Equal to value
     *
     * @generated from field: int64 eq = 1;
     */
    value: bigint;
    case: "eq";
  } | {
    /**
     * Not equal to value
     *
     * @generated from field: int64 ne = 2;
     */
    value: bigint;
    case: "ne";
  } | {
    /**
     * Less than value
     *
     * @generated from field: int64 lt = 3;
     */
    value: bigint;
    case: "lt";
  } | {
    /**
     * Less than or equal to value
     *
     * @generated from field: int64 lte = 4;
     */
    value: bigint;
    case: "lte";
  } | {
    /**
     * Greater than value
     *
     * @generated from field: int64 gt = 5;
     */
    value: bigint;
    case: "gt";
  } | {
    /**
     * Greater than or equal to value
     *
     * @generated from field: int64 gte = 6;
     */
    value: bigint;
    case: "gte";
  } | {
    /**
     * Between min and max (inclusive)
     *
     * @generated from field: cbt.Int64Range between = 7;
     */
    value: Int64Range;
    case: "between";
  } | {
    /**
     * In list of values
     *
     * @generated from field: cbt.Int64List in = 8;
     */
    value: Int64List;
    case: "in";
  } | {
    /**
     * Not in list of values
     *
     * @generated from field: cbt.Int64List not_in = 9;
     */
    value: Int64List;
    case: "notIn";
  } | {
    /**
     * IS NULL check
     *
     * @generated from field: google.protobuf.Empty is_null = 10;
     */
    value: Empty;
    case: "isNull";
  } | {
    /**
     * IS NOT NULL check
     *
     * @generated from field: google.protobuf.Empty is_not_null = 11;
     */
    value: Empty;
    case: "isNotNull";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<NullableInt64Filter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.NullableInt64Filter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "eq", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "filter" },
    { no: 2, name: "ne", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "filter" },
    { no: 3, name: "lt", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "filter" },
    { no: 4, name: "lte", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "filter" },
    { no: 5, name: "gt", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "filter" },
    { no: 6, name: "gte", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "filter" },
    { no: 7, name: "between", kind: "message", T: Int64Range, oneof: "filter" },
    { no: 8, name: "in", kind: "message", T: Int64List, oneof: "filter" },
    { no: 9, name: "not_in", kind: "message", T: Int64List, oneof: "filter" },
    { no: 10, name: "is_null", kind: "message", T: Empty, oneof: "filter" },
    { no: 11, name: "is_not_null", kind: "message", T: Empty, oneof: "filter" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NullableInt64Filter {
    return new NullableInt64Filter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NullableInt64Filter {
    return new NullableInt64Filter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NullableInt64Filter {
    return new NullableInt64Filter().fromJsonString(jsonString, options);
  }

  static equals(a: NullableInt64Filter | PlainMessage<NullableInt64Filter> | undefined, b: NullableInt64Filter | PlainMessage<NullableInt64Filter> | undefined): boolean {
    return proto3.util.equals(NullableInt64Filter, a, b);
  }
}

/**
 * Int64Range represents a range of int64 values
 *
 * @generated from message cbt.Int64Range
 */
export class Int64Range extends Message<Int64Range> {
  /**
   * @generated from field: int64 min = 1;
   */
  min = protoInt64.zero;

  /**
   * @generated from field: google.protobuf.Int64Value max = 2;
   */
  max?: bigint;

  constructor(data?: PartialMessage<Int64Range>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.Int64Range";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "min", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "max", kind: "message", T: Int64Value },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int64Range {
    return new Int64Range().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int64Range {
    return new Int64Range().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int64Range {
    return new Int64Range().fromJsonString(jsonString, options);
  }

  static equals(a: Int64Range | PlainMessage<Int64Range> | undefined, b: Int64Range | PlainMessage<Int64Range> | undefined): boolean {
    return proto3.util.equals(Int64Range, a, b);
  }
}

/**
 * Int64List represents a list of int64 values
 *
 * @generated from message cbt.Int64List
 */
export class Int64List extends Message<Int64List> {
  /**
   * @generated from field: repeated int64 values = 1;
   */
  values: bigint[] = [];

  constructor(data?: PartialMessage<Int64List>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.Int64List";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Int64List {
    return new Int64List().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Int64List {
    return new Int64List().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Int64List {
    return new Int64List().fromJsonString(jsonString, options);
  }

  static equals(a: Int64List | PlainMessage<Int64List> | undefined, b: Int64List | PlainMessage<Int64List> | undefined): boolean {
    return proto3.util.equals(Int64List, a, b);
  }
}

/**
 * StringFilter represents filtering options for non-nullable string values
 *
 * @generated from message cbt.StringFilter
 */
export class StringFilter extends Message<StringFilter> {
  /**
   * @generated from oneof cbt.StringFilter.filter
   */
  filter: {
    /**
     * Equal to value
     *
     * @generated from field: string eq = 1;
     */
    value: string;
    case: "eq";
  } | {
    /**
     * Not equal to value
     *
     * @generated from field: string ne = 2;
     */
    value: string;
    case: "ne";
  } | {
    /**
     * Contains substring (SQL LIKE '%value%')
     *
     * @generated from field: string contains = 3;
     */
    value: string;
    case: "contains";
  } | {
    /**
     * Starts with prefix (SQL LIKE 'value%')
     *
     * @generated from field: string starts_with = 4;
     */
    value: string;
    case: "startsWith";
  } | {
    /**
     * Ends with suffix (SQL LIKE '%value')
     *
     * @generated from field: string ends_with = 5;
     */
    value: string;
    case: "endsWith";
  } | {
    /**
     * SQL LIKE pattern (% and _ wildcards)
     *
     * @generated from field: string like = 6;
     */
    value: string;
    case: "like";
  } | {
    /**
     * SQL NOT LIKE pattern
     *
     * @generated from field: string not_like = 7;
     */
    value: string;
    case: "notLike";
  } | {
    /**
     * In list of values
     *
     * @generated from field: cbt.StringList in = 8;
     */
    value: StringList;
    case: "in";
  } | {
    /**
     * Not in list of values
     *
     * @generated from field: cbt.StringList not_in = 9;
     */
    value: StringList;
    case: "notIn";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StringFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.StringFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "eq", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 2, name: "ne", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 3, name: "contains", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 4, name: "starts_with", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 5, name: "ends_with", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 6, name: "like", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 7, name: "not_like", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 8, name: "in", kind: "message", T: StringList, oneof: "filter" },
    { no: 9, name: "not_in", kind: "message", T: StringList, oneof: "filter" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringFilter {
    return new StringFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringFilter {
    return new StringFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringFilter {
    return new StringFilter().fromJsonString(jsonString, options);
  }

  static equals(a: StringFilter | PlainMessage<StringFilter> | undefined, b: StringFilter | PlainMessage<StringFilter> | undefined): boolean {
    return proto3.util.equals(StringFilter, a, b);
  }
}

/**
 * NullableStringFilter represents filtering options for nullable string values
 *
 * @generated from message cbt.NullableStringFilter
 */
export class NullableStringFilter extends Message<NullableStringFilter> {
  /**
   * @generated from oneof cbt.NullableStringFilter.filter
   */
  filter: {
    /**
     * Equal to value
     *
     * @generated from field: string eq = 1;
     */
    value: string;
    case: "eq";
  } | {
    /**
     * Not equal to value
     *
     * @generated from field: string ne = 2;
     */
    value: string;
    case: "ne";
  } | {
    /**
     * Contains substring (SQL LIKE '%value%')
     *
     * @generated from field: string contains = 3;
     */
    value: string;
    case: "contains";
  } | {
    /**
     * Starts with prefix (SQL LIKE 'value%')
     *
     * @generated from field: string starts_with = 4;
     */
    value: string;
    case: "startsWith";
  } | {
    /**
     * Ends with suffix (SQL LIKE '%value')
     *
     * @generated from field: string ends_with = 5;
     */
    value: string;
    case: "endsWith";
  } | {
    /**
     * SQL LIKE pattern (% and _ wildcards)
     *
     * @generated from field: string like = 6;
     */
    value: string;
    case: "like";
  } | {
    /**
     * SQL NOT LIKE pattern
     *
     * @generated from field: string not_like = 7;
     */
    value: string;
    case: "notLike";
  } | {
    /**
     * In list of values
     *
     * @generated from field: cbt.StringList in = 8;
     */
    value: StringList;
    case: "in";
  } | {
    /**
     * Not in list of values
     *
     * @generated from field: cbt.StringList not_in = 9;
     */
    value: StringList;
    case: "notIn";
  } | {
    /**
     * IS NULL check
     *
     * @generated from field: google.protobuf.Empty is_null = 10;
     */
    value: Empty;
    case: "isNull";
  } | {
    /**
     * IS NOT NULL check
     *
     * @generated from field: google.protobuf.Empty is_not_null = 11;
     */
    value: Empty;
    case: "isNotNull";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<NullableStringFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.NullableStringFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "eq", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 2, name: "ne", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 3, name: "contains", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 4, name: "starts_with", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 5, name: "ends_with", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 6, name: "like", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 7, name: "not_like", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 8, name: "in", kind: "message", T: StringList, oneof: "filter" },
    { no: 9, name: "not_in", kind: "message", T: StringList, oneof: "filter" },
    { no: 10, name: "is_null", kind: "message", T: Empty, oneof: "filter" },
    { no: 11, name: "is_not_null", kind: "message", T: Empty, oneof: "filter" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NullableStringFilter {
    return new NullableStringFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NullableStringFilter {
    return new NullableStringFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NullableStringFilter {
    return new NullableStringFilter().fromJsonString(jsonString, options);
  }

  static equals(a: NullableStringFilter | PlainMessage<NullableStringFilter> | undefined, b: NullableStringFilter | PlainMessage<NullableStringFilter> | undefined): boolean {
    return proto3.util.equals(NullableStringFilter, a, b);
  }
}

/**
 * StringList represents a list of string values
 *
 * @generated from message cbt.StringList
 */
export class StringList extends Message<StringList> {
  /**
   * @generated from field: repeated string values = 1;
   */
  values: string[] = [];

  constructor(data?: PartialMessage<StringList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.StringList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringList {
    return new StringList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringList {
    return new StringList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringList {
    return new StringList().fromJsonString(jsonString, options);
  }

  static equals(a: StringList | PlainMessage<StringList> | undefined, b: StringList | PlainMessage<StringList> | undefined): boolean {
    return proto3.util.equals(StringList, a, b);
  }
}

/**
 * BoolFilter represents filtering options for non-nullable bool values
 *
 * @generated from message cbt.BoolFilter
 */
export class BoolFilter extends Message<BoolFilter> {
  /**
   * @generated from oneof cbt.BoolFilter.filter
   */
  filter: {
    /**
     * Equal to value
     *
     * @generated from field: bool eq = 1;
     */
    value: boolean;
    case: "eq";
  } | {
    /**
     * Not equal to value
     *
     * @generated from field: bool ne = 2;
     */
    value: boolean;
    case: "ne";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<BoolFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.BoolFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "eq", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "filter" },
    { no: 2, name: "ne", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "filter" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BoolFilter {
    return new BoolFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BoolFilter {
    return new BoolFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BoolFilter {
    return new BoolFilter().fromJsonString(jsonString, options);
  }

  static equals(a: BoolFilter | PlainMessage<BoolFilter> | undefined, b: BoolFilter | PlainMessage<BoolFilter> | undefined): boolean {
    return proto3.util.equals(BoolFilter, a, b);
  }
}

/**
 * NullableBoolFilter represents filtering options for nullable bool values
 *
 * @generated from message cbt.NullableBoolFilter
 */
export class NullableBoolFilter extends Message<NullableBoolFilter> {
  /**
   * @generated from oneof cbt.NullableBoolFilter.filter
   */
  filter: {
    /**
     * Equal to value
     *
     * @generated from field: bool eq = 1;
     */
    value: boolean;
    case: "eq";
  } | {
    /**
     * Not equal to value
     *
     * @generated from field: bool ne = 2;
     */
    value: boolean;
    case: "ne";
  } | {
    /**
     * IS NULL check
     *
     * @generated from field: google.protobuf.Empty is_null = 3;
     */
    value: Empty;
    case: "isNull";
  } | {
    /**
     * IS NOT NULL check
     *
     * @generated from field: google.protobuf.Empty is_not_null = 4;
     */
    value: Empty;
    case: "isNotNull";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<NullableBoolFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.NullableBoolFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "eq", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "filter" },
    { no: 2, name: "ne", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "filter" },
    { no: 3, name: "is_null", kind: "message", T: Empty, oneof: "filter" },
    { no: 4, name: "is_not_null", kind: "message", T: Empty, oneof: "filter" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NullableBoolFilter {
    return new NullableBoolFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NullableBoolFilter {
    return new NullableBoolFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NullableBoolFilter {
    return new NullableBoolFilter().fromJsonString(jsonString, options);
  }

  static equals(a: NullableBoolFilter | PlainMessage<NullableBoolFilter> | undefined, b: NullableBoolFilter | PlainMessage<NullableBoolFilter> | undefined): boolean {
    return proto3.util.equals(NullableBoolFilter, a, b);
  }
}

/**
 * MapKeyValueStringString represents a key-value pair filter for Map(String, String)
 *
 * @generated from message cbt.MapKeyValueStringString
 */
export class MapKeyValueStringString extends Message<MapKeyValueStringString> {
  /**
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * @generated from field: cbt.StringFilter value_filter = 2;
   */
  valueFilter?: StringFilter;

  constructor(data?: PartialMessage<MapKeyValueStringString>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.MapKeyValueStringString";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value_filter", kind: "message", T: StringFilter },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapKeyValueStringString {
    return new MapKeyValueStringString().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapKeyValueStringString {
    return new MapKeyValueStringString().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapKeyValueStringString {
    return new MapKeyValueStringString().fromJsonString(jsonString, options);
  }

  static equals(a: MapKeyValueStringString | PlainMessage<MapKeyValueStringString> | undefined, b: MapKeyValueStringString | PlainMessage<MapKeyValueStringString> | undefined): boolean {
    return proto3.util.equals(MapKeyValueStringString, a, b);
  }
}

/**
 * MapStringStringFilter represents filtering options for Map(String, String) values
 *
 * @generated from message cbt.MapStringStringFilter
 */
export class MapStringStringFilter extends Message<MapStringStringFilter> {
  /**
   * @generated from oneof cbt.MapStringStringFilter.filter
   */
  filter: {
    /**
     * mapColumn['key'] op 'value'
     *
     * @generated from field: cbt.MapKeyValueStringString key_value = 1;
     */
    value: MapKeyValueStringString;
    case: "keyValue";
  } | {
    /**
     * mapContains(mapColumn, 'key')
     *
     * @generated from field: string has_key = 2;
     */
    value: string;
    case: "hasKey";
  } | {
    /**
     * NOT mapContains(mapColumn, 'key')
     *
     * @generated from field: string not_has_key = 3;
     */
    value: string;
    case: "notHasKey";
  } | {
    /**
     * mapContainsAny(mapColumn, ['k1', 'k2'])
     *
     * @generated from field: cbt.StringList has_any_key = 4;
     */
    value: StringList;
    case: "hasAnyKey";
  } | {
    /**
     * mapContainsAll(mapColumn, ['k1', 'k2'])
     *
     * @generated from field: cbt.StringList has_all_keys = 5;
     */
    value: StringList;
    case: "hasAllKeys";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<MapStringStringFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.MapStringStringFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key_value", kind: "message", T: MapKeyValueStringString, oneof: "filter" },
    { no: 2, name: "has_key", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 3, name: "not_has_key", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 4, name: "has_any_key", kind: "message", T: StringList, oneof: "filter" },
    { no: 5, name: "has_all_keys", kind: "message", T: StringList, oneof: "filter" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapStringStringFilter {
    return new MapStringStringFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapStringStringFilter {
    return new MapStringStringFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapStringStringFilter {
    return new MapStringStringFilter().fromJsonString(jsonString, options);
  }

  static equals(a: MapStringStringFilter | PlainMessage<MapStringStringFilter> | undefined, b: MapStringStringFilter | PlainMessage<MapStringStringFilter> | undefined): boolean {
    return proto3.util.equals(MapStringStringFilter, a, b);
  }
}

/**
 * MapKeyValueStringUInt32 represents a key-value pair filter for Map(String, UInt32)
 *
 * @generated from message cbt.MapKeyValueStringUInt32
 */
export class MapKeyValueStringUInt32 extends Message<MapKeyValueStringUInt32> {
  /**
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * @generated from field: cbt.UInt32Filter value_filter = 2;
   */
  valueFilter?: UInt32Filter;

  constructor(data?: PartialMessage<MapKeyValueStringUInt32>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.MapKeyValueStringUInt32";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value_filter", kind: "message", T: UInt32Filter },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapKeyValueStringUInt32 {
    return new MapKeyValueStringUInt32().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapKeyValueStringUInt32 {
    return new MapKeyValueStringUInt32().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapKeyValueStringUInt32 {
    return new MapKeyValueStringUInt32().fromJsonString(jsonString, options);
  }

  static equals(a: MapKeyValueStringUInt32 | PlainMessage<MapKeyValueStringUInt32> | undefined, b: MapKeyValueStringUInt32 | PlainMessage<MapKeyValueStringUInt32> | undefined): boolean {
    return proto3.util.equals(MapKeyValueStringUInt32, a, b);
  }
}

/**
 * MapStringUInt32Filter represents filtering options for Map(String, UInt32) values
 *
 * @generated from message cbt.MapStringUInt32Filter
 */
export class MapStringUInt32Filter extends Message<MapStringUInt32Filter> {
  /**
   * @generated from oneof cbt.MapStringUInt32Filter.filter
   */
  filter: {
    /**
     * mapColumn['key'] op value
     *
     * @generated from field: cbt.MapKeyValueStringUInt32 key_value = 1;
     */
    value: MapKeyValueStringUInt32;
    case: "keyValue";
  } | {
    /**
     * mapContains(mapColumn, 'key')
     *
     * @generated from field: string has_key = 2;
     */
    value: string;
    case: "hasKey";
  } | {
    /**
     * NOT mapContains(mapColumn, 'key')
     *
     * @generated from field: string not_has_key = 3;
     */
    value: string;
    case: "notHasKey";
  } | {
    /**
     * mapContainsAny(mapColumn, ['k1', 'k2'])
     *
     * @generated from field: cbt.StringList has_any_key = 4;
     */
    value: StringList;
    case: "hasAnyKey";
  } | {
    /**
     * mapContainsAll(mapColumn, ['k1', 'k2'])
     *
     * @generated from field: cbt.StringList has_all_keys = 5;
     */
    value: StringList;
    case: "hasAllKeys";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<MapStringUInt32Filter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.MapStringUInt32Filter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key_value", kind: "message", T: MapKeyValueStringUInt32, oneof: "filter" },
    { no: 2, name: "has_key", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 3, name: "not_has_key", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 4, name: "has_any_key", kind: "message", T: StringList, oneof: "filter" },
    { no: 5, name: "has_all_keys", kind: "message", T: StringList, oneof: "filter" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapStringUInt32Filter {
    return new MapStringUInt32Filter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapStringUInt32Filter {
    return new MapStringUInt32Filter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapStringUInt32Filter {
    return new MapStringUInt32Filter().fromJsonString(jsonString, options);
  }

  static equals(a: MapStringUInt32Filter | PlainMessage<MapStringUInt32Filter> | undefined, b: MapStringUInt32Filter | PlainMessage<MapStringUInt32Filter> | undefined): boolean {
    return proto3.util.equals(MapStringUInt32Filter, a, b);
  }
}

/**
 * MapKeyValueStringInt32 represents a key-value pair filter for Map(String, Int32)
 *
 * @generated from message cbt.MapKeyValueStringInt32
 */
export class MapKeyValueStringInt32 extends Message<MapKeyValueStringInt32> {
  /**
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * @generated from field: cbt.Int32Filter value_filter = 2;
   */
  valueFilter?: Int32Filter;

  constructor(data?: PartialMessage<MapKeyValueStringInt32>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.MapKeyValueStringInt32";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value_filter", kind: "message", T: Int32Filter },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapKeyValueStringInt32 {
    return new MapKeyValueStringInt32().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapKeyValueStringInt32 {
    return new MapKeyValueStringInt32().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapKeyValueStringInt32 {
    return new MapKeyValueStringInt32().fromJsonString(jsonString, options);
  }

  static equals(a: MapKeyValueStringInt32 | PlainMessage<MapKeyValueStringInt32> | undefined, b: MapKeyValueStringInt32 | PlainMessage<MapKeyValueStringInt32> | undefined): boolean {
    return proto3.util.equals(MapKeyValueStringInt32, a, b);
  }
}

/**
 * MapStringInt32Filter represents filtering options for Map(String, Int32) values
 *
 * @generated from message cbt.MapStringInt32Filter
 */
export class MapStringInt32Filter extends Message<MapStringInt32Filter> {
  /**
   * @generated from oneof cbt.MapStringInt32Filter.filter
   */
  filter: {
    /**
     * mapColumn['key'] op value
     *
     * @generated from field: cbt.MapKeyValueStringInt32 key_value = 1;
     */
    value: MapKeyValueStringInt32;
    case: "keyValue";
  } | {
    /**
     * mapContains(mapColumn, 'key')
     *
     * @generated from field: string has_key = 2;
     */
    value: string;
    case: "hasKey";
  } | {
    /**
     * NOT mapContains(mapColumn, 'key')
     *
     * @generated from field: string not_has_key = 3;
     */
    value: string;
    case: "notHasKey";
  } | {
    /**
     * mapContainsAny(mapColumn, ['k1', 'k2'])
     *
     * @generated from field: cbt.StringList has_any_key = 4;
     */
    value: StringList;
    case: "hasAnyKey";
  } | {
    /**
     * mapContainsAll(mapColumn, ['k1', 'k2'])
     *
     * @generated from field: cbt.StringList has_all_keys = 5;
     */
    value: StringList;
    case: "hasAllKeys";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<MapStringInt32Filter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.MapStringInt32Filter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key_value", kind: "message", T: MapKeyValueStringInt32, oneof: "filter" },
    { no: 2, name: "has_key", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 3, name: "not_has_key", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 4, name: "has_any_key", kind: "message", T: StringList, oneof: "filter" },
    { no: 5, name: "has_all_keys", kind: "message", T: StringList, oneof: "filter" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapStringInt32Filter {
    return new MapStringInt32Filter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapStringInt32Filter {
    return new MapStringInt32Filter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapStringInt32Filter {
    return new MapStringInt32Filter().fromJsonString(jsonString, options);
  }

  static equals(a: MapStringInt32Filter | PlainMessage<MapStringInt32Filter> | undefined, b: MapStringInt32Filter | PlainMessage<MapStringInt32Filter> | undefined): boolean {
    return proto3.util.equals(MapStringInt32Filter, a, b);
  }
}

/**
 * MapKeyValueStringUInt64 represents a key-value pair filter for Map(String, UInt64)
 *
 * @generated from message cbt.MapKeyValueStringUInt64
 */
export class MapKeyValueStringUInt64 extends Message<MapKeyValueStringUInt64> {
  /**
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * @generated from field: cbt.UInt64Filter value_filter = 2;
   */
  valueFilter?: UInt64Filter;

  constructor(data?: PartialMessage<MapKeyValueStringUInt64>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.MapKeyValueStringUInt64";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value_filter", kind: "message", T: UInt64Filter },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapKeyValueStringUInt64 {
    return new MapKeyValueStringUInt64().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapKeyValueStringUInt64 {
    return new MapKeyValueStringUInt64().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapKeyValueStringUInt64 {
    return new MapKeyValueStringUInt64().fromJsonString(jsonString, options);
  }

  static equals(a: MapKeyValueStringUInt64 | PlainMessage<MapKeyValueStringUInt64> | undefined, b: MapKeyValueStringUInt64 | PlainMessage<MapKeyValueStringUInt64> | undefined): boolean {
    return proto3.util.equals(MapKeyValueStringUInt64, a, b);
  }
}

/**
 * MapStringUInt64Filter represents filtering options for Map(String, UInt64) values
 *
 * @generated from message cbt.MapStringUInt64Filter
 */
export class MapStringUInt64Filter extends Message<MapStringUInt64Filter> {
  /**
   * @generated from oneof cbt.MapStringUInt64Filter.filter
   */
  filter: {
    /**
     * mapColumn['key'] op value
     *
     * @generated from field: cbt.MapKeyValueStringUInt64 key_value = 1;
     */
    value: MapKeyValueStringUInt64;
    case: "keyValue";
  } | {
    /**
     * mapContains(mapColumn, 'key')
     *
     * @generated from field: string has_key = 2;
     */
    value: string;
    case: "hasKey";
  } | {
    /**
     * NOT mapContains(mapColumn, 'key')
     *
     * @generated from field: string not_has_key = 3;
     */
    value: string;
    case: "notHasKey";
  } | {
    /**
     * mapContainsAny(mapColumn, ['k1', 'k2'])
     *
     * @generated from field: cbt.StringList has_any_key = 4;
     */
    value: StringList;
    case: "hasAnyKey";
  } | {
    /**
     * mapContainsAll(mapColumn, ['k1', 'k2'])
     *
     * @generated from field: cbt.StringList has_all_keys = 5;
     */
    value: StringList;
    case: "hasAllKeys";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<MapStringUInt64Filter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.MapStringUInt64Filter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key_value", kind: "message", T: MapKeyValueStringUInt64, oneof: "filter" },
    { no: 2, name: "has_key", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 3, name: "not_has_key", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 4, name: "has_any_key", kind: "message", T: StringList, oneof: "filter" },
    { no: 5, name: "has_all_keys", kind: "message", T: StringList, oneof: "filter" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapStringUInt64Filter {
    return new MapStringUInt64Filter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapStringUInt64Filter {
    return new MapStringUInt64Filter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapStringUInt64Filter {
    return new MapStringUInt64Filter().fromJsonString(jsonString, options);
  }

  static equals(a: MapStringUInt64Filter | PlainMessage<MapStringUInt64Filter> | undefined, b: MapStringUInt64Filter | PlainMessage<MapStringUInt64Filter> | undefined): boolean {
    return proto3.util.equals(MapStringUInt64Filter, a, b);
  }
}

/**
 * MapKeyValueStringInt64 represents a key-value pair filter for Map(String, Int64)
 *
 * @generated from message cbt.MapKeyValueStringInt64
 */
export class MapKeyValueStringInt64 extends Message<MapKeyValueStringInt64> {
  /**
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * @generated from field: cbt.Int64Filter value_filter = 2;
   */
  valueFilter?: Int64Filter;

  constructor(data?: PartialMessage<MapKeyValueStringInt64>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.MapKeyValueStringInt64";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value_filter", kind: "message", T: Int64Filter },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapKeyValueStringInt64 {
    return new MapKeyValueStringInt64().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapKeyValueStringInt64 {
    return new MapKeyValueStringInt64().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapKeyValueStringInt64 {
    return new MapKeyValueStringInt64().fromJsonString(jsonString, options);
  }

  static equals(a: MapKeyValueStringInt64 | PlainMessage<MapKeyValueStringInt64> | undefined, b: MapKeyValueStringInt64 | PlainMessage<MapKeyValueStringInt64> | undefined): boolean {
    return proto3.util.equals(MapKeyValueStringInt64, a, b);
  }
}

/**
 * MapStringInt64Filter represents filtering options for Map(String, Int64) values
 *
 * @generated from message cbt.MapStringInt64Filter
 */
export class MapStringInt64Filter extends Message<MapStringInt64Filter> {
  /**
   * @generated from oneof cbt.MapStringInt64Filter.filter
   */
  filter: {
    /**
     * mapColumn['key'] op value
     *
     * @generated from field: cbt.MapKeyValueStringInt64 key_value = 1;
     */
    value: MapKeyValueStringInt64;
    case: "keyValue";
  } | {
    /**
     * mapContains(mapColumn, 'key')
     *
     * @generated from field: string has_key = 2;
     */
    value: string;
    case: "hasKey";
  } | {
    /**
     * NOT mapContains(mapColumn, 'key')
     *
     * @generated from field: string not_has_key = 3;
     */
    value: string;
    case: "notHasKey";
  } | {
    /**
     * mapContainsAny(mapColumn, ['k1', 'k2'])
     *
     * @generated from field: cbt.StringList has_any_key = 4;
     */
    value: StringList;
    case: "hasAnyKey";
  } | {
    /**
     * mapContainsAll(mapColumn, ['k1', 'k2'])
     *
     * @generated from field: cbt.StringList has_all_keys = 5;
     */
    value: StringList;
    case: "hasAllKeys";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<MapStringInt64Filter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cbt.MapStringInt64Filter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key_value", kind: "message", T: MapKeyValueStringInt64, oneof: "filter" },
    { no: 2, name: "has_key", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 3, name: "not_has_key", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 4, name: "has_any_key", kind: "message", T: StringList, oneof: "filter" },
    { no: 5, name: "has_all_keys", kind: "message", T: StringList, oneof: "filter" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapStringInt64Filter {
    return new MapStringInt64Filter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapStringInt64Filter {
    return new MapStringInt64Filter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapStringInt64Filter {
    return new MapStringInt64Filter().fromJsonString(jsonString, options);
  }

  static equals(a: MapStringInt64Filter | PlainMessage<MapStringInt64Filter> | undefined, b: MapStringInt64Filter | PlainMessage<MapStringInt64Filter> | undefined): boolean {
    return proto3.util.equals(MapStringInt64Filter, a, b);
  }
}

