// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file backend/pkg/server/proto/networks/networks.proto (package networks, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * Network represents an Ethereum network with its metadata.
 *
 * @generated from message networks.Network
 */
export class Network extends Message<Network> {
  /**
   * Full network name (e.g., "mainnet", "sepolia", "fusaka-devnet-0").
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Network status: "active", "inactive", or "unknown".
   *
   * @generated from field: string status = 2;
   */
  status = "";

  /**
   * Ethereum chain ID for this network.
   *
   * @generated from field: int64 chain_id = 3;
   */
  chainId = protoInt64.zero;

  /**
   * ISO 8601 timestamp of when this network metadata was last updated.
   *
   * @generated from field: string last_updated = 4;
   */
  lastUpdated = "";

  constructor(data?: PartialMessage<Network>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "networks.Network";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "chain_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "last_updated", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Network {
    return new Network().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Network {
    return new Network().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Network {
    return new Network().fromJsonString(jsonString, options);
  }

  static equals(a: Network | PlainMessage<Network> | undefined, b: Network | PlainMessage<Network> | undefined): boolean {
    return proto3.util.equals(Network, a, b);
  }
}

/**
 * ListNetworksRequest defines filters for listing networks.
 *
 * @generated from message networks.ListNetworksRequest
 */
export class ListNetworksRequest extends Message<ListNetworksRequest> {
  /**
   * If true, only return networks with status="active".
   *
   * @generated from field: bool active_only = 1;
   */
  activeOnly = false;

  constructor(data?: PartialMessage<ListNetworksRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "networks.ListNetworksRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "active_only", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListNetworksRequest {
    return new ListNetworksRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListNetworksRequest {
    return new ListNetworksRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListNetworksRequest {
    return new ListNetworksRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListNetworksRequest | PlainMessage<ListNetworksRequest> | undefined, b: ListNetworksRequest | PlainMessage<ListNetworksRequest> | undefined): boolean {
    return proto3.util.equals(ListNetworksRequest, a, b);
  }
}

/**
 * ListNetworksResponse contains the filtered list of networks and metadata.
 *
 * @generated from message networks.ListNetworksResponse
 */
export class ListNetworksResponse extends Message<ListNetworksResponse> {
  /**
   * List of networks matching the filter criteria.
   *
   * @generated from field: repeated networks.Network networks = 1;
   */
  networks: Network[] = [];

  /**
   * Metadata about the filtering operation.
   *
   * @generated from field: networks.FilterMetadata filters = 2;
   */
  filters?: FilterMetadata;

  constructor(data?: PartialMessage<ListNetworksResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "networks.ListNetworksResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "networks", kind: "message", T: Network, repeated: true },
    { no: 2, name: "filters", kind: "message", T: FilterMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListNetworksResponse {
    return new ListNetworksResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListNetworksResponse {
    return new ListNetworksResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListNetworksResponse {
    return new ListNetworksResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListNetworksResponse | PlainMessage<ListNetworksResponse> | undefined, b: ListNetworksResponse | PlainMessage<ListNetworksResponse> | undefined): boolean {
    return proto3.util.equals(ListNetworksResponse, a, b);
  }
}

/**
 * FilterMetadata provides information about the filtering operation.
 *
 * @generated from message networks.FilterMetadata
 */
export class FilterMetadata extends Message<FilterMetadata> {
  /**
   * List of filters that were applied (e.g., ["active_only"]).
   *
   * @generated from field: repeated string applied_filters = 1;
   */
  appliedFilters: string[] = [];

  /**
   * Total number of networks before filtering.
   *
   * @generated from field: int32 total_count = 2;
   */
  totalCount = 0;

  /**
   * Number of networks after filtering.
   *
   * @generated from field: int32 filtered_count = 3;
   */
  filteredCount = 0;

  constructor(data?: PartialMessage<FilterMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "networks.FilterMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "applied_filters", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "total_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "filtered_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilterMetadata {
    return new FilterMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilterMetadata {
    return new FilterMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilterMetadata {
    return new FilterMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: FilterMetadata | PlainMessage<FilterMetadata> | undefined, b: FilterMetadata | PlainMessage<FilterMetadata> | undefined): boolean {
    return proto3.util.equals(FilterMetadata, a, b);
  }
}

/**
 * GetNetworkRequest specifies which network to retrieve.
 *
 * @generated from message networks.GetNetworkRequest
 */
export class GetNetworkRequest extends Message<GetNetworkRequest> {
  /**
   * Name of the network to retrieve (case-insensitive).
   *
   * @generated from field: string network_name = 1;
   */
  networkName = "";

  constructor(data?: PartialMessage<GetNetworkRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "networks.GetNetworkRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "network_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetNetworkRequest {
    return new GetNetworkRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetNetworkRequest {
    return new GetNetworkRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetNetworkRequest {
    return new GetNetworkRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetNetworkRequest | PlainMessage<GetNetworkRequest> | undefined, b: GetNetworkRequest | PlainMessage<GetNetworkRequest> | undefined): boolean {
    return proto3.util.equals(GetNetworkRequest, a, b);
  }
}

/**
 * GetNetworkResponse contains the requested network information.
 *
 * @generated from message networks.GetNetworkResponse
 */
export class GetNetworkResponse extends Message<GetNetworkResponse> {
  /**
   * The requested network, or null if not found.
   *
   * @generated from field: networks.Network network = 1;
   */
  network?: Network;

  constructor(data?: PartialMessage<GetNetworkResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "networks.GetNetworkResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "network", kind: "message", T: Network },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetNetworkResponse {
    return new GetNetworkResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetNetworkResponse {
    return new GetNetworkResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetNetworkResponse {
    return new GetNetworkResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetNetworkResponse | PlainMessage<GetNetworkResponse> | undefined, b: GetNetworkResponse | PlainMessage<GetNetworkResponse> | undefined): boolean {
    return proto3.util.equals(GetNetworkResponse, a, b);
  }
}

/**
 * NetworksData represents the complete network data from cartographoor.
 * This is used internally by the service to store the fetched data.
 *
 * @generated from message networks.NetworksData
 */
export class NetworksData extends Message<NetworksData> {
  /**
   * ISO 8601 timestamp of when this data was generated.
   *
   * @generated from field: string generated = 1;
   */
  generated = "";

  /**
   * Map of network name to network data.
   *
   * @generated from field: map<string, networks.Network> networks = 2;
   */
  networks: { [key: string]: Network } = {};

  constructor(data?: PartialMessage<NetworksData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "networks.NetworksData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "generated", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "networks", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Network} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NetworksData {
    return new NetworksData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NetworksData {
    return new NetworksData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NetworksData {
    return new NetworksData().fromJsonString(jsonString, options);
  }

  static equals(a: NetworksData | PlainMessage<NetworksData> | undefined, b: NetworksData | PlainMessage<NetworksData> | undefined): boolean {
    return proto3.util.equals(NetworksData, a, b);
  }
}

/**
 * RawNetworkData represents the raw network data from cartographoor JSON.
 * Used for unmarshaling the cartographoor API response.
 *
 * @generated from message networks.RawNetworkData
 */
export class RawNetworkData extends Message<RawNetworkData> {
  /**
   * Network suffix name (e.g., "devnet-0" without prefix).
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Network status: "active", "inactive", or "unknown".
   *
   * @generated from field: string status = 2;
   */
  status = "";

  /**
   * ISO 8601 timestamp of last update.
   *
   * @generated from field: string last_updated = 3;
   */
  lastUpdated = "";

  /**
   * Ethereum chain ID.
   *
   * @generated from field: int64 chain_id = 4;
   */
  chainId = protoInt64.zero;

  constructor(data?: PartialMessage<RawNetworkData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "networks.RawNetworkData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "last_updated", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "chain_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RawNetworkData {
    return new RawNetworkData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RawNetworkData {
    return new RawNetworkData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RawNetworkData {
    return new RawNetworkData().fromJsonString(jsonString, options);
  }

  static equals(a: RawNetworkData | PlainMessage<RawNetworkData> | undefined, b: RawNetworkData | PlainMessage<RawNetworkData> | undefined): boolean {
    return proto3.util.equals(RawNetworkData, a, b);
  }
}

/**
 * CartographoorResponse represents the raw cartographoor API response.
 * This matches the exact JSON structure from the API.
 *
 * @generated from message networks.CartographoorResponse
 */
export class CartographoorResponse extends Message<CartographoorResponse> {
  /**
   * ISO 8601 timestamp of when this data was generated.
   *
   * @generated from field: string generated = 1;
   */
  generated = "";

  /**
   * Map of full network name to raw network data.
   *
   * @generated from field: map<string, networks.RawNetworkData> networks = 2;
   */
  networks: { [key: string]: RawNetworkData } = {};

  constructor(data?: PartialMessage<CartographoorResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "networks.CartographoorResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "generated", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "networks", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: RawNetworkData} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CartographoorResponse {
    return new CartographoorResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CartographoorResponse {
    return new CartographoorResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CartographoorResponse {
    return new CartographoorResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CartographoorResponse | PlainMessage<CartographoorResponse> | undefined, b: CartographoorResponse | PlainMessage<CartographoorResponse> | undefined): boolean {
    return proto3.util.equals(CartographoorResponse, a, b);
  }
}

