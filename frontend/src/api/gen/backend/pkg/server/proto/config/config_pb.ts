// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file backend/pkg/server/proto/config/config.proto (package config, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * GetConfigRequest is empty for now but allows future expansion
 *
 * @generated from message config.GetConfigRequest
 */
export class GetConfigRequest extends Message<GetConfigRequest> {
  constructor(data?: PartialMessage<GetConfigRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.GetConfigRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConfigRequest {
    return new GetConfigRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConfigRequest {
    return new GetConfigRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConfigRequest {
    return new GetConfigRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConfigRequest | PlainMessage<GetConfigRequest> | undefined, b: GetConfigRequest | PlainMessage<GetConfigRequest> | undefined): boolean {
    return proto3.util.equals(GetConfigRequest, a, b);
  }
}

/**
 * GetConfigResponse contains the complete configuration
 *
 * @generated from message config.GetConfigResponse
 */
export class GetConfigResponse extends Message<GetConfigResponse> {
  /**
   * The main configuration object
   *
   * @generated from field: config.FrontendConfig config = 1;
   */
  config?: FrontendConfig;

  constructor(data?: PartialMessage<GetConfigResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.GetConfigResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "config", kind: "message", T: FrontendConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConfigResponse {
    return new GetConfigResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConfigResponse {
    return new GetConfigResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConfigResponse {
    return new GetConfigResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConfigResponse | PlainMessage<GetConfigResponse> | undefined, b: GetConfigResponse | PlainMessage<GetConfigResponse> | undefined): boolean {
    return proto3.util.equals(GetConfigResponse, a, b);
  }
}

/**
 * FrontendConfig represents the complete frontend configuration
 *
 * @generated from message config.FrontendConfig
 */
export class FrontendConfig extends Message<FrontendConfig> {
  /**
   * Ethereum configuration including networks
   *
   * @generated from field: config.EthereumConfig ethereum = 1;
   */
  ethereum?: EthereumConfig;

  /**
   * Module configurations
   *
   * @generated from field: config.ModulesConfig modules = 2;
   */
  modules?: ModulesConfig;

  constructor(data?: PartialMessage<FrontendConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.FrontendConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ethereum", kind: "message", T: EthereumConfig },
    { no: 2, name: "modules", kind: "message", T: ModulesConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FrontendConfig {
    return new FrontendConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FrontendConfig {
    return new FrontendConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FrontendConfig {
    return new FrontendConfig().fromJsonString(jsonString, options);
  }

  static equals(a: FrontendConfig | PlainMessage<FrontendConfig> | undefined, b: FrontendConfig | PlainMessage<FrontendConfig> | undefined): boolean {
    return proto3.util.equals(FrontendConfig, a, b);
  }
}

/**
 * EthereumConfig contains Ethereum-related configuration
 *
 * @generated from message config.EthereumConfig
 */
export class EthereumConfig extends Message<EthereumConfig> {
  /**
   * Map of network name to network configuration
   *
   * @generated from field: map<string, config.NetworkConfig> networks = 1;
   */
  networks: { [key: string]: NetworkConfig } = {};

  constructor(data?: PartialMessage<EthereumConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.EthereumConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "networks", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: NetworkConfig} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EthereumConfig {
    return new EthereumConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EthereumConfig {
    return new EthereumConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EthereumConfig {
    return new EthereumConfig().fromJsonString(jsonString, options);
  }

  static equals(a: EthereumConfig | PlainMessage<EthereumConfig> | undefined, b: EthereumConfig | PlainMessage<EthereumConfig> | undefined): boolean {
    return proto3.util.equals(EthereumConfig, a, b);
  }
}

/**
 * NetworkConfig represents configuration for a single network
 *
 * @generated from message config.NetworkConfig
 */
export class NetworkConfig extends Message<NetworkConfig> {
  /**
   * Network name
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Network status
   *
   * @generated from field: string status = 2;
   */
  status = "";

  /**
   * Chain ID
   *
   * @generated from field: int64 chain_id = 3;
   */
  chainId = protoInt64.zero;

  /**
   * Description
   *
   * @generated from field: string description = 4;
   */
  description = "";

  /**
   * Genesis time as Unix timestamp
   *
   * @generated from field: int64 genesis_time = 5;
   */
  genesisTime = protoInt64.zero;

  /**
   * Service URLs
   *
   * @generated from field: map<string, string> service_urls = 6;
   */
  serviceUrls: { [key: string]: string } = {};

  /**
   * Fork information
   *
   * @generated from field: config.ForkConfig forks = 7;
   */
  forks?: ForkConfig;

  /**
   * Last updated timestamp
   *
   * @generated from field: string last_updated = 8;
   */
  lastUpdated = "";

  constructor(data?: PartialMessage<NetworkConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.NetworkConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "chain_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "genesis_time", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "service_urls", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 7, name: "forks", kind: "message", T: ForkConfig },
    { no: 8, name: "last_updated", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NetworkConfig {
    return new NetworkConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NetworkConfig {
    return new NetworkConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NetworkConfig {
    return new NetworkConfig().fromJsonString(jsonString, options);
  }

  static equals(a: NetworkConfig | PlainMessage<NetworkConfig> | undefined, b: NetworkConfig | PlainMessage<NetworkConfig> | undefined): boolean {
    return proto3.util.equals(NetworkConfig, a, b);
  }
}

/**
 * ForkConfig contains fork information
 *
 * @generated from message config.ForkConfig
 */
export class ForkConfig extends Message<ForkConfig> {
  /**
   * Consensus layer forks
   *
   * @generated from field: config.ConsensusForks consensus = 1;
   */
  consensus?: ConsensusForks;

  constructor(data?: PartialMessage<ForkConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.ForkConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "consensus", kind: "message", T: ConsensusForks },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ForkConfig {
    return new ForkConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ForkConfig {
    return new ForkConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ForkConfig {
    return new ForkConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ForkConfig | PlainMessage<ForkConfig> | undefined, b: ForkConfig | PlainMessage<ForkConfig> | undefined): boolean {
    return proto3.util.equals(ForkConfig, a, b);
  }
}

/**
 * ConsensusForks contains consensus layer fork information
 *
 * @generated from message config.ConsensusForks
 */
export class ConsensusForks extends Message<ConsensusForks> {
  /**
   * Electra fork info
   *
   * @generated from field: config.ForkInfo electra = 1;
   */
  electra?: ForkInfo;

  constructor(data?: PartialMessage<ConsensusForks>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.ConsensusForks";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "electra", kind: "message", T: ForkInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConsensusForks {
    return new ConsensusForks().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConsensusForks {
    return new ConsensusForks().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConsensusForks {
    return new ConsensusForks().fromJsonString(jsonString, options);
  }

  static equals(a: ConsensusForks | PlainMessage<ConsensusForks> | undefined, b: ConsensusForks | PlainMessage<ConsensusForks> | undefined): boolean {
    return proto3.util.equals(ConsensusForks, a, b);
  }
}

/**
 * ForkInfo contains information about a specific fork
 *
 * @generated from message config.ForkInfo
 */
export class ForkInfo extends Message<ForkInfo> {
  /**
   * Epoch when the fork activates
   *
   * @generated from field: int64 epoch = 1;
   */
  epoch = protoInt64.zero;

  /**
   * Minimum client versions
   *
   * @generated from field: map<string, string> min_client_versions = 2;
   */
  minClientVersions: { [key: string]: string } = {};

  constructor(data?: PartialMessage<ForkInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.ForkInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "epoch", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "min_client_versions", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ForkInfo {
    return new ForkInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ForkInfo {
    return new ForkInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ForkInfo {
    return new ForkInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ForkInfo | PlainMessage<ForkInfo> | undefined, b: ForkInfo | PlainMessage<ForkInfo> | undefined): boolean {
    return proto3.util.equals(ForkInfo, a, b);
  }
}

/**
 * ModulesConfig contains all module configurations
 *
 * @generated from message config.ModulesConfig
 */
export class ModulesConfig extends Message<ModulesConfig> {
  /**
   * Beacon chain timings module
   *
   * @generated from field: config.BeaconChainTimingsModule beacon_chain_timings = 1;
   */
  beaconChainTimings?: BeaconChainTimingsModule;

  /**
   * Xatu public contributors module
   *
   * @generated from field: config.XatuPublicContributorsModule xatu_public_contributors = 2;
   */
  xatuPublicContributors?: XatuPublicContributorsModule;

  /**
   * Beacon module
   *
   * @generated from field: config.BeaconModule beacon = 3;
   */
  beacon?: BeaconModule;

  constructor(data?: PartialMessage<ModulesConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.ModulesConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "beacon_chain_timings", kind: "message", T: BeaconChainTimingsModule },
    { no: 2, name: "xatu_public_contributors", kind: "message", T: XatuPublicContributorsModule },
    { no: 3, name: "beacon", kind: "message", T: BeaconModule },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModulesConfig {
    return new ModulesConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModulesConfig {
    return new ModulesConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModulesConfig {
    return new ModulesConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ModulesConfig | PlainMessage<ModulesConfig> | undefined, b: ModulesConfig | PlainMessage<ModulesConfig> | undefined): boolean {
    return proto3.util.equals(ModulesConfig, a, b);
  }
}

/**
 * BeaconChainTimingsModule configuration
 *
 * @generated from message config.BeaconChainTimingsModule
 */
export class BeaconChainTimingsModule extends Message<BeaconChainTimingsModule> {
  /**
   * List of networks this module supports
   *
   * @generated from field: repeated string networks = 1;
   */
  networks: string[] = [];

  /**
   * Time windows configuration
   *
   * @generated from field: repeated config.TimeWindow time_windows = 2;
   */
  timeWindows: TimeWindow[] = [];

  /**
   * Path prefix for data files
   *
   * @generated from field: string path_prefix = 3;
   */
  pathPrefix = "";

  constructor(data?: PartialMessage<BeaconChainTimingsModule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.BeaconChainTimingsModule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "networks", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "time_windows", kind: "message", T: TimeWindow, repeated: true },
    { no: 3, name: "path_prefix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BeaconChainTimingsModule {
    return new BeaconChainTimingsModule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BeaconChainTimingsModule {
    return new BeaconChainTimingsModule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BeaconChainTimingsModule {
    return new BeaconChainTimingsModule().fromJsonString(jsonString, options);
  }

  static equals(a: BeaconChainTimingsModule | PlainMessage<BeaconChainTimingsModule> | undefined, b: BeaconChainTimingsModule | PlainMessage<BeaconChainTimingsModule> | undefined): boolean {
    return proto3.util.equals(BeaconChainTimingsModule, a, b);
  }
}

/**
 * XatuPublicContributorsModule configuration
 *
 * @generated from message config.XatuPublicContributorsModule
 */
export class XatuPublicContributorsModule extends Message<XatuPublicContributorsModule> {
  /**
   * List of networks this module supports
   *
   * @generated from field: repeated string networks = 1;
   */
  networks: string[] = [];

  /**
   * Time windows configuration
   *
   * @generated from field: repeated config.TimeWindow time_windows = 2;
   */
  timeWindows: TimeWindow[] = [];

  /**
   * Path prefix for data files
   *
   * @generated from field: string path_prefix = 3;
   */
  pathPrefix = "";

  /**
   * Whether the module is enabled
   *
   * @generated from field: bool enabled = 4;
   */
  enabled = false;

  constructor(data?: PartialMessage<XatuPublicContributorsModule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.XatuPublicContributorsModule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "networks", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "time_windows", kind: "message", T: TimeWindow, repeated: true },
    { no: 3, name: "path_prefix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): XatuPublicContributorsModule {
    return new XatuPublicContributorsModule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): XatuPublicContributorsModule {
    return new XatuPublicContributorsModule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): XatuPublicContributorsModule {
    return new XatuPublicContributorsModule().fromJsonString(jsonString, options);
  }

  static equals(a: XatuPublicContributorsModule | PlainMessage<XatuPublicContributorsModule> | undefined, b: XatuPublicContributorsModule | PlainMessage<XatuPublicContributorsModule> | undefined): boolean {
    return proto3.util.equals(XatuPublicContributorsModule, a, b);
  }
}

/**
 * BeaconModule configuration
 *
 * @generated from message config.BeaconModule
 */
export class BeaconModule extends Message<BeaconModule> {
  /**
   * Whether the module is enabled
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * Description
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * Path prefix for data files
   *
   * @generated from field: string path_prefix = 3;
   */
  pathPrefix = "";

  /**
   * Per-network configuration
   *
   * @generated from field: map<string, config.BeaconNetworkConfig> networks = 4;
   */
  networks: { [key: string]: BeaconNetworkConfig } = {};

  constructor(data?: PartialMessage<BeaconModule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.BeaconModule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "path_prefix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "networks", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: BeaconNetworkConfig} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BeaconModule {
    return new BeaconModule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BeaconModule {
    return new BeaconModule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BeaconModule {
    return new BeaconModule().fromJsonString(jsonString, options);
  }

  static equals(a: BeaconModule | PlainMessage<BeaconModule> | undefined, b: BeaconModule | PlainMessage<BeaconModule> | undefined): boolean {
    return proto3.util.equals(BeaconModule, a, b);
  }
}

/**
 * BeaconNetworkConfig contains beacon-specific network configuration
 *
 * @generated from message config.BeaconNetworkConfig
 */
export class BeaconNetworkConfig extends Message<BeaconNetworkConfig> {
  /**
   * Head lag slots
   *
   * @generated from field: int32 head_lag_slots = 1;
   */
  headLagSlots = 0;

  /**
   * Backlog days
   *
   * @generated from field: int32 backlog_days = 2;
   */
  backlogDays = 0;

  constructor(data?: PartialMessage<BeaconNetworkConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.BeaconNetworkConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "head_lag_slots", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "backlog_days", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BeaconNetworkConfig {
    return new BeaconNetworkConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BeaconNetworkConfig {
    return new BeaconNetworkConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BeaconNetworkConfig {
    return new BeaconNetworkConfig().fromJsonString(jsonString, options);
  }

  static equals(a: BeaconNetworkConfig | PlainMessage<BeaconNetworkConfig> | undefined, b: BeaconNetworkConfig | PlainMessage<BeaconNetworkConfig> | undefined): boolean {
    return proto3.util.equals(BeaconNetworkConfig, a, b);
  }
}

/**
 * TimeWindow represents a time window configuration
 *
 * @generated from message config.TimeWindow
 */
export class TimeWindow extends Message<TimeWindow> {
  /**
   * File identifier
   *
   * @generated from field: string file = 1;
   */
  file = "";

  /**
   * Step interval
   *
   * @generated from field: string step = 2;
   */
  step = "";

  /**
   * Time range
   *
   * @generated from field: string range = 3;
   */
  range = "";

  /**
   * Display label
   *
   * @generated from field: string label = 4;
   */
  label = "";

  constructor(data?: PartialMessage<TimeWindow>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.TimeWindow";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "file", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "step", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "range", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "label", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeWindow {
    return new TimeWindow().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeWindow {
    return new TimeWindow().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeWindow {
    return new TimeWindow().fromJsonString(jsonString, options);
  }

  static equals(a: TimeWindow | PlainMessage<TimeWindow> | undefined, b: TimeWindow | PlainMessage<TimeWindow> | undefined): boolean {
    return proto3.util.equals(TimeWindow, a, b);
  }
}

