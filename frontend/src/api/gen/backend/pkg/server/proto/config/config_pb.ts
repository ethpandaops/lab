// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file backend/pkg/server/proto/config/config.proto (package config, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Struct } from "@bufbuild/protobuf";

/**
 * GetConfigRequest is empty for now but allows future expansion
 *
 * @generated from message config.GetConfigRequest
 */
export class GetConfigRequest extends Message<GetConfigRequest> {
  constructor(data?: PartialMessage<GetConfigRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.GetConfigRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConfigRequest {
    return new GetConfigRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConfigRequest {
    return new GetConfigRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConfigRequest {
    return new GetConfigRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConfigRequest | PlainMessage<GetConfigRequest> | undefined, b: GetConfigRequest | PlainMessage<GetConfigRequest> | undefined): boolean {
    return proto3.util.equals(GetConfigRequest, a, b);
  }
}

/**
 * GetConfigResponse contains the complete configuration
 *
 * @generated from message config.GetConfigResponse
 */
export class GetConfigResponse extends Message<GetConfigResponse> {
  /**
   * The main configuration object
   *
   * @generated from field: config.FrontendConfig config = 1;
   */
  config?: FrontendConfig;

  constructor(data?: PartialMessage<GetConfigResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.GetConfigResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "config", kind: "message", T: FrontendConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConfigResponse {
    return new GetConfigResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConfigResponse {
    return new GetConfigResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConfigResponse {
    return new GetConfigResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConfigResponse | PlainMessage<GetConfigResponse> | undefined, b: GetConfigResponse | PlainMessage<GetConfigResponse> | undefined): boolean {
    return proto3.util.equals(GetConfigResponse, a, b);
  }
}

/**
 * FrontendConfig represents the complete frontend configuration
 *
 * @generated from message config.FrontendConfig
 */
export class FrontendConfig extends Message<FrontendConfig> {
  /**
   * Ethereum configuration including networks
   *
   * @generated from field: config.EthereumConfig ethereum = 1;
   */
  ethereum?: EthereumConfig;

  /**
   * List of experiments
   *
   * @generated from field: repeated config.ExperimentConfig experiments = 2;
   */
  experiments: ExperimentConfig[] = [];

  constructor(data?: PartialMessage<FrontendConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.FrontendConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ethereum", kind: "message", T: EthereumConfig },
    { no: 2, name: "experiments", kind: "message", T: ExperimentConfig, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FrontendConfig {
    return new FrontendConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FrontendConfig {
    return new FrontendConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FrontendConfig {
    return new FrontendConfig().fromJsonString(jsonString, options);
  }

  static equals(a: FrontendConfig | PlainMessage<FrontendConfig> | undefined, b: FrontendConfig | PlainMessage<FrontendConfig> | undefined): boolean {
    return proto3.util.equals(FrontendConfig, a, b);
  }
}

/**
 * EthereumConfig contains Ethereum-related configuration
 *
 * @generated from message config.EthereumConfig
 */
export class EthereumConfig extends Message<EthereumConfig> {
  /**
   * Map of network name to network configuration
   *
   * @generated from field: map<string, config.NetworkConfig> networks = 1;
   */
  networks: { [key: string]: NetworkConfig } = {};

  constructor(data?: PartialMessage<EthereumConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.EthereumConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "networks", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: NetworkConfig} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EthereumConfig {
    return new EthereumConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EthereumConfig {
    return new EthereumConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EthereumConfig {
    return new EthereumConfig().fromJsonString(jsonString, options);
  }

  static equals(a: EthereumConfig | PlainMessage<EthereumConfig> | undefined, b: EthereumConfig | PlainMessage<EthereumConfig> | undefined): boolean {
    return proto3.util.equals(EthereumConfig, a, b);
  }
}

/**
 * NetworkConfig represents configuration for a single network
 *
 * @generated from message config.NetworkConfig
 */
export class NetworkConfig extends Message<NetworkConfig> {
  /**
   * Network name
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Network status
   *
   * @generated from field: string status = 2;
   */
  status = "";

  /**
   * Chain ID
   *
   * @generated from field: int64 chain_id = 3;
   */
  chainId = protoInt64.zero;

  /**
   * Description
   *
   * @generated from field: string description = 4;
   */
  description = "";

  /**
   * Genesis time as Unix timestamp
   *
   * @generated from field: int64 genesis_time = 5;
   */
  genesisTime = protoInt64.zero;

  /**
   * Fork information
   *
   * @generated from field: config.ForkConfig forks = 6;
   */
  forks?: ForkConfig;

  /**
   * Last updated timestamp
   *
   * @generated from field: string last_updated = 7;
   */
  lastUpdated = "";

  constructor(data?: PartialMessage<NetworkConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.NetworkConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "chain_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "genesis_time", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "forks", kind: "message", T: ForkConfig },
    { no: 7, name: "last_updated", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NetworkConfig {
    return new NetworkConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NetworkConfig {
    return new NetworkConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NetworkConfig {
    return new NetworkConfig().fromJsonString(jsonString, options);
  }

  static equals(a: NetworkConfig | PlainMessage<NetworkConfig> | undefined, b: NetworkConfig | PlainMessage<NetworkConfig> | undefined): boolean {
    return proto3.util.equals(NetworkConfig, a, b);
  }
}

/**
 * ForkConfig contains fork information
 *
 * @generated from message config.ForkConfig
 */
export class ForkConfig extends Message<ForkConfig> {
  /**
   * Consensus layer forks
   *
   * @generated from field: config.ConsensusForks consensus = 1;
   */
  consensus?: ConsensusForks;

  constructor(data?: PartialMessage<ForkConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.ForkConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "consensus", kind: "message", T: ConsensusForks },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ForkConfig {
    return new ForkConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ForkConfig {
    return new ForkConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ForkConfig {
    return new ForkConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ForkConfig | PlainMessage<ForkConfig> | undefined, b: ForkConfig | PlainMessage<ForkConfig> | undefined): boolean {
    return proto3.util.equals(ForkConfig, a, b);
  }
}

/**
 * ConsensusForks contains consensus layer fork information
 *
 * @generated from message config.ConsensusForks
 */
export class ConsensusForks extends Message<ConsensusForks> {
  /**
   * Electra fork info
   *
   * @generated from field: config.ForkInfo electra = 1;
   */
  electra?: ForkInfo;

  /**
   * Fusaka fork info
   *
   * @generated from field: config.ForkInfo fusaka = 2;
   */
  fusaka?: ForkInfo;

  constructor(data?: PartialMessage<ConsensusForks>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.ConsensusForks";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "electra", kind: "message", T: ForkInfo },
    { no: 2, name: "fusaka", kind: "message", T: ForkInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConsensusForks {
    return new ConsensusForks().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConsensusForks {
    return new ConsensusForks().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConsensusForks {
    return new ConsensusForks().fromJsonString(jsonString, options);
  }

  static equals(a: ConsensusForks | PlainMessage<ConsensusForks> | undefined, b: ConsensusForks | PlainMessage<ConsensusForks> | undefined): boolean {
    return proto3.util.equals(ConsensusForks, a, b);
  }
}

/**
 * ForkInfo contains information about a specific fork
 *
 * @generated from message config.ForkInfo
 */
export class ForkInfo extends Message<ForkInfo> {
  /**
   * Epoch when the fork activates
   *
   * @generated from field: int64 epoch = 1;
   */
  epoch = protoInt64.zero;

  /**
   * Minimum client versions
   *
   * @generated from field: map<string, string> min_client_versions = 2;
   */
  minClientVersions: { [key: string]: string } = {};

  constructor(data?: PartialMessage<ForkInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.ForkInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "epoch", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "min_client_versions", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ForkInfo {
    return new ForkInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ForkInfo {
    return new ForkInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ForkInfo {
    return new ForkInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ForkInfo | PlainMessage<ForkInfo> | undefined, b: ForkInfo | PlainMessage<ForkInfo> | undefined): boolean {
    return proto3.util.equals(ForkInfo, a, b);
  }
}

/**
 * ExperimentsConfig contains all experiments configuration
 *
 * @generated from message config.ExperimentsConfig
 */
export class ExperimentsConfig extends Message<ExperimentsConfig> {
  /**
   * List of available experiments
   *
   * @generated from field: repeated config.ExperimentConfig experiments = 1;
   */
  experiments: ExperimentConfig[] = [];

  constructor(data?: PartialMessage<ExperimentsConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.ExperimentsConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "experiments", kind: "message", T: ExperimentConfig, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExperimentsConfig {
    return new ExperimentsConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExperimentsConfig {
    return new ExperimentsConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExperimentsConfig {
    return new ExperimentsConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ExperimentsConfig | PlainMessage<ExperimentsConfig> | undefined, b: ExperimentsConfig | PlainMessage<ExperimentsConfig> | undefined): boolean {
    return proto3.util.equals(ExperimentsConfig, a, b);
  }
}

/**
 * ExperimentConfig represents a single experiment
 *
 * @generated from message config.ExperimentConfig
 */
export class ExperimentConfig extends Message<ExperimentConfig> {
  /**
   * Unique identifier for the experiment
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Whether this experiment is enabled
   *
   * @generated from field: bool enabled = 2;
   */
  enabled = false;

  /**
   * Networks this experiment supports
   *
   * @generated from field: repeated string networks = 3;
   */
  networks: string[] = [];

  /**
   * Data availability per network
   *
   * @generated from field: map<string, config.ExperimentDataAvailability> data_availability = 4;
   */
  dataAvailability: { [key: string]: ExperimentDataAvailability } = {};

  /**
   * Experiment-specific configuration
   *
   * @generated from field: google.protobuf.Struct config = 5;
   */
  config?: Struct;

  constructor(data?: PartialMessage<ExperimentConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.ExperimentConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "networks", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "data_availability", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: ExperimentDataAvailability} },
    { no: 5, name: "config", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExperimentConfig {
    return new ExperimentConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExperimentConfig {
    return new ExperimentConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExperimentConfig {
    return new ExperimentConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ExperimentConfig | PlainMessage<ExperimentConfig> | undefined, b: ExperimentConfig | PlainMessage<ExperimentConfig> | undefined): boolean {
    return proto3.util.equals(ExperimentConfig, a, b);
  }
}

/**
 * ExperimentDataAvailability contains data availability information for an experiment on a specific network
 *
 * @generated from message config.ExperimentDataAvailability
 */
export class ExperimentDataAvailability extends Message<ExperimentDataAvailability> {
  /**
   * Unix timestamp (seconds) of the earliest available data
   *
   * @generated from field: int64 available_from_timestamp = 1;
   */
  availableFromTimestamp = protoInt64.zero;

  /**
   * Unix timestamp (seconds) of the latest available data
   *
   * @generated from field: int64 available_until_timestamp = 2;
   */
  availableUntilTimestamp = protoInt64.zero;

  /**
   * Earliest available slot number
   *
   * @generated from field: uint64 min_slot = 3;
   */
  minSlot = protoInt64.zero;

  /**
   * Latest available slot number
   *
   * @generated from field: uint64 max_slot = 4;
   */
  maxSlot = protoInt64.zero;

  /**
   * Safe slot for "live" view (head - 2 slots)
   *
   * @generated from field: uint64 safe_slot = 5;
   */
  safeSlot = protoInt64.zero;

  /**
   * The current head slot of the network
   *
   * @generated from field: uint64 head_slot = 6;
   */
  headSlot = protoInt64.zero;

  /**
   * Indicates if data is available (overlapping interval exists)
   *
   * @generated from field: bool has_data = 7;
   */
  hasData = false;

  constructor(data?: PartialMessage<ExperimentDataAvailability>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.ExperimentDataAvailability";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "available_from_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "available_until_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "min_slot", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "max_slot", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "safe_slot", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 6, name: "head_slot", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 7, name: "has_data", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExperimentDataAvailability {
    return new ExperimentDataAvailability().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExperimentDataAvailability {
    return new ExperimentDataAvailability().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExperimentDataAvailability {
    return new ExperimentDataAvailability().fromJsonString(jsonString, options);
  }

  static equals(a: ExperimentDataAvailability | PlainMessage<ExperimentDataAvailability> | undefined, b: ExperimentDataAvailability | PlainMessage<ExperimentDataAvailability> | undefined): boolean {
    return proto3.util.equals(ExperimentDataAvailability, a, b);
  }
}

/**
 * GetExperimentConfigRequest defines the request for getting a single experiment's configuration.
 *
 * @generated from message config.GetExperimentConfigRequest
 */
export class GetExperimentConfigRequest extends Message<GetExperimentConfigRequest> {
  /**
   * The experiment ID to get configuration for
   *
   * @generated from field: string experiment_id = 1;
   */
  experimentId = "";

  constructor(data?: PartialMessage<GetExperimentConfigRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.GetExperimentConfigRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "experiment_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetExperimentConfigRequest {
    return new GetExperimentConfigRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetExperimentConfigRequest {
    return new GetExperimentConfigRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetExperimentConfigRequest {
    return new GetExperimentConfigRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetExperimentConfigRequest | PlainMessage<GetExperimentConfigRequest> | undefined, b: GetExperimentConfigRequest | PlainMessage<GetExperimentConfigRequest> | undefined): boolean {
    return proto3.util.equals(GetExperimentConfigRequest, a, b);
  }
}

/**
 * GetExperimentConfigResponse returns a single experiment's full configuration with data availability.
 *
 * @generated from message config.GetExperimentConfigResponse
 */
export class GetExperimentConfigResponse extends Message<GetExperimentConfigResponse> {
  /**
   * The experiment configuration with data availability
   *
   * @generated from field: config.ExperimentConfig experiment = 1;
   */
  experiment?: ExperimentConfig;

  constructor(data?: PartialMessage<GetExperimentConfigResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.GetExperimentConfigResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "experiment", kind: "message", T: ExperimentConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetExperimentConfigResponse {
    return new GetExperimentConfigResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetExperimentConfigResponse {
    return new GetExperimentConfigResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetExperimentConfigResponse {
    return new GetExperimentConfigResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetExperimentConfigResponse | PlainMessage<GetExperimentConfigResponse> | undefined, b: GetExperimentConfigResponse | PlainMessage<GetExperimentConfigResponse> | undefined): boolean {
    return proto3.util.equals(GetExperimentConfigResponse, a, b);
  }
}

