// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file backend/pkg/api/v1/proto/public.proto (package api.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * ListNodesResponse is the v1 API response for listing nodes with pagination.
 *
 * @generated from message api.v1.ListNodesResponse
 */
export class ListNodesResponse extends Message<ListNodesResponse> {
  /**
   * @generated from field: repeated api.v1.Node nodes = 1;
   */
  nodes: Node[] = [];

  /**
   * @generated from field: api.v1.PaginationMetadata pagination = 2;
   */
  pagination?: PaginationMetadata;

  /**
   * @generated from field: api.v1.FilterMetadata filters = 3;
   */
  filters?: FilterMetadata;

  constructor(data?: PartialMessage<ListNodesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ListNodesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nodes", kind: "message", T: Node, repeated: true },
    { no: 2, name: "pagination", kind: "message", T: PaginationMetadata },
    { no: 3, name: "filters", kind: "message", T: FilterMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListNodesResponse {
    return new ListNodesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListNodesResponse {
    return new ListNodesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListNodesResponse {
    return new ListNodesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListNodesResponse | PlainMessage<ListNodesResponse> | undefined, b: ListNodesResponse | PlainMessage<ListNodesResponse> | undefined): boolean {
    return proto3.util.equals(ListNodesResponse, a, b);
  }
}

/**
 * ListNetworksResponse is the v1 API response for listing available networks.
 *
 * @generated from message api.v1.ListNetworksResponse
 */
export class ListNetworksResponse extends Message<ListNetworksResponse> {
  /**
   * @generated from field: repeated api.v1.Network networks = 1;
   */
  networks: Network[] = [];

  /**
   * @generated from field: api.v1.NetworkFilterMetadata filters = 2;
   */
  filters?: NetworkFilterMetadata;

  constructor(data?: PartialMessage<ListNetworksResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ListNetworksResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "networks", kind: "message", T: Network, repeated: true },
    { no: 2, name: "filters", kind: "message", T: NetworkFilterMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListNetworksResponse {
    return new ListNetworksResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListNetworksResponse {
    return new ListNetworksResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListNetworksResponse {
    return new ListNetworksResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListNetworksResponse | PlainMessage<ListNetworksResponse> | undefined, b: ListNetworksResponse | PlainMessage<ListNetworksResponse> | undefined): boolean {
    return proto3.util.equals(ListNetworksResponse, a, b);
  }
}

/**
 * Node represents a transformed view of node data for public consumption.
 * This is a curated subset of fields from the internal structs,
 * formatted for client convenience (e.g., timestamps as ISO strings).
 *
 * @generated from message api.v1.Node
 */
export class Node extends Message<Node> {
  /**
   * @generated from field: string username = 1;
   */
  username = "";

  /**
   * @generated from field: string node_id = 2;
   */
  nodeId = "";

  /**
   * @generated from field: string classification = 3;
   */
  classification = "";

  /**
   * @generated from field: api.v1.ClientInfo client = 4;
   */
  client?: ClientInfo;

  /**
   * @generated from field: api.v1.GeoInfo geo = 5;
   */
  geo?: GeoInfo;

  /**
   * @generated from field: api.v1.ConsensusInfo consensus = 6;
   */
  consensus?: ConsensusInfo;

  /**
   * ISO 8601 formatted, not raw Unix timestamp
   *
   * @generated from field: string last_seen = 7;
   */
  lastSeen = "";

  constructor(data?: PartialMessage<Node>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.Node";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "node_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "classification", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "client", kind: "message", T: ClientInfo },
    { no: 5, name: "geo", kind: "message", T: GeoInfo },
    { no: 6, name: "consensus", kind: "message", T: ConsensusInfo },
    { no: 7, name: "last_seen", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Node {
    return new Node().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Node {
    return new Node().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Node {
    return new Node().fromJsonString(jsonString, options);
  }

  static equals(a: Node | PlainMessage<Node> | undefined, b: Node | PlainMessage<Node> | undefined): boolean {
    return proto3.util.equals(Node, a, b);
  }
}

/**
 * ClientInfo groups execution client metadata.
 *
 * @generated from message api.v1.ClientInfo
 */
export class ClientInfo extends Message<ClientInfo> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * @generated from field: string implementation = 3;
   */
  implementation = "";

  constructor(data?: PartialMessage<ClientInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ClientInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "implementation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientInfo {
    return new ClientInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientInfo {
    return new ClientInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientInfo {
    return new ClientInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ClientInfo | PlainMessage<ClientInfo> | undefined, b: ClientInfo | PlainMessage<ClientInfo> | undefined): boolean {
    return proto3.util.equals(ClientInfo, a, b);
  }
}

/**
 * GeoInfo groups geographical metadata.
 *
 * @generated from message api.v1.GeoInfo
 */
export class GeoInfo extends Message<GeoInfo> {
  /**
   * @generated from field: string city = 1;
   */
  city = "";

  /**
   * @generated from field: string country = 2;
   */
  country = "";

  /**
   * @generated from field: string country_code = 3;
   */
  countryCode = "";

  /**
   * @generated from field: string continent_code = 4;
   */
  continentCode = "";

  constructor(data?: PartialMessage<GeoInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.GeoInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "city", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "country", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "country_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "continent_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoInfo {
    return new GeoInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoInfo {
    return new GeoInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoInfo {
    return new GeoInfo().fromJsonString(jsonString, options);
  }

  static equals(a: GeoInfo | PlainMessage<GeoInfo> | undefined, b: GeoInfo | PlainMessage<GeoInfo> | undefined): boolean {
    return proto3.util.equals(GeoInfo, a, b);
  }
}

/**
 * ConsensusInfo groups consensus client metadata.
 *
 * @generated from message api.v1.ConsensusInfo
 */
export class ConsensusInfo extends Message<ConsensusInfo> {
  /**
   * @generated from field: string version = 1;
   */
  version = "";

  /**
   * @generated from field: string implementation = 2;
   */
  implementation = "";

  constructor(data?: PartialMessage<ConsensusInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ConsensusInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "implementation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConsensusInfo {
    return new ConsensusInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConsensusInfo {
    return new ConsensusInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConsensusInfo {
    return new ConsensusInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ConsensusInfo | PlainMessage<ConsensusInfo> | undefined, b: ConsensusInfo | PlainMessage<ConsensusInfo> | undefined): boolean {
    return proto3.util.equals(ConsensusInfo, a, b);
  }
}

/**
 * Pagination metadata following AIP-132.
 *
 * @generated from message api.v1.PaginationMetadata
 */
export class PaginationMetadata extends Message<PaginationMetadata> {
  /**
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0;

  /**
   * @generated from field: string page_token = 2;
   */
  pageToken = "";

  /**
   * @generated from field: string next_page_token = 3;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<PaginationMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.PaginationMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PaginationMetadata {
    return new PaginationMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PaginationMetadata {
    return new PaginationMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PaginationMetadata {
    return new PaginationMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: PaginationMetadata | PlainMessage<PaginationMetadata> | undefined, b: PaginationMetadata | PlainMessage<PaginationMetadata> | undefined): boolean {
    return proto3.util.equals(PaginationMetadata, a, b);
  }
}

/**
 * Filter metadata showing applied filters.
 *
 * @generated from message api.v1.FilterMetadata
 */
export class FilterMetadata extends Message<FilterMetadata> {
  /**
   * @generated from field: string network = 1;
   */
  network = "";

  /**
   * All filters including time filters
   *
   * @generated from field: map<string, string> applied_filters = 2;
   */
  appliedFilters: { [key: string]: string } = {};

  /**
   * @generated from field: string order_by = 3;
   */
  orderBy = "";

  constructor(data?: PartialMessage<FilterMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.FilterMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "network", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "applied_filters", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 3, name: "order_by", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilterMetadata {
    return new FilterMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilterMetadata {
    return new FilterMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilterMetadata {
    return new FilterMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: FilterMetadata | PlainMessage<FilterMetadata> | undefined, b: FilterMetadata | PlainMessage<FilterMetadata> | undefined): boolean {
    return proto3.util.equals(FilterMetadata, a, b);
  }
}

/**
 * Network represents an Ethereum network for public API consumption.
 * This provides essential network metadata needed by clients.
 *
 * @generated from message api.v1.Network
 */
export class Network extends Message<Network> {
  /**
   * Full network name (e.g., "mainnet", "sepolia", "fusaka-devnet-0")
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * "active", "inactive", or "unknown"
   *
   * @generated from field: string status = 2;
   */
  status = "";

  /**
   * Ethereum chain ID
   *
   * @generated from field: int64 chain_id = 3;
   */
  chainId = protoInt64.zero;

  /**
   * ISO 8601 formatted timestamp
   *
   * @generated from field: string last_updated = 4;
   */
  lastUpdated = "";

  constructor(data?: PartialMessage<Network>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.Network";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "chain_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "last_updated", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Network {
    return new Network().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Network {
    return new Network().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Network {
    return new Network().fromJsonString(jsonString, options);
  }

  static equals(a: Network | PlainMessage<Network> | undefined, b: Network | PlainMessage<Network> | undefined): boolean {
    return proto3.util.equals(Network, a, b);
  }
}

/**
 * NetworkFilterMetadata shows filtering information for network queries.
 *
 * @generated from message api.v1.NetworkFilterMetadata
 */
export class NetworkFilterMetadata extends Message<NetworkFilterMetadata> {
  /**
   * e.g., ["active_only"]
   *
   * @generated from field: repeated string applied_filters = 1;
   */
  appliedFilters: string[] = [];

  /**
   * Total networks before filtering
   *
   * @generated from field: int32 total_count = 2;
   */
  totalCount = 0;

  /**
   * Networks after filtering
   *
   * @generated from field: int32 filtered_count = 3;
   */
  filteredCount = 0;

  constructor(data?: PartialMessage<NetworkFilterMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.NetworkFilterMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "applied_filters", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "total_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "filtered_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NetworkFilterMetadata {
    return new NetworkFilterMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NetworkFilterMetadata {
    return new NetworkFilterMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NetworkFilterMetadata {
    return new NetworkFilterMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: NetworkFilterMetadata | PlainMessage<NetworkFilterMetadata> | undefined, b: NetworkFilterMetadata | PlainMessage<NetworkFilterMetadata> | undefined): boolean {
    return proto3.util.equals(NetworkFilterMetadata, a, b);
  }
}

/**
 * Error response.
 *
 * @generated from message api.v1.ErrorResponse
 */
export class ErrorResponse extends Message<ErrorResponse> {
  /**
   * @generated from field: string error = 1;
   */
  error = "";

  /**
   * @generated from field: string message = 2;
   */
  message = "";

  /**
   * @generated from field: int32 code = 3;
   */
  code = 0;

  constructor(data?: PartialMessage<ErrorResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ErrorResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "code", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ErrorResponse {
    return new ErrorResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ErrorResponse {
    return new ErrorResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ErrorResponse {
    return new ErrorResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ErrorResponse | PlainMessage<ErrorResponse> | undefined, b: ErrorResponse | PlainMessage<ErrorResponse> | undefined): boolean {
    return proto3.util.equals(ErrorResponse, a, b);
  }
}

/**
 * GetConfigResponse is the v1 API response for getting the complete lab configuration.
 *
 * @generated from message api.v1.GetConfigResponse
 */
export class GetConfigResponse extends Message<GetConfigResponse> {
  /**
   * @generated from field: api.v1.FrontendConfig config = 1;
   */
  config?: FrontendConfig;

  constructor(data?: PartialMessage<GetConfigResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.GetConfigResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "config", kind: "message", T: FrontendConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConfigResponse {
    return new GetConfigResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConfigResponse {
    return new GetConfigResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConfigResponse {
    return new GetConfigResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConfigResponse | PlainMessage<GetConfigResponse> | undefined, b: GetConfigResponse | PlainMessage<GetConfigResponse> | undefined): boolean {
    return proto3.util.equals(GetConfigResponse, a, b);
  }
}

/**
 * FrontendConfig represents the complete frontend configuration for public API consumption.
 *
 * @generated from message api.v1.FrontendConfig
 */
export class FrontendConfig extends Message<FrontendConfig> {
  /**
   * @generated from field: api.v1.EthereumConfig ethereum = 1;
   */
  ethereum?: EthereumConfig;

  /**
   * @generated from field: api.v1.ModulesConfig modules = 2;
   */
  modules?: ModulesConfig;

  constructor(data?: PartialMessage<FrontendConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.FrontendConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ethereum", kind: "message", T: EthereumConfig },
    { no: 2, name: "modules", kind: "message", T: ModulesConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FrontendConfig {
    return new FrontendConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FrontendConfig {
    return new FrontendConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FrontendConfig {
    return new FrontendConfig().fromJsonString(jsonString, options);
  }

  static equals(a: FrontendConfig | PlainMessage<FrontendConfig> | undefined, b: FrontendConfig | PlainMessage<FrontendConfig> | undefined): boolean {
    return proto3.util.equals(FrontendConfig, a, b);
  }
}

/**
 * EthereumConfig contains Ethereum-related configuration for public API consumption.
 *
 * @generated from message api.v1.EthereumConfig
 */
export class EthereumConfig extends Message<EthereumConfig> {
  /**
   * @generated from field: map<string, api.v1.NetworkConfig> networks = 1;
   */
  networks: { [key: string]: NetworkConfig } = {};

  constructor(data?: PartialMessage<EthereumConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.EthereumConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "networks", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: NetworkConfig} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EthereumConfig {
    return new EthereumConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EthereumConfig {
    return new EthereumConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EthereumConfig {
    return new EthereumConfig().fromJsonString(jsonString, options);
  }

  static equals(a: EthereumConfig | PlainMessage<EthereumConfig> | undefined, b: EthereumConfig | PlainMessage<EthereumConfig> | undefined): boolean {
    return proto3.util.equals(EthereumConfig, a, b);
  }
}

/**
 * NetworkConfig represents configuration for a single network for public API consumption.
 *
 * @generated from message api.v1.NetworkConfig
 */
export class NetworkConfig extends Message<NetworkConfig> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string status = 2;
   */
  status = "";

  /**
   * @generated from field: int64 chain_id = 3;
   */
  chainId = protoInt64.zero;

  /**
   * @generated from field: string description = 4;
   */
  description = "";

  /**
   * @generated from field: int64 genesis_time = 5;
   */
  genesisTime = protoInt64.zero;

  /**
   * @generated from field: map<string, string> service_urls = 6;
   */
  serviceUrls: { [key: string]: string } = {};

  /**
   * @generated from field: api.v1.ForkConfig forks = 7;
   */
  forks?: ForkConfig;

  /**
   * @generated from field: string last_updated = 8;
   */
  lastUpdated = "";

  constructor(data?: PartialMessage<NetworkConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.NetworkConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "chain_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "genesis_time", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "service_urls", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 7, name: "forks", kind: "message", T: ForkConfig },
    { no: 8, name: "last_updated", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NetworkConfig {
    return new NetworkConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NetworkConfig {
    return new NetworkConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NetworkConfig {
    return new NetworkConfig().fromJsonString(jsonString, options);
  }

  static equals(a: NetworkConfig | PlainMessage<NetworkConfig> | undefined, b: NetworkConfig | PlainMessage<NetworkConfig> | undefined): boolean {
    return proto3.util.equals(NetworkConfig, a, b);
  }
}

/**
 * ForkConfig contains fork information for public API consumption.
 *
 * @generated from message api.v1.ForkConfig
 */
export class ForkConfig extends Message<ForkConfig> {
  /**
   * @generated from field: api.v1.ConsensusForks consensus = 1;
   */
  consensus?: ConsensusForks;

  constructor(data?: PartialMessage<ForkConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ForkConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "consensus", kind: "message", T: ConsensusForks },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ForkConfig {
    return new ForkConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ForkConfig {
    return new ForkConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ForkConfig {
    return new ForkConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ForkConfig | PlainMessage<ForkConfig> | undefined, b: ForkConfig | PlainMessage<ForkConfig> | undefined): boolean {
    return proto3.util.equals(ForkConfig, a, b);
  }
}

/**
 * ConsensusForks contains consensus layer fork information for public API consumption.
 *
 * @generated from message api.v1.ConsensusForks
 */
export class ConsensusForks extends Message<ConsensusForks> {
  /**
   * @generated from field: api.v1.ForkInfo electra = 1;
   */
  electra?: ForkInfo;

  constructor(data?: PartialMessage<ConsensusForks>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ConsensusForks";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "electra", kind: "message", T: ForkInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConsensusForks {
    return new ConsensusForks().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConsensusForks {
    return new ConsensusForks().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConsensusForks {
    return new ConsensusForks().fromJsonString(jsonString, options);
  }

  static equals(a: ConsensusForks | PlainMessage<ConsensusForks> | undefined, b: ConsensusForks | PlainMessage<ConsensusForks> | undefined): boolean {
    return proto3.util.equals(ConsensusForks, a, b);
  }
}

/**
 * ForkInfo contains information about a specific fork for public API consumption.
 *
 * @generated from message api.v1.ForkInfo
 */
export class ForkInfo extends Message<ForkInfo> {
  /**
   * @generated from field: int64 epoch = 1;
   */
  epoch = protoInt64.zero;

  /**
   * @generated from field: map<string, string> min_client_versions = 2;
   */
  minClientVersions: { [key: string]: string } = {};

  constructor(data?: PartialMessage<ForkInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ForkInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "epoch", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "min_client_versions", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ForkInfo {
    return new ForkInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ForkInfo {
    return new ForkInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ForkInfo {
    return new ForkInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ForkInfo | PlainMessage<ForkInfo> | undefined, b: ForkInfo | PlainMessage<ForkInfo> | undefined): boolean {
    return proto3.util.equals(ForkInfo, a, b);
  }
}

/**
 * ModulesConfig contains all module configurations for public API consumption.
 *
 * @generated from message api.v1.ModulesConfig
 */
export class ModulesConfig extends Message<ModulesConfig> {
  /**
   * @generated from field: api.v1.BeaconChainTimingsModule beacon_chain_timings = 1;
   */
  beaconChainTimings?: BeaconChainTimingsModule;

  /**
   * @generated from field: api.v1.XatuPublicContributorsModule xatu_public_contributors = 2;
   */
  xatuPublicContributors?: XatuPublicContributorsModule;

  /**
   * @generated from field: api.v1.BeaconModule beacon = 3;
   */
  beacon?: BeaconModule;

  constructor(data?: PartialMessage<ModulesConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ModulesConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "beacon_chain_timings", kind: "message", T: BeaconChainTimingsModule },
    { no: 2, name: "xatu_public_contributors", kind: "message", T: XatuPublicContributorsModule },
    { no: 3, name: "beacon", kind: "message", T: BeaconModule },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModulesConfig {
    return new ModulesConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModulesConfig {
    return new ModulesConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModulesConfig {
    return new ModulesConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ModulesConfig | PlainMessage<ModulesConfig> | undefined, b: ModulesConfig | PlainMessage<ModulesConfig> | undefined): boolean {
    return proto3.util.equals(ModulesConfig, a, b);
  }
}

/**
 * BeaconChainTimingsModule configuration for public API consumption.
 *
 * @generated from message api.v1.BeaconChainTimingsModule
 */
export class BeaconChainTimingsModule extends Message<BeaconChainTimingsModule> {
  /**
   * @generated from field: repeated string networks = 1;
   */
  networks: string[] = [];

  /**
   * @generated from field: repeated api.v1.TimeWindow time_windows = 2;
   */
  timeWindows: TimeWindow[] = [];

  /**
   * @generated from field: string path_prefix = 3;
   */
  pathPrefix = "";

  constructor(data?: PartialMessage<BeaconChainTimingsModule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.BeaconChainTimingsModule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "networks", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "time_windows", kind: "message", T: TimeWindow, repeated: true },
    { no: 3, name: "path_prefix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BeaconChainTimingsModule {
    return new BeaconChainTimingsModule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BeaconChainTimingsModule {
    return new BeaconChainTimingsModule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BeaconChainTimingsModule {
    return new BeaconChainTimingsModule().fromJsonString(jsonString, options);
  }

  static equals(a: BeaconChainTimingsModule | PlainMessage<BeaconChainTimingsModule> | undefined, b: BeaconChainTimingsModule | PlainMessage<BeaconChainTimingsModule> | undefined): boolean {
    return proto3.util.equals(BeaconChainTimingsModule, a, b);
  }
}

/**
 * XatuPublicContributorsModule configuration for public API consumption.
 *
 * @generated from message api.v1.XatuPublicContributorsModule
 */
export class XatuPublicContributorsModule extends Message<XatuPublicContributorsModule> {
  /**
   * @generated from field: repeated string networks = 1;
   */
  networks: string[] = [];

  /**
   * @generated from field: repeated api.v1.TimeWindow time_windows = 2;
   */
  timeWindows: TimeWindow[] = [];

  /**
   * @generated from field: string path_prefix = 3;
   */
  pathPrefix = "";

  /**
   * @generated from field: bool enabled = 4;
   */
  enabled = false;

  constructor(data?: PartialMessage<XatuPublicContributorsModule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.XatuPublicContributorsModule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "networks", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "time_windows", kind: "message", T: TimeWindow, repeated: true },
    { no: 3, name: "path_prefix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): XatuPublicContributorsModule {
    return new XatuPublicContributorsModule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): XatuPublicContributorsModule {
    return new XatuPublicContributorsModule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): XatuPublicContributorsModule {
    return new XatuPublicContributorsModule().fromJsonString(jsonString, options);
  }

  static equals(a: XatuPublicContributorsModule | PlainMessage<XatuPublicContributorsModule> | undefined, b: XatuPublicContributorsModule | PlainMessage<XatuPublicContributorsModule> | undefined): boolean {
    return proto3.util.equals(XatuPublicContributorsModule, a, b);
  }
}

/**
 * BeaconModule configuration for public API consumption.
 *
 * @generated from message api.v1.BeaconModule
 */
export class BeaconModule extends Message<BeaconModule> {
  /**
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: string path_prefix = 3;
   */
  pathPrefix = "";

  /**
   * @generated from field: map<string, api.v1.BeaconNetworkConfig> networks = 4;
   */
  networks: { [key: string]: BeaconNetworkConfig } = {};

  constructor(data?: PartialMessage<BeaconModule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.BeaconModule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "path_prefix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "networks", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: BeaconNetworkConfig} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BeaconModule {
    return new BeaconModule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BeaconModule {
    return new BeaconModule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BeaconModule {
    return new BeaconModule().fromJsonString(jsonString, options);
  }

  static equals(a: BeaconModule | PlainMessage<BeaconModule> | undefined, b: BeaconModule | PlainMessage<BeaconModule> | undefined): boolean {
    return proto3.util.equals(BeaconModule, a, b);
  }
}

/**
 * BeaconNetworkConfig contains beacon-specific network configuration for public API consumption.
 *
 * @generated from message api.v1.BeaconNetworkConfig
 */
export class BeaconNetworkConfig extends Message<BeaconNetworkConfig> {
  /**
   * @generated from field: int32 head_lag_slots = 1;
   */
  headLagSlots = 0;

  /**
   * @generated from field: int32 backlog_days = 2;
   */
  backlogDays = 0;

  constructor(data?: PartialMessage<BeaconNetworkConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.BeaconNetworkConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "head_lag_slots", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "backlog_days", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BeaconNetworkConfig {
    return new BeaconNetworkConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BeaconNetworkConfig {
    return new BeaconNetworkConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BeaconNetworkConfig {
    return new BeaconNetworkConfig().fromJsonString(jsonString, options);
  }

  static equals(a: BeaconNetworkConfig | PlainMessage<BeaconNetworkConfig> | undefined, b: BeaconNetworkConfig | PlainMessage<BeaconNetworkConfig> | undefined): boolean {
    return proto3.util.equals(BeaconNetworkConfig, a, b);
  }
}

/**
 * TimeWindow represents a time window configuration for public API consumption.
 *
 * @generated from message api.v1.TimeWindow
 */
export class TimeWindow extends Message<TimeWindow> {
  /**
   * @generated from field: string file = 1;
   */
  file = "";

  /**
   * @generated from field: string step = 2;
   */
  step = "";

  /**
   * @generated from field: string range = 3;
   */
  range = "";

  /**
   * @generated from field: string label = 4;
   */
  label = "";

  constructor(data?: PartialMessage<TimeWindow>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.TimeWindow";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "file", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "step", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "range", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "label", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeWindow {
    return new TimeWindow().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeWindow {
    return new TimeWindow().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeWindow {
    return new TimeWindow().fromJsonString(jsonString, options);
  }

  static equals(a: TimeWindow | PlainMessage<TimeWindow> | undefined, b: TimeWindow | PlainMessage<TimeWindow> | undefined): boolean {
    return proto3.util.equals(TimeWindow, a, b);
  }
}

