// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file backend/pkg/api/v1/proto/public.proto (package api.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Struct } from "@bufbuild/protobuf";

/**
 * ListNodesResponse is the v1 API response for listing nodes with pagination.
 *
 * @generated from message api.v1.ListNodesResponse
 */
export class ListNodesResponse extends Message<ListNodesResponse> {
  /**
   * @generated from field: repeated api.v1.Node nodes = 1;
   */
  nodes: Node[] = [];

  /**
   * @generated from field: api.v1.PaginationMetadata pagination = 2;
   */
  pagination?: PaginationMetadata;

  /**
   * @generated from field: api.v1.FilterMetadata filters = 3;
   */
  filters?: FilterMetadata;

  constructor(data?: PartialMessage<ListNodesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ListNodesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nodes", kind: "message", T: Node, repeated: true },
    { no: 2, name: "pagination", kind: "message", T: PaginationMetadata },
    { no: 3, name: "filters", kind: "message", T: FilterMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListNodesResponse {
    return new ListNodesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListNodesResponse {
    return new ListNodesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListNodesResponse {
    return new ListNodesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListNodesResponse | PlainMessage<ListNodesResponse> | undefined, b: ListNodesResponse | PlainMessage<ListNodesResponse> | undefined): boolean {
    return proto3.util.equals(ListNodesResponse, a, b);
  }
}

/**
 * ListNetworksResponse is the v1 API response for listing available networks.
 *
 * @generated from message api.v1.ListNetworksResponse
 */
export class ListNetworksResponse extends Message<ListNetworksResponse> {
  /**
   * @generated from field: repeated api.v1.Network networks = 1;
   */
  networks: Network[] = [];

  /**
   * @generated from field: api.v1.NetworkFilterMetadata filters = 2;
   */
  filters?: NetworkFilterMetadata;

  constructor(data?: PartialMessage<ListNetworksResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ListNetworksResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "networks", kind: "message", T: Network, repeated: true },
    { no: 2, name: "filters", kind: "message", T: NetworkFilterMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListNetworksResponse {
    return new ListNetworksResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListNetworksResponse {
    return new ListNetworksResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListNetworksResponse {
    return new ListNetworksResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListNetworksResponse | PlainMessage<ListNetworksResponse> | undefined, b: ListNetworksResponse | PlainMessage<ListNetworksResponse> | undefined): boolean {
    return proto3.util.equals(ListNetworksResponse, a, b);
  }
}

/**
 * Node represents a transformed view of node data for public consumption.
 * This is a curated subset of fields from the internal structs,
 * formatted for client convenience (e.g., timestamps as ISO strings).
 *
 * @generated from message api.v1.Node
 */
export class Node extends Message<Node> {
  /**
   * @generated from field: string username = 1;
   */
  username = "";

  /**
   * @generated from field: string node_id = 2;
   */
  nodeId = "";

  /**
   * @generated from field: string classification = 3;
   */
  classification = "";

  /**
   * @generated from field: api.v1.ClientInfo client = 4;
   */
  client?: ClientInfo;

  /**
   * @generated from field: api.v1.GeoInfo geo = 5;
   */
  geo?: GeoInfo;

  /**
   * @generated from field: api.v1.ConsensusInfo consensus = 6;
   */
  consensus?: ConsensusInfo;

  /**
   * ISO 8601 formatted, not raw Unix timestamp
   *
   * @generated from field: string last_seen = 7;
   */
  lastSeen = "";

  constructor(data?: PartialMessage<Node>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.Node";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "node_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "classification", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "client", kind: "message", T: ClientInfo },
    { no: 5, name: "geo", kind: "message", T: GeoInfo },
    { no: 6, name: "consensus", kind: "message", T: ConsensusInfo },
    { no: 7, name: "last_seen", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Node {
    return new Node().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Node {
    return new Node().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Node {
    return new Node().fromJsonString(jsonString, options);
  }

  static equals(a: Node | PlainMessage<Node> | undefined, b: Node | PlainMessage<Node> | undefined): boolean {
    return proto3.util.equals(Node, a, b);
  }
}

/**
 * ClientInfo groups execution client metadata.
 *
 * @generated from message api.v1.ClientInfo
 */
export class ClientInfo extends Message<ClientInfo> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * @generated from field: string implementation = 3;
   */
  implementation = "";

  constructor(data?: PartialMessage<ClientInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ClientInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "implementation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientInfo {
    return new ClientInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientInfo {
    return new ClientInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientInfo {
    return new ClientInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ClientInfo | PlainMessage<ClientInfo> | undefined, b: ClientInfo | PlainMessage<ClientInfo> | undefined): boolean {
    return proto3.util.equals(ClientInfo, a, b);
  }
}

/**
 * GeoInfo groups geographical metadata.
 *
 * @generated from message api.v1.GeoInfo
 */
export class GeoInfo extends Message<GeoInfo> {
  /**
   * @generated from field: string city = 1;
   */
  city = "";

  /**
   * @generated from field: string country = 2;
   */
  country = "";

  /**
   * @generated from field: string country_code = 3;
   */
  countryCode = "";

  /**
   * @generated from field: string continent_code = 4;
   */
  continentCode = "";

  constructor(data?: PartialMessage<GeoInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.GeoInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "city", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "country", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "country_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "continent_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoInfo {
    return new GeoInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoInfo {
    return new GeoInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoInfo {
    return new GeoInfo().fromJsonString(jsonString, options);
  }

  static equals(a: GeoInfo | PlainMessage<GeoInfo> | undefined, b: GeoInfo | PlainMessage<GeoInfo> | undefined): boolean {
    return proto3.util.equals(GeoInfo, a, b);
  }
}

/**
 * ConsensusInfo groups consensus client metadata.
 *
 * @generated from message api.v1.ConsensusInfo
 */
export class ConsensusInfo extends Message<ConsensusInfo> {
  /**
   * @generated from field: string version = 1;
   */
  version = "";

  /**
   * @generated from field: string implementation = 2;
   */
  implementation = "";

  constructor(data?: PartialMessage<ConsensusInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ConsensusInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "implementation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConsensusInfo {
    return new ConsensusInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConsensusInfo {
    return new ConsensusInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConsensusInfo {
    return new ConsensusInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ConsensusInfo | PlainMessage<ConsensusInfo> | undefined, b: ConsensusInfo | PlainMessage<ConsensusInfo> | undefined): boolean {
    return proto3.util.equals(ConsensusInfo, a, b);
  }
}

/**
 * Pagination metadata following AIP-132.
 *
 * @generated from message api.v1.PaginationMetadata
 */
export class PaginationMetadata extends Message<PaginationMetadata> {
  /**
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0;

  /**
   * @generated from field: string page_token = 2;
   */
  pageToken = "";

  /**
   * @generated from field: string next_page_token = 3;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<PaginationMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.PaginationMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PaginationMetadata {
    return new PaginationMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PaginationMetadata {
    return new PaginationMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PaginationMetadata {
    return new PaginationMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: PaginationMetadata | PlainMessage<PaginationMetadata> | undefined, b: PaginationMetadata | PlainMessage<PaginationMetadata> | undefined): boolean {
    return proto3.util.equals(PaginationMetadata, a, b);
  }
}

/**
 * Filter metadata showing applied filters.
 *
 * @generated from message api.v1.FilterMetadata
 */
export class FilterMetadata extends Message<FilterMetadata> {
  /**
   * @generated from field: string network = 1;
   */
  network = "";

  /**
   * All filters including time filters
   *
   * @generated from field: map<string, string> applied_filters = 2;
   */
  appliedFilters: { [key: string]: string } = {};

  /**
   * @generated from field: string order_by = 3;
   */
  orderBy = "";

  constructor(data?: PartialMessage<FilterMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.FilterMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "network", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "applied_filters", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 3, name: "order_by", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilterMetadata {
    return new FilterMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilterMetadata {
    return new FilterMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilterMetadata {
    return new FilterMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: FilterMetadata | PlainMessage<FilterMetadata> | undefined, b: FilterMetadata | PlainMessage<FilterMetadata> | undefined): boolean {
    return proto3.util.equals(FilterMetadata, a, b);
  }
}

/**
 * Network represents an Ethereum network for public API consumption.
 * This provides essential network metadata needed by clients.
 *
 * @generated from message api.v1.Network
 */
export class Network extends Message<Network> {
  /**
   * Full network name (e.g., "mainnet", "sepolia", "fusaka-devnet-0")
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * "active", "inactive", or "unknown"
   *
   * @generated from field: string status = 2;
   */
  status = "";

  /**
   * Ethereum chain ID
   *
   * @generated from field: int64 chain_id = 3;
   */
  chainId = protoInt64.zero;

  /**
   * ISO 8601 formatted timestamp
   *
   * @generated from field: string last_updated = 4;
   */
  lastUpdated = "";

  constructor(data?: PartialMessage<Network>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.Network";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "chain_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "last_updated", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Network {
    return new Network().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Network {
    return new Network().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Network {
    return new Network().fromJsonString(jsonString, options);
  }

  static equals(a: Network | PlainMessage<Network> | undefined, b: Network | PlainMessage<Network> | undefined): boolean {
    return proto3.util.equals(Network, a, b);
  }
}

/**
 * NetworkFilterMetadata shows filtering information for network queries.
 *
 * @generated from message api.v1.NetworkFilterMetadata
 */
export class NetworkFilterMetadata extends Message<NetworkFilterMetadata> {
  /**
   * e.g., ["active_only"]
   *
   * @generated from field: repeated string applied_filters = 1;
   */
  appliedFilters: string[] = [];

  /**
   * Total networks before filtering
   *
   * @generated from field: int32 total_count = 2;
   */
  totalCount = 0;

  /**
   * Networks after filtering
   *
   * @generated from field: int32 filtered_count = 3;
   */
  filteredCount = 0;

  constructor(data?: PartialMessage<NetworkFilterMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.NetworkFilterMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "applied_filters", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "total_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "filtered_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NetworkFilterMetadata {
    return new NetworkFilterMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NetworkFilterMetadata {
    return new NetworkFilterMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NetworkFilterMetadata {
    return new NetworkFilterMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: NetworkFilterMetadata | PlainMessage<NetworkFilterMetadata> | undefined, b: NetworkFilterMetadata | PlainMessage<NetworkFilterMetadata> | undefined): boolean {
    return proto3.util.equals(NetworkFilterMetadata, a, b);
  }
}

/**
 * Error response.
 *
 * @generated from message api.v1.ErrorResponse
 */
export class ErrorResponse extends Message<ErrorResponse> {
  /**
   * @generated from field: string error = 1;
   */
  error = "";

  /**
   * @generated from field: string message = 2;
   */
  message = "";

  /**
   * @generated from field: int32 code = 3;
   */
  code = 0;

  /**
   * @generated from field: string request_id = 4;
   */
  requestId = "";

  constructor(data?: PartialMessage<ErrorResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ErrorResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "code", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ErrorResponse {
    return new ErrorResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ErrorResponse {
    return new ErrorResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ErrorResponse {
    return new ErrorResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ErrorResponse | PlainMessage<ErrorResponse> | undefined, b: ErrorResponse | PlainMessage<ErrorResponse> | undefined): boolean {
    return proto3.util.equals(ErrorResponse, a, b);
  }
}

/**
 * GetConfigResponse is the v1 API response for getting the complete lab configuration.
 *
 * @generated from message api.v1.GetConfigResponse
 */
export class GetConfigResponse extends Message<GetConfigResponse> {
  /**
   * @generated from field: api.v1.FrontendConfig config = 1;
   */
  config?: FrontendConfig;

  constructor(data?: PartialMessage<GetConfigResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.GetConfigResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "config", kind: "message", T: FrontendConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConfigResponse {
    return new GetConfigResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConfigResponse {
    return new GetConfigResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConfigResponse {
    return new GetConfigResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConfigResponse | PlainMessage<GetConfigResponse> | undefined, b: GetConfigResponse | PlainMessage<GetConfigResponse> | undefined): boolean {
    return proto3.util.equals(GetConfigResponse, a, b);
  }
}

/**
 * FrontendConfig represents the complete frontend configuration for public API consumption.
 *
 * @generated from message api.v1.FrontendConfig
 */
export class FrontendConfig extends Message<FrontendConfig> {
  /**
   * @generated from field: api.v1.EthereumConfig ethereum = 1;
   */
  ethereum?: EthereumConfig;

  /**
   * @generated from field: repeated api.v1.ExperimentConfig experiments = 2;
   */
  experiments: ExperimentConfig[] = [];

  constructor(data?: PartialMessage<FrontendConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.FrontendConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ethereum", kind: "message", T: EthereumConfig },
    { no: 2, name: "experiments", kind: "message", T: ExperimentConfig, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FrontendConfig {
    return new FrontendConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FrontendConfig {
    return new FrontendConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FrontendConfig {
    return new FrontendConfig().fromJsonString(jsonString, options);
  }

  static equals(a: FrontendConfig | PlainMessage<FrontendConfig> | undefined, b: FrontendConfig | PlainMessage<FrontendConfig> | undefined): boolean {
    return proto3.util.equals(FrontendConfig, a, b);
  }
}

/**
 * EthereumConfig contains Ethereum-related configuration for public API consumption.
 *
 * @generated from message api.v1.EthereumConfig
 */
export class EthereumConfig extends Message<EthereumConfig> {
  /**
   * @generated from field: map<string, api.v1.NetworkConfig> networks = 1;
   */
  networks: { [key: string]: NetworkConfig } = {};

  constructor(data?: PartialMessage<EthereumConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.EthereumConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "networks", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: NetworkConfig} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EthereumConfig {
    return new EthereumConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EthereumConfig {
    return new EthereumConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EthereumConfig {
    return new EthereumConfig().fromJsonString(jsonString, options);
  }

  static equals(a: EthereumConfig | PlainMessage<EthereumConfig> | undefined, b: EthereumConfig | PlainMessage<EthereumConfig> | undefined): boolean {
    return proto3.util.equals(EthereumConfig, a, b);
  }
}

/**
 * NetworkConfig represents configuration for a single network for public API consumption.
 *
 * @generated from message api.v1.NetworkConfig
 */
export class NetworkConfig extends Message<NetworkConfig> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string status = 2;
   */
  status = "";

  /**
   * @generated from field: int64 chain_id = 3;
   */
  chainId = protoInt64.zero;

  /**
   * @generated from field: string description = 4;
   */
  description = "";

  /**
   * @generated from field: int64 genesis_time = 5;
   */
  genesisTime = protoInt64.zero;

  /**
   * @generated from field: api.v1.ForkConfig forks = 6;
   */
  forks?: ForkConfig;

  /**
   * @generated from field: string last_updated = 7;
   */
  lastUpdated = "";

  constructor(data?: PartialMessage<NetworkConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.NetworkConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "chain_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "genesis_time", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "forks", kind: "message", T: ForkConfig },
    { no: 7, name: "last_updated", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NetworkConfig {
    return new NetworkConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NetworkConfig {
    return new NetworkConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NetworkConfig {
    return new NetworkConfig().fromJsonString(jsonString, options);
  }

  static equals(a: NetworkConfig | PlainMessage<NetworkConfig> | undefined, b: NetworkConfig | PlainMessage<NetworkConfig> | undefined): boolean {
    return proto3.util.equals(NetworkConfig, a, b);
  }
}

/**
 * ForkConfig contains fork information for public API consumption.
 *
 * @generated from message api.v1.ForkConfig
 */
export class ForkConfig extends Message<ForkConfig> {
  /**
   * @generated from field: api.v1.ConsensusForks consensus = 1;
   */
  consensus?: ConsensusForks;

  constructor(data?: PartialMessage<ForkConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ForkConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "consensus", kind: "message", T: ConsensusForks },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ForkConfig {
    return new ForkConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ForkConfig {
    return new ForkConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ForkConfig {
    return new ForkConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ForkConfig | PlainMessage<ForkConfig> | undefined, b: ForkConfig | PlainMessage<ForkConfig> | undefined): boolean {
    return proto3.util.equals(ForkConfig, a, b);
  }
}

/**
 * ConsensusForks contains consensus layer fork information for public API consumption.
 *
 * @generated from message api.v1.ConsensusForks
 */
export class ConsensusForks extends Message<ConsensusForks> {
  /**
   * @generated from field: api.v1.ForkInfo electra = 1;
   */
  electra?: ForkInfo;

  constructor(data?: PartialMessage<ConsensusForks>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ConsensusForks";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "electra", kind: "message", T: ForkInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConsensusForks {
    return new ConsensusForks().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConsensusForks {
    return new ConsensusForks().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConsensusForks {
    return new ConsensusForks().fromJsonString(jsonString, options);
  }

  static equals(a: ConsensusForks | PlainMessage<ConsensusForks> | undefined, b: ConsensusForks | PlainMessage<ConsensusForks> | undefined): boolean {
    return proto3.util.equals(ConsensusForks, a, b);
  }
}

/**
 * ForkInfo contains information about a specific fork for public API consumption.
 *
 * @generated from message api.v1.ForkInfo
 */
export class ForkInfo extends Message<ForkInfo> {
  /**
   * @generated from field: int64 epoch = 1;
   */
  epoch = protoInt64.zero;

  /**
   * @generated from field: map<string, string> min_client_versions = 2;
   */
  minClientVersions: { [key: string]: string } = {};

  constructor(data?: PartialMessage<ForkInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ForkInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "epoch", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "min_client_versions", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ForkInfo {
    return new ForkInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ForkInfo {
    return new ForkInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ForkInfo {
    return new ForkInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ForkInfo | PlainMessage<ForkInfo> | undefined, b: ForkInfo | PlainMessage<ForkInfo> | undefined): boolean {
    return proto3.util.equals(ForkInfo, a, b);
  }
}

/**
 * ExperimentsConfig contains all experiments configuration for public API consumption.
 *
 * @generated from message api.v1.ExperimentsConfig
 */
export class ExperimentsConfig extends Message<ExperimentsConfig> {
  /**
   * @generated from field: repeated api.v1.ExperimentConfig experiments = 1;
   */
  experiments: ExperimentConfig[] = [];

  constructor(data?: PartialMessage<ExperimentsConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ExperimentsConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "experiments", kind: "message", T: ExperimentConfig, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExperimentsConfig {
    return new ExperimentsConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExperimentsConfig {
    return new ExperimentsConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExperimentsConfig {
    return new ExperimentsConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ExperimentsConfig | PlainMessage<ExperimentsConfig> | undefined, b: ExperimentsConfig | PlainMessage<ExperimentsConfig> | undefined): boolean {
    return proto3.util.equals(ExperimentsConfig, a, b);
  }
}

/**
 * ExperimentConfig represents a single experiment for public API consumption.
 *
 * @generated from message api.v1.ExperimentConfig
 */
export class ExperimentConfig extends Message<ExperimentConfig> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: bool enabled = 2;
   */
  enabled = false;

  /**
   * @generated from field: repeated string networks = 3;
   */
  networks: string[] = [];

  /**
   * @generated from field: google.protobuf.Struct config = 4;
   */
  config?: Struct;

  /**
   * @generated from field: map<string, api.v1.ExperimentDataAvailability> data_availability = 5;
   */
  dataAvailability: { [key: string]: ExperimentDataAvailability } = {};

  constructor(data?: PartialMessage<ExperimentConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ExperimentConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "networks", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "config", kind: "message", T: Struct },
    { no: 5, name: "data_availability", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: ExperimentDataAvailability} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExperimentConfig {
    return new ExperimentConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExperimentConfig {
    return new ExperimentConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExperimentConfig {
    return new ExperimentConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ExperimentConfig | PlainMessage<ExperimentConfig> | undefined, b: ExperimentConfig | PlainMessage<ExperimentConfig> | undefined): boolean {
    return proto3.util.equals(ExperimentConfig, a, b);
  }
}

/**
 * ExperimentDataAvailability contains data availability information for an experiment on a specific network.
 *
 * @generated from message api.v1.ExperimentDataAvailability
 */
export class ExperimentDataAvailability extends Message<ExperimentDataAvailability> {
  /**
   * @generated from field: int64 available_from_timestamp = 1;
   */
  availableFromTimestamp = protoInt64.zero;

  /**
   * @generated from field: int64 available_until_timestamp = 2;
   */
  availableUntilTimestamp = protoInt64.zero;

  /**
   * @generated from field: uint64 min_slot = 3;
   */
  minSlot = protoInt64.zero;

  /**
   * @generated from field: uint64 max_slot = 4;
   */
  maxSlot = protoInt64.zero;

  /**
   * @generated from field: uint64 safe_slot = 5;
   */
  safeSlot = protoInt64.zero;

  /**
   * @generated from field: uint64 head_slot = 6;
   */
  headSlot = protoInt64.zero;

  /**
   * @generated from field: bool has_data = 7;
   */
  hasData = false;

  constructor(data?: PartialMessage<ExperimentDataAvailability>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ExperimentDataAvailability";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "available_from_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "available_until_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "min_slot", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "max_slot", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "safe_slot", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 6, name: "head_slot", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 7, name: "has_data", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExperimentDataAvailability {
    return new ExperimentDataAvailability().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExperimentDataAvailability {
    return new ExperimentDataAvailability().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExperimentDataAvailability {
    return new ExperimentDataAvailability().fromJsonString(jsonString, options);
  }

  static equals(a: ExperimentDataAvailability | PlainMessage<ExperimentDataAvailability> | undefined, b: ExperimentDataAvailability | PlainMessage<ExperimentDataAvailability> | undefined): boolean {
    return proto3.util.equals(ExperimentDataAvailability, a, b);
  }
}

/**
 * GetExperimentConfigRequest defines the request for getting a single experiment's configuration.
 *
 * @generated from message api.v1.GetExperimentConfigRequest
 */
export class GetExperimentConfigRequest extends Message<GetExperimentConfigRequest> {
  /**
   * @generated from field: string experiment_id = 1;
   */
  experimentId = "";

  constructor(data?: PartialMessage<GetExperimentConfigRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.GetExperimentConfigRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "experiment_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetExperimentConfigRequest {
    return new GetExperimentConfigRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetExperimentConfigRequest {
    return new GetExperimentConfigRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetExperimentConfigRequest {
    return new GetExperimentConfigRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetExperimentConfigRequest | PlainMessage<GetExperimentConfigRequest> | undefined, b: GetExperimentConfigRequest | PlainMessage<GetExperimentConfigRequest> | undefined): boolean {
    return proto3.util.equals(GetExperimentConfigRequest, a, b);
  }
}

/**
 * GetExperimentConfigResponse returns a single experiment's full configuration with data availability.
 *
 * @generated from message api.v1.GetExperimentConfigResponse
 */
export class GetExperimentConfigResponse extends Message<GetExperimentConfigResponse> {
  /**
   * @generated from field: api.v1.ExperimentConfig experiment = 1;
   */
  experiment?: ExperimentConfig;

  constructor(data?: PartialMessage<GetExperimentConfigResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.GetExperimentConfigResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "experiment", kind: "message", T: ExperimentConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetExperimentConfigResponse {
    return new GetExperimentConfigResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetExperimentConfigResponse {
    return new GetExperimentConfigResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetExperimentConfigResponse {
    return new GetExperimentConfigResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetExperimentConfigResponse | PlainMessage<GetExperimentConfigResponse> | undefined, b: GetExperimentConfigResponse | PlainMessage<GetExperimentConfigResponse> | undefined): boolean {
    return proto3.util.equals(GetExperimentConfigResponse, a, b);
  }
}

/**
 * BlockTimingResponse is the v1 API response for block timing data.
 *
 * @generated from message api.v1.BlockTimingResponse
 */
export class BlockTimingResponse extends Message<BlockTimingResponse> {
  /**
   * @generated from field: repeated api.v1.BlockTimingNode nodes = 1;
   */
  nodes: BlockTimingNode[] = [];

  /**
   * @generated from field: api.v1.PaginationMetadata pagination = 2;
   */
  pagination?: PaginationMetadata;

  /**
   * @generated from field: api.v1.FilterMetadata filters = 3;
   */
  filters?: FilterMetadata;

  constructor(data?: PartialMessage<BlockTimingResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.BlockTimingResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nodes", kind: "message", T: BlockTimingNode, repeated: true },
    { no: 2, name: "pagination", kind: "message", T: PaginationMetadata },
    { no: 3, name: "filters", kind: "message", T: FilterMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlockTimingResponse {
    return new BlockTimingResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlockTimingResponse {
    return new BlockTimingResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlockTimingResponse {
    return new BlockTimingResponse().fromJsonString(jsonString, options);
  }

  static equals(a: BlockTimingResponse | PlainMessage<BlockTimingResponse> | undefined, b: BlockTimingResponse | PlainMessage<BlockTimingResponse> | undefined): boolean {
    return proto3.util.equals(BlockTimingResponse, a, b);
  }
}

/**
 * BlockTimingNode represents a node that observed a block.
 *
 * @generated from message api.v1.BlockTimingNode
 */
export class BlockTimingNode extends Message<BlockTimingNode> {
  /**
   * @generated from field: string node_id = 1;
   */
  nodeId = "";

  /**
   * @generated from field: string username = 2;
   */
  username = "";

  /**
   * milliseconds from slot start
   *
   * @generated from field: int64 seen_diff_ms = 3;
   */
  seenDiffMs = protoInt64.zero;

  /**
   * reuse existing GeoInfo type
   *
   * @generated from field: api.v1.GeoInfo geo = 4;
   */
  geo?: GeoInfo;

  /**
   * reuse existing ClientInfo type
   *
   * @generated from field: api.v1.ClientInfo client = 5;
   */
  client?: ClientInfo;

  constructor(data?: PartialMessage<BlockTimingNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.BlockTimingNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "node_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "seen_diff_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "geo", kind: "message", T: GeoInfo },
    { no: 5, name: "client", kind: "message", T: ClientInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlockTimingNode {
    return new BlockTimingNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlockTimingNode {
    return new BlockTimingNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlockTimingNode {
    return new BlockTimingNode().fromJsonString(jsonString, options);
  }

  static equals(a: BlockTimingNode | PlainMessage<BlockTimingNode> | undefined, b: BlockTimingNode | PlainMessage<BlockTimingNode> | undefined): boolean {
    return proto3.util.equals(BlockTimingNode, a, b);
  }
}

