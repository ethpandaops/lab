// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file backend/pkg/api/v1/proto/public.proto (package api.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * ListNodesResponse is the v1 API response for listing nodes with pagination.
 *
 * @generated from message api.v1.ListNodesResponse
 */
export class ListNodesResponse extends Message<ListNodesResponse> {
  /**
   * @generated from field: repeated api.v1.Node nodes = 1;
   */
  nodes: Node[] = [];

  /**
   * @generated from field: api.v1.PaginationMetadata pagination = 2;
   */
  pagination?: PaginationMetadata;

  /**
   * @generated from field: api.v1.FilterMetadata filters = 3;
   */
  filters?: FilterMetadata;

  constructor(data?: PartialMessage<ListNodesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ListNodesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nodes", kind: "message", T: Node, repeated: true },
    { no: 2, name: "pagination", kind: "message", T: PaginationMetadata },
    { no: 3, name: "filters", kind: "message", T: FilterMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListNodesResponse {
    return new ListNodesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListNodesResponse {
    return new ListNodesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListNodesResponse {
    return new ListNodesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListNodesResponse | PlainMessage<ListNodesResponse> | undefined, b: ListNodesResponse | PlainMessage<ListNodesResponse> | undefined): boolean {
    return proto3.util.equals(ListNodesResponse, a, b);
  }
}

/**
 * ListNetworksResponse is the v1 API response for listing available networks.
 *
 * @generated from message api.v1.ListNetworksResponse
 */
export class ListNetworksResponse extends Message<ListNetworksResponse> {
  /**
   * @generated from field: repeated api.v1.Network networks = 1;
   */
  networks: Network[] = [];

  /**
   * @generated from field: api.v1.NetworkFilterMetadata filters = 2;
   */
  filters?: NetworkFilterMetadata;

  constructor(data?: PartialMessage<ListNetworksResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ListNetworksResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "networks", kind: "message", T: Network, repeated: true },
    { no: 2, name: "filters", kind: "message", T: NetworkFilterMetadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListNetworksResponse {
    return new ListNetworksResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListNetworksResponse {
    return new ListNetworksResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListNetworksResponse {
    return new ListNetworksResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListNetworksResponse | PlainMessage<ListNetworksResponse> | undefined, b: ListNetworksResponse | PlainMessage<ListNetworksResponse> | undefined): boolean {
    return proto3.util.equals(ListNetworksResponse, a, b);
  }
}

/**
 * Node represents a transformed view of node data for public consumption.
 * This is a curated subset of fields from the internal structs,
 * formatted for client convenience (e.g., timestamps as ISO strings).
 *
 * @generated from message api.v1.Node
 */
export class Node extends Message<Node> {
  /**
   * @generated from field: string username = 1;
   */
  username = "";

  /**
   * @generated from field: string node_id = 2;
   */
  nodeId = "";

  /**
   * @generated from field: string classification = 3;
   */
  classification = "";

  /**
   * @generated from field: api.v1.ClientInfo client = 4;
   */
  client?: ClientInfo;

  /**
   * @generated from field: api.v1.GeoInfo geo = 5;
   */
  geo?: GeoInfo;

  /**
   * @generated from field: api.v1.ConsensusInfo consensus = 6;
   */
  consensus?: ConsensusInfo;

  /**
   * ISO 8601 formatted, not raw Unix timestamp
   *
   * @generated from field: string last_seen = 7;
   */
  lastSeen = "";

  constructor(data?: PartialMessage<Node>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.Node";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "node_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "classification", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "client", kind: "message", T: ClientInfo },
    { no: 5, name: "geo", kind: "message", T: GeoInfo },
    { no: 6, name: "consensus", kind: "message", T: ConsensusInfo },
    { no: 7, name: "last_seen", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Node {
    return new Node().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Node {
    return new Node().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Node {
    return new Node().fromJsonString(jsonString, options);
  }

  static equals(a: Node | PlainMessage<Node> | undefined, b: Node | PlainMessage<Node> | undefined): boolean {
    return proto3.util.equals(Node, a, b);
  }
}

/**
 * ClientInfo groups execution client metadata.
 *
 * @generated from message api.v1.ClientInfo
 */
export class ClientInfo extends Message<ClientInfo> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * @generated from field: string implementation = 3;
   */
  implementation = "";

  constructor(data?: PartialMessage<ClientInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ClientInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "implementation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientInfo {
    return new ClientInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientInfo {
    return new ClientInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientInfo {
    return new ClientInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ClientInfo | PlainMessage<ClientInfo> | undefined, b: ClientInfo | PlainMessage<ClientInfo> | undefined): boolean {
    return proto3.util.equals(ClientInfo, a, b);
  }
}

/**
 * GeoInfo groups geographical metadata.
 *
 * @generated from message api.v1.GeoInfo
 */
export class GeoInfo extends Message<GeoInfo> {
  /**
   * @generated from field: string city = 1;
   */
  city = "";

  /**
   * @generated from field: string country = 2;
   */
  country = "";

  /**
   * @generated from field: string country_code = 3;
   */
  countryCode = "";

  /**
   * @generated from field: string continent_code = 4;
   */
  continentCode = "";

  constructor(data?: PartialMessage<GeoInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.GeoInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "city", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "country", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "country_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "continent_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoInfo {
    return new GeoInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoInfo {
    return new GeoInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoInfo {
    return new GeoInfo().fromJsonString(jsonString, options);
  }

  static equals(a: GeoInfo | PlainMessage<GeoInfo> | undefined, b: GeoInfo | PlainMessage<GeoInfo> | undefined): boolean {
    return proto3.util.equals(GeoInfo, a, b);
  }
}

/**
 * ConsensusInfo groups consensus client metadata.
 *
 * @generated from message api.v1.ConsensusInfo
 */
export class ConsensusInfo extends Message<ConsensusInfo> {
  /**
   * @generated from field: string version = 1;
   */
  version = "";

  /**
   * @generated from field: string implementation = 2;
   */
  implementation = "";

  constructor(data?: PartialMessage<ConsensusInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ConsensusInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "implementation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConsensusInfo {
    return new ConsensusInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConsensusInfo {
    return new ConsensusInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConsensusInfo {
    return new ConsensusInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ConsensusInfo | PlainMessage<ConsensusInfo> | undefined, b: ConsensusInfo | PlainMessage<ConsensusInfo> | undefined): boolean {
    return proto3.util.equals(ConsensusInfo, a, b);
  }
}

/**
 * Pagination metadata following AIP-132.
 *
 * @generated from message api.v1.PaginationMetadata
 */
export class PaginationMetadata extends Message<PaginationMetadata> {
  /**
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0;

  /**
   * @generated from field: string page_token = 2;
   */
  pageToken = "";

  /**
   * @generated from field: string next_page_token = 3;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<PaginationMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.PaginationMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PaginationMetadata {
    return new PaginationMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PaginationMetadata {
    return new PaginationMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PaginationMetadata {
    return new PaginationMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: PaginationMetadata | PlainMessage<PaginationMetadata> | undefined, b: PaginationMetadata | PlainMessage<PaginationMetadata> | undefined): boolean {
    return proto3.util.equals(PaginationMetadata, a, b);
  }
}

/**
 * Filter metadata showing applied filters.
 *
 * @generated from message api.v1.FilterMetadata
 */
export class FilterMetadata extends Message<FilterMetadata> {
  /**
   * @generated from field: string network = 1;
   */
  network = "";

  /**
   * All filters including time filters
   *
   * @generated from field: map<string, string> applied_filters = 2;
   */
  appliedFilters: { [key: string]: string } = {};

  /**
   * @generated from field: string order_by = 3;
   */
  orderBy = "";

  constructor(data?: PartialMessage<FilterMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.FilterMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "network", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "applied_filters", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 3, name: "order_by", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilterMetadata {
    return new FilterMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilterMetadata {
    return new FilterMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilterMetadata {
    return new FilterMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: FilterMetadata | PlainMessage<FilterMetadata> | undefined, b: FilterMetadata | PlainMessage<FilterMetadata> | undefined): boolean {
    return proto3.util.equals(FilterMetadata, a, b);
  }
}

/**
 * Network represents an Ethereum network for public API consumption.
 * This provides essential network metadata needed by clients.
 *
 * @generated from message api.v1.Network
 */
export class Network extends Message<Network> {
  /**
   * Full network name (e.g., "mainnet", "sepolia", "fusaka-devnet-0")
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * "active", "inactive", or "unknown"
   *
   * @generated from field: string status = 2;
   */
  status = "";

  /**
   * Ethereum chain ID
   *
   * @generated from field: int64 chain_id = 3;
   */
  chainId = protoInt64.zero;

  /**
   * ISO 8601 formatted timestamp
   *
   * @generated from field: string last_updated = 4;
   */
  lastUpdated = "";

  constructor(data?: PartialMessage<Network>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.Network";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "chain_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "last_updated", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Network {
    return new Network().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Network {
    return new Network().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Network {
    return new Network().fromJsonString(jsonString, options);
  }

  static equals(a: Network | PlainMessage<Network> | undefined, b: Network | PlainMessage<Network> | undefined): boolean {
    return proto3.util.equals(Network, a, b);
  }
}

/**
 * NetworkFilterMetadata shows filtering information for network queries.
 *
 * @generated from message api.v1.NetworkFilterMetadata
 */
export class NetworkFilterMetadata extends Message<NetworkFilterMetadata> {
  /**
   * e.g., ["active_only"]
   *
   * @generated from field: repeated string applied_filters = 1;
   */
  appliedFilters: string[] = [];

  /**
   * Total networks before filtering
   *
   * @generated from field: int32 total_count = 2;
   */
  totalCount = 0;

  /**
   * Networks after filtering
   *
   * @generated from field: int32 filtered_count = 3;
   */
  filteredCount = 0;

  constructor(data?: PartialMessage<NetworkFilterMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.NetworkFilterMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "applied_filters", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "total_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "filtered_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NetworkFilterMetadata {
    return new NetworkFilterMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NetworkFilterMetadata {
    return new NetworkFilterMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NetworkFilterMetadata {
    return new NetworkFilterMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: NetworkFilterMetadata | PlainMessage<NetworkFilterMetadata> | undefined, b: NetworkFilterMetadata | PlainMessage<NetworkFilterMetadata> | undefined): boolean {
    return proto3.util.equals(NetworkFilterMetadata, a, b);
  }
}

/**
 * Error response.
 *
 * @generated from message api.v1.ErrorResponse
 */
export class ErrorResponse extends Message<ErrorResponse> {
  /**
   * @generated from field: string error = 1;
   */
  error = "";

  /**
   * @generated from field: string message = 2;
   */
  message = "";

  /**
   * @generated from field: int32 code = 3;
   */
  code = 0;

  constructor(data?: PartialMessage<ErrorResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "api.v1.ErrorResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "code", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ErrorResponse {
    return new ErrorResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ErrorResponse {
    return new ErrorResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ErrorResponse {
    return new ErrorResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ErrorResponse | PlainMessage<ErrorResponse> | undefined, b: ErrorResponse | PlainMessage<ErrorResponse> | undefined): boolean {
    return proto3.util.equals(ErrorResponse, a, b);
  }
}

