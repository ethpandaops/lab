import { Routes, Route, Outlet, useSearchParams } from 'react-router-dom';
import { useEffect, useState } from 'react';
import { useAppStore } from '@/stores/appStore';
import { LoadingState } from '@/components/common/LoadingState';
import { ErrorState } from '@/components/common/ErrorState';
import ScrollToTop from '@/components/common/ScrollToTop';
import Redirect from '@/components/common/Redirect';
import XatuRedirect from '@/components/common/XatuRedirect';
import Home from '@/pages/Home.tsx';
import { About } from '@/pages/About.tsx';
import XatuData from '@/pages/xatu-data';
import XatuDataContributorsList from '@/pages/xatu-data/ContributorsList';
import XatuDataContributorDetail from '@/pages/xatu-data/ContributorDetail';
import XatuDataNetworks from '@/pages/xatu-data/networks';
import XatuDataGeographicalChecklist from '@/pages/xatu-data/geographical-checklist';
import XatuDataForkReadiness from '@/pages/xatu-data/fork-readiness';
import Layout from '@/components/layout/Layout';
import { Beacon } from '@/pages/beacon';
import { BeaconLive } from '@/pages/beacon/live';
import { BeaconSlot } from '@/pages/beacon/slot';
import Experiments from '@/pages/Experiments.tsx';
import { SlotLookup } from '@/pages/beacon/slot/index';
import { ModalProvider } from '@/contexts/ModalContext.tsx';
import { LocallyBuiltBlocks } from '@/pages/beacon/LocallyBuiltBlocks';
import BlockProductionLivePage from '@/pages/beacon/block-production/live.tsx';
import BlockProductionSlotPage from '@/pages/beacon/block-production/slot.tsx';
import ApplicationProvider from '@/providers/application';
import fetchBootstrap, { Bootstrap } from '@/bootstrap';
import { createLabApiClient, LabApiClient, Config } from '@/api/client.ts';
import { RestApiClient } from '@/api/rest/client';

function App() {
  const [bootstrap, setBootstrap] = useState<Bootstrap | null>(null);
  const [client, setClient] = useState<LabApiClient | null>(null);
  const [restClient, setRestClient] = useState<RestApiClient | null>(null);
  const [configError, setConfigError] = useState<Error | null>(null);
  const [bootstrapError, setBootstrapError] = useState<Error | null>(null);
  const [searchParams, setSearchParams] = useSearchParams();

  const {
    config,
    setConfig,
    selectedNetwork,
    setSelectedNetwork,
    availableNetworks,
    setAvailableNetworks,
  } = useAppStore();

  useEffect(() => {
    fetchBootstrap().then(setBootstrap).catch(setBootstrapError);
  }, []);

  useEffect(() => {
    if (bootstrap?.backend?.url) {
      setClient(createLabApiClient(bootstrap.backend.url));
      // Create REST client using the dedicated REST API URL if available, otherwise use the main URL
      const restApiUrl = bootstrap.backend.restApiUrl || bootstrap.backend.url;
      setRestClient(new RestApiClient(restApiUrl));
    }
  }, [bootstrap]);

  useEffect(() => {
    if (restClient) {
      restClient
        .getConfig()
        .then(response => {
          if (response.config) {
            setConfig(response.config);
            const networks = Object.keys(response.config.ethereum?.networks || {});
            setAvailableNetworks(networks);
          }
        })
        .catch(setConfigError);
    }
  }, [restClient, setConfig, setAvailableNetworks]);

  useEffect(() => {
    if (availableNetworks.length > 0) {
      // Get network from URL or use mainnet as default
      const networkFromUrl = searchParams.get('network');

      if (networkFromUrl && availableNetworks.includes(networkFromUrl)) {
        if (selectedNetwork !== networkFromUrl) {
          setSelectedNetwork(networkFromUrl);
        }
      } else if (!availableNetworks.includes(selectedNetwork)) {
        // If current network is not in available networks, switch to first available
        setSelectedNetwork(availableNetworks[0]);
      }
    }
  }, [availableNetworks, searchParams, selectedNetwork, setSelectedNetwork]);

  useEffect(() => {
    if (config) {
      const newParams = new URLSearchParams(searchParams);
      if (selectedNetwork === 'mainnet') {
        newParams.delete('network');
      } else {
        newParams.set('network', selectedNetwork);
      }
      setSearchParams(newParams, { replace: true });
    }
  }, [config, selectedNetwork, searchParams, setSearchParams]);

  if (configError) {
    return <ErrorState message="Failed to load configuration" error={configError} />;
  }

  if (bootstrapError) {
    return <ErrorState message="Failed to load bootstrap" error={bootstrapError} />;
  }

  if (!config) {
    return <LoadingState message="Loading configuration..." />;
  }

  if (!client) {
    return <ErrorState message="Failed to load API client" />;
  }

  if (!bootstrap) {
    return <LoadingState message="Loading bootstrap..." />;
  }

  return (
    <ApplicationProvider
      api={{ client, baseUrl: bootstrap.backend.url, restApiUrl: bootstrap.backend.restApiUrl }}
      beacon={{ config }}
    >
      <ModalProvider>
        <ScrollToTop />
        <Routes>
          <Route path="/" element={<Layout />}>
            <Route index element={<Home />} />
            <Route path="about" element={<About />} />
            <Route path="experiments" element={<Experiments />} />
            {/* Redirect all /xatu routes to /xatu-data */}
            <Route path="xatu" element={<XatuRedirect />} />
            <Route path="xatu/*" element={<XatuRedirect />} />
            <Route path="xatu-data" element={<XatuData />}>
              <Route path="contributors" element={<XatuDataContributorsList />} />
              <Route path="contributors/:name" element={<XatuDataContributorDetail />} />
              <Route path="networks" element={<XatuDataNetworks />} />
              <Route path="geographical-checklist" element={<XatuDataGeographicalChecklist />} />
              <Route path="fork-readiness" element={<XatuDataForkReadiness />} />
            </Route>
            <Route path="beacon" element={<Beacon />}>
              <Route path="slot" element={<Outlet />}>
                <Route index element={<SlotLookup />} />
                <Route path="live" element={<BeaconLive />} />
                <Route path=":slot" element={<BeaconSlot />} />
              </Route>
              <Route path="locally-built-blocks" element={<LocallyBuiltBlocks />} />
              <Route
                path="block-production"
                element={<Redirect to="/beacon/block-production/live" />}
              />
              <Route path="block-production/live" element={<BlockProductionLivePage />} />
              <Route path="block-production/:slot" element={<BlockProductionSlotPage />} />
            </Route>
          </Route>
        </Routes>
      </ModalProvider>
    </ApplicationProvider>
  );
}

export default App;
