package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

// TemplateData holds the data needed for the query method template
type TemplateData struct {
	ModelName    string
	TableName    string
	PackageName  string
	Params       []ParamField
	Imports      []string
	CategoryFile string
}

// ParamField represents a parameter field in the params struct
type ParamField struct {
	Name string
	Type string
}

// QueryMethodTemplate is the template for generating query methods
const QueryMethodTemplate = `package {{.PackageName}}

import (
	"context"
{{range .Imports}}	"{{.}}"
{{end}}
	"github.com/ethpandaops/lab/pkg/xatuclickhouse/models"
)

// {{.ModelName}}Params defines parameters for querying {{.TableName}} table
type {{.ModelName}}Params struct {
{{range .Params}}	{{.Name}} {{.Type}}
{{end}}	Limit     *uint64
	Offset    *uint64
}

// {{.ModelName}} queries the {{.TableName}} table
func (x *XatuClickhouse) {{.ModelName}}(
	ctx context.Context,
	params {{.ModelName}}Params,
) ([]models.{{.ModelName}}, error) {
	newModel := func() Model {
		return &models.{{.ModelName}}{}
	}

	results, err := x.QueryWithModel(ctx, newModel, params)
	if err != nil {
		return nil, err
	}

	typedResults := make([]models.{{.ModelName}}, len(results))
	for i, result := range results {
		typedResults[i] = *result.(*models.{{.ModelName}})
	}

	return typedResults, nil
}
`

func main() {
	// Set paths
	modelsDir := "../models"
	outputDir := ".."

	// Create maps for categorizing models by type
	categories := map[string][]TemplateData{
		"beacon_api":          {},
		"mempool":             {},
		"canonical_beacon":    {},
		"canonical_execution": {},
		"libp2p":              {},
		"mev_relay":           {},
		"miscellaneous":       {},
	}

	// Process each model file
	files, err := os.ReadDir(modelsDir)
	if err != nil {
		fmt.Printf("Error reading models directory: %v\n", err)
		os.Exit(1)
	}

	var imports []string
	timeImportNeeded := false

	// Parse each model file
	for _, file := range files {
		if file.IsDir() || !strings.HasSuffix(file.Name(), ".go") || strings.HasSuffix(file.Name(), "_test.go") {
			continue
		}

		modelFilePath := filepath.Join(modelsDir, file.Name())
		modelName, tableNameStr, fields, err := parseModelFile(modelFilePath)
		if err != nil {
			fmt.Printf("Error parsing %s: %v\n", file.Name(), err)
			continue
		}

		// Skip if this is not a model file
		if modelName == "" || tableNameStr == "" {
			continue
		}

		// Generate params fields based on model fields
		params := generateParamFields(fields)

		// Check if we need to import time
		for _, param := range params {
			if strings.Contains(param.Type, "time.Time") {
				timeImportNeeded = true
				break
			}
		}

		// Determine which category this model belongs to
		categoryFile := getCategoryFile(tableNameStr)

		// Add to the appropriate category
		templateData := TemplateData{
			ModelName:    modelName,
			TableName:    tableNameStr,
			PackageName:  "xatuclickhouse",
			Params:       params,
			CategoryFile: categoryFile,
		}

		if timeImportNeeded {
			imports = append(imports, "time")
		}
		templateData.Imports = imports

		category := getCategoryFromTableName(tableNameStr)
		categories[category] = append(categories[category], templateData)
	}

	// Generate files for each category
	for category, models := range categories {
		if len(models) == 0 {
			continue
		}

		// Only write to existing files
		outputFile := filepath.Join(outputDir, getCategoryFile(category))
		f, err := os.Create(outputFile)
		if err != nil {
			fmt.Printf("Error creating file %s: %v\n", outputFile, err)
			continue
		}

		// Write package declaration and imports
		fmt.Fprintf(f, "// Code generated by generate_query_methods.go; DO NOT EDIT.\n\n")
		fmt.Fprintf(f, "package xatuclickhouse\n\n")
		fmt.Fprintf(f, "import (\n")
		fmt.Fprintf(f, "\t\"context\"\n")
		if timeImportNeeded {
			fmt.Fprintf(f, "\t\"time\"\n")
		}
		fmt.Fprintf(f, "\n\t\"github.com/ethpandaops/lab/pkg/xatuclickhouse/models\"\n")
		fmt.Fprintf(f, ")\n\n")

		// Write each model's query method
		for _, data := range models {
			// Generate params struct
			fmt.Fprintf(f, "// %sParams defines parameters for querying %s table\n", data.ModelName, data.TableName)
			fmt.Fprintf(f, "type %sParams struct {\n", data.ModelName)
			for _, param := range data.Params {
				fmt.Fprintf(f, "\t%s %s\n", param.Name, param.Type)
			}
			fmt.Fprintf(f, "\tLimit  *uint64\n")
			fmt.Fprintf(f, "\tOffset *uint64\n")
			fmt.Fprintf(f, "}\n\n")

			// Generate query method
			fmt.Fprintf(f, "// %s queries the %s table\n", data.ModelName, data.TableName)
			fmt.Fprintf(f, "func (x *XatuClickhouse) %s(\n", data.ModelName)
			fmt.Fprintf(f, "\tctx context.Context,\n")
			fmt.Fprintf(f, "\tparams %sParams,\n", data.ModelName)
			fmt.Fprintf(f, ") ([]models.%s, error) {\n", data.ModelName)
			fmt.Fprintf(f, "\tnewModel := func() Model {\n")
			fmt.Fprintf(f, "\t\treturn &models.%s{}\n", data.ModelName)
			fmt.Fprintf(f, "\t}\n\n")
			fmt.Fprintf(f, "\tresults, err := x.QueryWithModel(ctx, newModel, params)\n")
			fmt.Fprintf(f, "\tif err != nil {\n")
			fmt.Fprintf(f, "\t\treturn nil, err\n")
			fmt.Fprintf(f, "\t}\n\n")
			fmt.Fprintf(f, "\ttypedResults := make([]models.%s, len(results))\n", data.ModelName)
			fmt.Fprintf(f, "\tfor i, result := range results {\n")
			fmt.Fprintf(f, "\t\ttypedResults[i] = *result.(*models.%s)\n", data.ModelName)
			fmt.Fprintf(f, "\t}\n\n")
			fmt.Fprintf(f, "\treturn typedResults, nil\n")
			fmt.Fprintf(f, "}\n\n")
		}

		f.Close()
	}

	fmt.Println("Generated query methods successfully!")
}

// parseModelFile parses a Go file and extracts model information
func parseModelFile(filePath string) (string, string, []ParamField, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return "", "", nil, err
	}

	var modelName, tableNameStr string
	var fields []ParamField

	for _, decl := range node.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			// Look for struct types
			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}

			// Skip *Params structs as they would be generated
			if strings.HasSuffix(typeSpec.Name.Name, "Params") {
				continue
			}

			// Only process types that look like models (start with capital letter)
			if len(typeSpec.Name.Name) > 0 && typeSpec.Name.Name[0] >= 'A' && typeSpec.Name.Name[0] <= 'Z' {
				modelName = typeSpec.Name.Name

				// Find TableName method to get table name
				for _, methodDecl := range node.Decls {
					funcDecl, ok := methodDecl.(*ast.FuncDecl)
					if !ok || funcDecl.Recv == nil || len(funcDecl.Recv.List) == 0 {
						continue
					}

					// Check if this is the TableName method for our model
					if funcDecl.Name.Name == "TableName" {
						recv, ok := funcDecl.Recv.List[0].Type.(*ast.StarExpr)
						if !ok {
							continue
						}

						recvIdent, ok := recv.X.(*ast.Ident)
						if !ok || recvIdent.Name != modelName {
							continue
						}

						// Extract string literal from return statement
						if funcDecl.Body != nil && len(funcDecl.Body.List) > 0 {
							returnStmt, ok := funcDecl.Body.List[0].(*ast.ReturnStmt)
							if !ok || len(returnStmt.Results) == 0 {
								continue
							}

							lit, ok := returnStmt.Results[0].(*ast.BasicLit)
							if !ok || lit.Kind != token.STRING {
								continue
							}

							// Strip quotes from string literal
							tableNameStr = strings.Trim(lit.Value, "\"")
						}
					}
				}

				// Process struct fields to generate params
				for _, field := range structType.Fields.List {
					if len(field.Names) == 0 {
						continue
					}

					fieldName := field.Names[0].Name

					// Skip meta fields for now
					if strings.HasPrefix(fieldName, "Meta") {
						continue
					}

					var typeStr string

					// Get the field type
					switch typExpr := field.Type.(type) {
					case *ast.Ident:
						typeStr = "*" + typExpr.Name
					case *ast.StarExpr:
						// Already a pointer type
						ident, ok := typExpr.X.(*ast.Ident)
						if ok {
							typeStr = "*" + ident.Name
						} else {
							// Handle more complex types
							typeStr = "*interface{}"
						}
					case *ast.ArrayType:
						// Handle array/slice types - skip these for params
						continue
					case *ast.MapType:
						// Handle map types - skip these for params
						continue
					case *ast.SelectorExpr:
						// Handle imported types like time.Time
						xIdent, ok := typExpr.X.(*ast.Ident)
						if ok {
							typeStr = "*" + xIdent.Name + "." + typExpr.Sel.Name
						} else {
							typeStr = "*interface{}"
						}
					default:
						// Skip unknown types
						continue
					}

					fields = append(fields, ParamField{
						Name: fieldName,
						Type: typeStr,
					})

					// Add range parameters for numeric and time fields
					if strings.Contains(typeStr, "int") ||
						strings.Contains(typeStr, "uint") ||
						strings.Contains(typeStr, "float") ||
						strings.Contains(typeStr, "Time") {
						fields = append(fields, ParamField{
							Name: "Start" + fieldName,
							Type: typeStr,
						})
						fields = append(fields, ParamField{
							Name: "End" + fieldName,
							Type: typeStr,
						})
					}
				}

				break
			}
		}
	}

	return modelName, tableNameStr, fields, nil
}

// generateParamFields generates parameter fields for the query params struct
func generateParamFields(modelFields []ParamField) []ParamField {
	// Limit the number of fields to keep the params struct manageable
	maxFields := 10
	if len(modelFields) > maxFields {
		return modelFields[:maxFields]
	}
	return modelFields
}

// getCategoryFromTableName determines which category a table belongs to
func getCategoryFromTableName(tableName string) string {
	if strings.HasPrefix(tableName, "beacon_api_") {
		return "beacon_api"
	} else if strings.HasPrefix(tableName, "mempool_") {
		return "mempool"
	} else if strings.HasPrefix(tableName, "canonical_beacon_") {
		return "canonical_beacon"
	} else if strings.HasPrefix(tableName, "canonical_execution_") {
		return "canonical_execution"
	} else if strings.HasPrefix(tableName, "libp2p_") {
		return "libp2p"
	} else if strings.HasPrefix(tableName, "mev_relay_") {
		return "mev_relay"
	}
	return "miscellaneous"
}

// getCategoryFile returns the file name for a category
func getCategoryFile(category string) string {
	if strings.HasPrefix(category, "beacon_api") {
		return "beacon_api.go"
	} else if strings.HasPrefix(category, "mempool") {
		return "mempool.go"
	} else if strings.HasPrefix(category, "canonical_beacon") {
		return "canonical_beacon.go"
	} else if strings.HasPrefix(category, "canonical_execution") {
		return "canonical_execution.go"
	} else if strings.HasPrefix(category, "libp2p") {
		return "libp2p.go"
	} else if strings.HasPrefix(category, "mev_relay") {
		return "mev_relay.go"
	}
	return "miscellaneous.go"
}
